# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ConnectionConfigurationsArgs',
    'ConnectionConfigurationsStreamArgs',
    'ConnectionScheduleArgs',
    'DestinationAstraConfigurationArgs',
    'DestinationAstraConfigurationEmbeddingArgs',
    'DestinationAstraConfigurationEmbeddingAzureOpenAiArgs',
    'DestinationAstraConfigurationEmbeddingCohereArgs',
    'DestinationAstraConfigurationEmbeddingFakeArgs',
    'DestinationAstraConfigurationEmbeddingOpenAiArgs',
    'DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs',
    'DestinationAstraConfigurationIndexingArgs',
    'DestinationAstraConfigurationProcessingArgs',
    'DestinationAstraConfigurationProcessingFieldNameMappingArgs',
    'DestinationAstraConfigurationProcessingTextSplitterArgs',
    'DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs',
    'DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs',
    'DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs',
    'DestinationAwsDatalakeConfigurationArgs',
    'DestinationAwsDatalakeConfigurationCredentialsArgs',
    'DestinationAwsDatalakeConfigurationCredentialsIamRoleArgs',
    'DestinationAwsDatalakeConfigurationCredentialsIamUserArgs',
    'DestinationAwsDatalakeConfigurationFormatArgs',
    'DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJsonArgs',
    'DestinationAwsDatalakeConfigurationFormatParquetColumnarStorageArgs',
    'DestinationAzureBlobStorageConfigurationArgs',
    'DestinationAzureBlobStorageConfigurationFormatArgs',
    'DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValuesArgs',
    'DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJsonArgs',
    'DestinationBigqueryConfigurationArgs',
    'DestinationBigqueryConfigurationLoadingMethodArgs',
    'DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs',
    'DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs',
    'DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKeyArgs',
    'DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs',
    'DestinationClickhouseConfigurationArgs',
    'DestinationClickhouseConfigurationTunnelMethodArgs',
    'DestinationClickhouseConfigurationTunnelMethodNoTunnelArgs',
    'DestinationClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationConvexConfigurationArgs',
    'DestinationDatabricksConfigurationArgs',
    'DestinationDatabricksConfigurationDataSourceArgs',
    'DestinationDatabricksConfigurationDataSourceAmazonS3Args',
    'DestinationDatabricksConfigurationDataSourceAzureBlobStorageArgs',
    'DestinationDatabricksConfigurationDataSourceRecommendedManagedTablesArgs',
    'DestinationDevNullConfigurationArgs',
    'DestinationDevNullConfigurationTestDestinationArgs',
    'DestinationDevNullConfigurationTestDestinationSilentArgs',
    'DestinationDuckdbConfigurationArgs',
    'DestinationDynamodbConfigurationArgs',
    'DestinationElasticsearchConfigurationArgs',
    'DestinationElasticsearchConfigurationAuthenticationMethodArgs',
    'DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs',
    'DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs',
    'DestinationFirestoreConfigurationArgs',
    'DestinationGcsConfigurationArgs',
    'DestinationGcsConfigurationCredentialArgs',
    'DestinationGcsConfigurationCredentialHmacKeyArgs',
    'DestinationGcsConfigurationFormatArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXzArgs',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesArgs',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonArgs',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs',
    'DestinationGcsConfigurationFormatParquetColumnarStorageArgs',
    'DestinationGoogleSheetsConfigurationArgs',
    'DestinationGoogleSheetsConfigurationCredentialsArgs',
    'DestinationLangchainConfigurationArgs',
    'DestinationLangchainConfigurationEmbeddingArgs',
    'DestinationLangchainConfigurationEmbeddingFakeArgs',
    'DestinationLangchainConfigurationEmbeddingOpenAiArgs',
    'DestinationLangchainConfigurationIndexingArgs',
    'DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs',
    'DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs',
    'DestinationLangchainConfigurationIndexingPineconeArgs',
    'DestinationLangchainConfigurationProcessingArgs',
    'DestinationMilvusConfigurationArgs',
    'DestinationMilvusConfigurationEmbeddingArgs',
    'DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs',
    'DestinationMilvusConfigurationEmbeddingCohereArgs',
    'DestinationMilvusConfigurationEmbeddingFakeArgs',
    'DestinationMilvusConfigurationEmbeddingOpenAiArgs',
    'DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs',
    'DestinationMilvusConfigurationIndexingArgs',
    'DestinationMilvusConfigurationIndexingAuthArgs',
    'DestinationMilvusConfigurationIndexingAuthApiTokenArgs',
    'DestinationMilvusConfigurationIndexingAuthNoAuthArgs',
    'DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs',
    'DestinationMilvusConfigurationProcessingArgs',
    'DestinationMilvusConfigurationProcessingFieldNameMappingArgs',
    'DestinationMilvusConfigurationProcessingTextSplitterArgs',
    'DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs',
    'DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs',
    'DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs',
    'DestinationMongodbConfigurationArgs',
    'DestinationMongodbConfigurationAuthTypeArgs',
    'DestinationMongodbConfigurationAuthTypeLoginPasswordArgs',
    'DestinationMongodbConfigurationAuthTypeNoneArgs',
    'DestinationMongodbConfigurationInstanceTypeArgs',
    'DestinationMongodbConfigurationInstanceTypeMongoDbAtlasArgs',
    'DestinationMongodbConfigurationInstanceTypeReplicaSetArgs',
    'DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstanceArgs',
    'DestinationMongodbConfigurationTunnelMethodArgs',
    'DestinationMongodbConfigurationTunnelMethodNoTunnelArgs',
    'DestinationMongodbConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationMongodbConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationMssqlConfigurationArgs',
    'DestinationMssqlConfigurationSslMethodArgs',
    'DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs',
    'DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs',
    'DestinationMssqlConfigurationTunnelMethodArgs',
    'DestinationMssqlConfigurationTunnelMethodNoTunnelArgs',
    'DestinationMssqlConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationMysqlConfigurationArgs',
    'DestinationMysqlConfigurationTunnelMethodArgs',
    'DestinationMysqlConfigurationTunnelMethodNoTunnelArgs',
    'DestinationMysqlConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationOracleConfigurationArgs',
    'DestinationOracleConfigurationTunnelMethodArgs',
    'DestinationOracleConfigurationTunnelMethodNoTunnelArgs',
    'DestinationOracleConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationOracleConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationPineconeConfigurationArgs',
    'DestinationPineconeConfigurationEmbeddingArgs',
    'DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs',
    'DestinationPineconeConfigurationEmbeddingCohereArgs',
    'DestinationPineconeConfigurationEmbeddingFakeArgs',
    'DestinationPineconeConfigurationEmbeddingOpenAiArgs',
    'DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs',
    'DestinationPineconeConfigurationIndexingArgs',
    'DestinationPineconeConfigurationProcessingArgs',
    'DestinationPineconeConfigurationProcessingFieldNameMappingArgs',
    'DestinationPineconeConfigurationProcessingTextSplitterArgs',
    'DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs',
    'DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs',
    'DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs',
    'DestinationPostgresConfigurationArgs',
    'DestinationPostgresConfigurationSslModeArgs',
    'DestinationPostgresConfigurationSslModeAllowArgs',
    'DestinationPostgresConfigurationSslModeDisableArgs',
    'DestinationPostgresConfigurationSslModePreferArgs',
    'DestinationPostgresConfigurationSslModeRequireArgs',
    'DestinationPostgresConfigurationSslModeVerifyCaArgs',
    'DestinationPostgresConfigurationSslModeVerifyFullArgs',
    'DestinationPostgresConfigurationTunnelMethodArgs',
    'DestinationPostgresConfigurationTunnelMethodNoTunnelArgs',
    'DestinationPostgresConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationPostgresConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationPubsubConfigurationArgs',
    'DestinationQdrantConfigurationArgs',
    'DestinationQdrantConfigurationEmbeddingArgs',
    'DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs',
    'DestinationQdrantConfigurationEmbeddingCohereArgs',
    'DestinationQdrantConfigurationEmbeddingFakeArgs',
    'DestinationQdrantConfigurationEmbeddingOpenAiArgs',
    'DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs',
    'DestinationQdrantConfigurationIndexingArgs',
    'DestinationQdrantConfigurationIndexingAuthMethodArgs',
    'DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuthArgs',
    'DestinationQdrantConfigurationIndexingAuthMethodNoAuthArgs',
    'DestinationQdrantConfigurationProcessingArgs',
    'DestinationQdrantConfigurationProcessingFieldNameMappingArgs',
    'DestinationQdrantConfigurationProcessingTextSplitterArgs',
    'DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs',
    'DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs',
    'DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs',
    'DestinationRedisConfigurationArgs',
    'DestinationRedisConfigurationSslModeArgs',
    'DestinationRedisConfigurationSslModeDisableArgs',
    'DestinationRedisConfigurationSslModeVerifyFullArgs',
    'DestinationRedisConfigurationTunnelMethodArgs',
    'DestinationRedisConfigurationTunnelMethodNoTunnelArgs',
    'DestinationRedisConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationRedisConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationRedshiftConfigurationArgs',
    'DestinationRedshiftConfigurationTunnelMethodArgs',
    'DestinationRedshiftConfigurationTunnelMethodNoTunnelArgs',
    'DestinationRedshiftConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationRedshiftConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'DestinationRedshiftConfigurationUploadingMethodArgs',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs',
    'DestinationRedshiftConfigurationUploadingMethodStandardArgs',
    'DestinationS3ConfigurationArgs',
    'DestinationS3ConfigurationFormatArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXzArgs',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesArgs',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonArgs',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs',
    'DestinationS3ConfigurationFormatParquetColumnarStorageArgs',
    'DestinationS3GlueConfigurationArgs',
    'DestinationS3GlueConfigurationFormatArgs',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonArgs',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs',
    'DestinationSftpJsonConfigurationArgs',
    'DestinationSnowflakeConfigurationArgs',
    'DestinationSnowflakeConfigurationCredentialsArgs',
    'DestinationSnowflakeConfigurationCredentialsKeyPairAuthenticationArgs',
    'DestinationSnowflakeConfigurationCredentialsOAuth20Args',
    'DestinationSnowflakeConfigurationCredentialsUsernameAndPasswordArgs',
    'DestinationSnowflakeCortexConfigurationArgs',
    'DestinationSnowflakeCortexConfigurationEmbeddingArgs',
    'DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs',
    'DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs',
    'DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs',
    'DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs',
    'DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs',
    'DestinationSnowflakeCortexConfigurationIndexingArgs',
    'DestinationSnowflakeCortexConfigurationIndexingCredentialsArgs',
    'DestinationSnowflakeCortexConfigurationProcessingArgs',
    'DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs',
    'DestinationTeradataConfigurationArgs',
    'DestinationTeradataConfigurationSslModeArgs',
    'DestinationTeradataConfigurationSslModeAllowArgs',
    'DestinationTeradataConfigurationSslModeDisableArgs',
    'DestinationTeradataConfigurationSslModePreferArgs',
    'DestinationTeradataConfigurationSslModeRequireArgs',
    'DestinationTeradataConfigurationSslModeVerifyCaArgs',
    'DestinationTeradataConfigurationSslModeVerifyFullArgs',
    'DestinationTypesenseConfigurationArgs',
    'DestinationVectaraConfigurationArgs',
    'DestinationVectaraConfigurationOauth2Args',
    'DestinationWeaviateConfigurationArgs',
    'DestinationWeaviateConfigurationEmbeddingArgs',
    'DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs',
    'DestinationWeaviateConfigurationEmbeddingCohereArgs',
    'DestinationWeaviateConfigurationEmbeddingFakeArgs',
    'DestinationWeaviateConfigurationEmbeddingFromFieldArgs',
    'DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs',
    'DestinationWeaviateConfigurationEmbeddingOpenAiArgs',
    'DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs',
    'DestinationWeaviateConfigurationIndexingArgs',
    'DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs',
    'DestinationWeaviateConfigurationIndexingAuthArgs',
    'DestinationWeaviateConfigurationIndexingAuthApiTokenArgs',
    'DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs',
    'DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs',
    'DestinationWeaviateConfigurationProcessingArgs',
    'DestinationWeaviateConfigurationProcessingFieldNameMappingArgs',
    'DestinationWeaviateConfigurationProcessingTextSplitterArgs',
    'DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs',
    'DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs',
    'DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs',
    'DestinationYellowbrickConfigurationArgs',
    'DestinationYellowbrickConfigurationSslModeArgs',
    'DestinationYellowbrickConfigurationSslModeAllowArgs',
    'DestinationYellowbrickConfigurationSslModeDisableArgs',
    'DestinationYellowbrickConfigurationSslModePreferArgs',
    'DestinationYellowbrickConfigurationSslModeRequireArgs',
    'DestinationYellowbrickConfigurationSslModeVerifyCaArgs',
    'DestinationYellowbrickConfigurationSslModeVerifyFullArgs',
    'DestinationYellowbrickConfigurationTunnelMethodArgs',
    'DestinationYellowbrickConfigurationTunnelMethodNoTunnelArgs',
    'DestinationYellowbrickConfigurationTunnelMethodPasswordAuthenticationArgs',
    'DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'SourceAhaConfigurationArgs',
    'SourceAircallConfigurationArgs',
    'SourceAirtableConfigurationArgs',
    'SourceAirtableConfigurationCredentialsArgs',
    'SourceAirtableConfigurationCredentialsOAuth20Args',
    'SourceAirtableConfigurationCredentialsPersonalAccessTokenArgs',
    'SourceAmazonAdsConfigurationArgs',
    'SourceAmazonSellerPartnerConfigurationArgs',
    'SourceAmazonSellerPartnerConfigurationReportOptionsListArgs',
    'SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs',
    'SourceAmazonSqsConfigurationArgs',
    'SourceAmplitudeConfigurationArgs',
    'SourceApifyDatasetConfigurationArgs',
    'SourceAppfollowConfigurationArgs',
    'SourceAsanaConfigurationArgs',
    'SourceAsanaConfigurationCredentialsArgs',
    'SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauthArgs',
    'SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs',
    'SourceAuth0ConfigurationArgs',
    'SourceAuth0ConfigurationCredentialsArgs',
    'SourceAuth0ConfigurationCredentialsOAuth2AccessTokenArgs',
    'SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplicationArgs',
    'SourceAwsCloudtrailConfigurationArgs',
    'SourceAzureBlobStorageConfigurationArgs',
    'SourceAzureBlobStorageConfigurationCredentialsArgs',
    'SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2Args',
    'SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKeyArgs',
    'SourceAzureBlobStorageConfigurationStreamArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatAvroFormatArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatJsonlFormatArgs',
    'SourceAzureBlobStorageConfigurationStreamFormatParquetFormatArgs',
    'SourceAzureTableConfigurationArgs',
    'SourceBambooHrConfigurationArgs',
    'SourceBigqueryConfigurationArgs',
    'SourceBingAdsConfigurationArgs',
    'SourceBingAdsConfigurationAccountNameArgs',
    'SourceBingAdsConfigurationCustomReportArgs',
    'SourceBraintreeConfigurationArgs',
    'SourceBrazeConfigurationArgs',
    'SourceCartConfigurationArgs',
    'SourceCartConfigurationCredentialsArgs',
    'SourceCartConfigurationCredentialsCentralApiRouterArgs',
    'SourceCartConfigurationCredentialsSingleStoreAccessTokenArgs',
    'SourceChargebeeConfigurationArgs',
    'SourceChartmogulConfigurationArgs',
    'SourceClickhouseConfigurationArgs',
    'SourceClickhouseConfigurationTunnelMethodArgs',
    'SourceClickhouseConfigurationTunnelMethodNoTunnelArgs',
    'SourceClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs',
    'SourceClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'SourceClickupApiConfigurationArgs',
    'SourceClockifyConfigurationArgs',
    'SourceCloseComConfigurationArgs',
    'SourceCodaConfigurationArgs',
    'SourceCoinApiConfigurationArgs',
    'SourceCoinmarketcapConfigurationArgs',
    'SourceConfigcatConfigurationArgs',
    'SourceConfluenceConfigurationArgs',
    'SourceConvexConfigurationArgs',
    'SourceDatascopeConfigurationArgs',
    'SourceDelightedConfigurationArgs',
    'SourceDixaConfigurationArgs',
    'SourceDockerhubConfigurationArgs',
    'SourceDremioConfigurationArgs',
    'SourceDynamodbConfigurationArgs',
    'SourceDynamodbConfigurationCredentialsArgs',
    'SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeysArgs',
    'SourceDynamodbConfigurationCredentialsRoleBasedAuthenticationArgs',
    'SourceEmailoctopusConfigurationArgs',
    'SourceExchangeRatesConfigurationArgs',
    'SourceFacebookMarketingConfigurationArgs',
    'SourceFacebookMarketingConfigurationCustomInsightArgs',
    'SourceFakerConfigurationArgs',
    'SourceFaunaConfigurationArgs',
    'SourceFaunaConfigurationCollectionArgs',
    'SourceFaunaConfigurationCollectionDeletionsArgs',
    'SourceFaunaConfigurationCollectionDeletionsDisabledArgs',
    'SourceFaunaConfigurationCollectionDeletionsEnabledArgs',
    'SourceFileConfigurationArgs',
    'SourceFileConfigurationProviderArgs',
    'SourceFileConfigurationProviderAzBlobAzureBlobStorageArgs',
    'SourceFileConfigurationProviderGcsGoogleCloudStorageArgs',
    'SourceFileConfigurationProviderHttpsPublicWebArgs',
    'SourceFileConfigurationProviderS3AmazonWebServicesArgs',
    'SourceFileConfigurationProviderScpSecureCopyProtocolArgs',
    'SourceFileConfigurationProviderSftpSecureFileTransferProtocolArgs',
    'SourceFileConfigurationProviderSshSecureShellArgs',
    'SourceFireboltConfigurationArgs',
    'SourceFreshcallerConfigurationArgs',
    'SourceFreshdeskConfigurationArgs',
    'SourceFreshsalesConfigurationArgs',
    'SourceGainsightPxConfigurationArgs',
    'SourceGcsConfigurationArgs',
    'SourceGcsConfigurationStreamArgs',
    'SourceGcsConfigurationStreamFormatArgs',
    'SourceGcsConfigurationStreamFormatCsvFormatArgs',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceGetlagoConfigurationArgs',
    'SourceGithubConfigurationArgs',
    'SourceGithubConfigurationCredentialsArgs',
    'SourceGithubConfigurationCredentialsOAuthArgs',
    'SourceGithubConfigurationCredentialsPersonalAccessTokenArgs',
    'SourceGitlabConfigurationArgs',
    'SourceGitlabConfigurationCredentialsArgs',
    'SourceGitlabConfigurationCredentialsOAuth20Args',
    'SourceGitlabConfigurationCredentialsPrivateTokenArgs',
    'SourceGlassfrogConfigurationArgs',
    'SourceGnewsConfigurationArgs',
    'SourceGoogleAdsConfigurationArgs',
    'SourceGoogleAdsConfigurationCredentialsArgs',
    'SourceGoogleAdsConfigurationCustomQueriesArrayArgs',
    'SourceGoogleAnalyticsDataApiConfigurationArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauthArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthenticationArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabledArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRangeArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRangeArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilterArgs',
    'SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationArgs',
    'SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs',
    'SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthenticationArgs',
    'SourceGoogleDirectoryConfigurationArgs',
    'SourceGoogleDirectoryConfigurationCredentialsArgs',
    'SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs',
    'SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs',
    'SourceGoogleDriveConfigurationArgs',
    'SourceGoogleDriveConfigurationCredentialsArgs',
    'SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuthArgs',
    'SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthenticationArgs',
    'SourceGoogleDriveConfigurationStreamArgs',
    'SourceGoogleDriveConfigurationStreamFormatArgs',
    'SourceGoogleDriveConfigurationStreamFormatAvroFormatArgs',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatArgs',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs',
    'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs',
    'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs',
    'SourceGoogleDriveConfigurationStreamFormatJsonlFormatArgs',
    'SourceGoogleDriveConfigurationStreamFormatParquetFormatArgs',
    'SourceGooglePagespeedInsightsConfigurationArgs',
    'SourceGoogleSearchConsoleConfigurationArgs',
    'SourceGoogleSearchConsoleConfigurationAuthorizationArgs',
    'SourceGoogleSearchConsoleConfigurationAuthorizationOAuthArgs',
    'SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthenticationArgs',
    'SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs',
    'SourceGoogleSheetsConfigurationArgs',
    'SourceGoogleSheetsConfigurationCredentialsArgs',
    'SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuthArgs',
    'SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthenticationArgs',
    'SourceGoogleWebfontsConfigurationArgs',
    'SourceGreenhouseConfigurationArgs',
    'SourceGridlyConfigurationArgs',
    'SourceHarvestConfigurationArgs',
    'SourceHarvestConfigurationCredentialsArgs',
    'SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuthArgs',
    'SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs',
    'SourceHubplannerConfigurationArgs',
    'SourceHubspotConfigurationArgs',
    'SourceHubspotConfigurationCredentialsArgs',
    'SourceHubspotConfigurationCredentialsOAuthArgs',
    'SourceHubspotConfigurationCredentialsPrivateAppArgs',
    'SourceInsightlyConfigurationArgs',
    'SourceInstagramConfigurationArgs',
    'SourceInstatusConfigurationArgs',
    'SourceIntercomConfigurationArgs',
    'SourceIp2whoisConfigurationArgs',
    'SourceIterableConfigurationArgs',
    'SourceJiraConfigurationArgs',
    'SourceK6CloudConfigurationArgs',
    'SourceKlarnaConfigurationArgs',
    'SourceKlaviyoConfigurationArgs',
    'SourceKyveConfigurationArgs',
    'SourceLaunchdarklyConfigurationArgs',
    'SourceLemlistConfigurationArgs',
    'SourceLeverHiringConfigurationArgs',
    'SourceLeverHiringConfigurationCredentialsArgs',
    'SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKeyArgs',
    'SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuthArgs',
    'SourceLinkedinAdsConfigurationArgs',
    'SourceLinkedinAdsConfigurationAdAnalyticsReportArgs',
    'SourceLinkedinAdsConfigurationCredentialsArgs',
    'SourceLinkedinAdsConfigurationCredentialsAccessTokenArgs',
    'SourceLinkedinAdsConfigurationCredentialsOAuth20Args',
    'SourceLinkedinPagesConfigurationArgs',
    'SourceLinkedinPagesConfigurationCredentialsArgs',
    'SourceLinkedinPagesConfigurationCredentialsAccessTokenArgs',
    'SourceLinkedinPagesConfigurationCredentialsOAuth20Args',
    'SourceLinnworksConfigurationArgs',
    'SourceLokaliseConfigurationArgs',
    'SourceMailchimpConfigurationArgs',
    'SourceMailchimpConfigurationCredentialsArgs',
    'SourceMailchimpConfigurationCredentialsApiKeyArgs',
    'SourceMailchimpConfigurationCredentialsOAuth20Args',
    'SourceMailgunConfigurationArgs',
    'SourceMailjetSmsConfigurationArgs',
    'SourceMarketoConfigurationArgs',
    'SourceMetabaseConfigurationArgs',
    'SourceMicrosoftOnedriveConfigurationArgs',
    'SourceMicrosoftOnedriveConfigurationCredentialsArgs',
    'SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs',
    'SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs',
    'SourceMicrosoftOnedriveConfigurationStreamArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormatArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormatArgs',
    'SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormatArgs',
    'SourceMicrosoftSharepointConfigurationArgs',
    'SourceMicrosoftSharepointConfigurationCredentialsArgs',
    'SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs',
    'SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs',
    'SourceMicrosoftSharepointConfigurationStreamArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatAvroFormatArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormatArgs',
    'SourceMicrosoftSharepointConfigurationStreamFormatParquetFormatArgs',
    'SourceMicrosoftTeamsConfigurationArgs',
    'SourceMicrosoftTeamsConfigurationCredentialsArgs',
    'SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftArgs',
    'SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20Args',
    'SourceMixpanelConfigurationArgs',
    'SourceMixpanelConfigurationCredentialsArgs',
    'SourceMixpanelConfigurationCredentialsProjectSecretArgs',
    'SourceMixpanelConfigurationCredentialsServiceAccountArgs',
    'SourceMondayConfigurationArgs',
    'SourceMondayConfigurationCredentialsArgs',
    'SourceMondayConfigurationCredentialsApiTokenArgs',
    'SourceMondayConfigurationCredentialsOAuth20Args',
    'SourceMongodbInternalPocConfigurationArgs',
    'SourceMongodbV2ConfigurationArgs',
    'SourceMongodbV2ConfigurationDatabaseConfigArgs',
    'SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs',
    'SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs',
    'SourceMssqlConfigurationArgs',
    'SourceMssqlConfigurationReplicationMethodArgs',
    'SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs',
    'SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs',
    'SourceMssqlConfigurationSslMethodArgs',
    'SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs',
    'SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs',
    'SourceMssqlConfigurationSslMethodUnencryptedArgs',
    'SourceMssqlConfigurationTunnelMethodArgs',
    'SourceMssqlConfigurationTunnelMethodNoTunnelArgs',
    'SourceMssqlConfigurationTunnelMethodPasswordAuthenticationArgs',
    'SourceMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'SourceMyHoursConfigurationArgs',
    'SourceMysqlConfigurationArgs',
    'SourceMysqlConfigurationReplicationMethodArgs',
    'SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs',
    'SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs',
    'SourceMysqlConfigurationSslModeArgs',
    'SourceMysqlConfigurationSslModePreferredArgs',
    'SourceMysqlConfigurationSslModeRequiredArgs',
    'SourceMysqlConfigurationSslModeVerifyCaArgs',
    'SourceMysqlConfigurationSslModeVerifyIdentityArgs',
    'SourceMysqlConfigurationTunnelMethodArgs',
    'SourceMysqlConfigurationTunnelMethodNoTunnelArgs',
    'SourceMysqlConfigurationTunnelMethodPasswordAuthenticationArgs',
    'SourceMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'SourceNetsuiteConfigurationArgs',
    'SourceNotionConfigurationArgs',
    'SourceNotionConfigurationCredentialsArgs',
    'SourceNotionConfigurationCredentialsAccessTokenArgs',
    'SourceNotionConfigurationCredentialsOAuth20Args',
    'SourceNytimesConfigurationArgs',
    'SourceOktaConfigurationArgs',
    'SourceOktaConfigurationCredentialsArgs',
    'SourceOktaConfigurationCredentialsApiTokenArgs',
    'SourceOktaConfigurationCredentialsOAuth20Args',
    'SourceOmnisendConfigurationArgs',
    'SourceOnesignalConfigurationArgs',
    'SourceOnesignalConfigurationApplicationArgs',
    'SourceOracleConfigurationArgs',
    'SourceOracleConfigurationConnectionDataArgs',
    'SourceOracleConfigurationConnectionDataServiceNameArgs',
    'SourceOracleConfigurationConnectionDataSystemIdsidArgs',
    'SourceOracleConfigurationEncryptionArgs',
    'SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs',
    'SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs',
    'SourceOracleConfigurationTunnelMethodArgs',
    'SourceOracleConfigurationTunnelMethodNoTunnelArgs',
    'SourceOracleConfigurationTunnelMethodPasswordAuthenticationArgs',
    'SourceOracleConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'SourceOrbConfigurationArgs',
    'SourceOrbitConfigurationArgs',
    'SourceOutbrainAmplifyConfigurationArgs',
    'SourceOutbrainAmplifyConfigurationCredentialsArgs',
    'SourceOutbrainAmplifyConfigurationCredentialsAccessTokenArgs',
    'SourceOutbrainAmplifyConfigurationCredentialsUsernamePasswordArgs',
    'SourceOutreachConfigurationArgs',
    'SourcePaypalTransactionConfigurationArgs',
    'SourcePaystackConfigurationArgs',
    'SourcePendoConfigurationArgs',
    'SourcePersistiqConfigurationArgs',
    'SourcePexelsApiConfigurationArgs',
    'SourcePinterestConfigurationArgs',
    'SourcePinterestConfigurationCredentialsArgs',
    'SourcePinterestConfigurationCustomReportArgs',
    'SourcePipedriveConfigurationArgs',
    'SourcePocketConfigurationArgs',
    'SourcePokeapiConfigurationArgs',
    'SourcePolygonStockApiConfigurationArgs',
    'SourcePostgresConfigurationArgs',
    'SourcePostgresConfigurationReplicationMethodArgs',
    'SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs',
    'SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs',
    'SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs',
    'SourcePostgresConfigurationSslModeArgs',
    'SourcePostgresConfigurationSslModeAllowArgs',
    'SourcePostgresConfigurationSslModeDisableArgs',
    'SourcePostgresConfigurationSslModePreferArgs',
    'SourcePostgresConfigurationSslModeRequireArgs',
    'SourcePostgresConfigurationSslModeVerifyCaArgs',
    'SourcePostgresConfigurationSslModeVerifyFullArgs',
    'SourcePostgresConfigurationTunnelMethodArgs',
    'SourcePostgresConfigurationTunnelMethodNoTunnelArgs',
    'SourcePostgresConfigurationTunnelMethodPasswordAuthenticationArgs',
    'SourcePostgresConfigurationTunnelMethodSshKeyAuthenticationArgs',
    'SourcePosthogConfigurationArgs',
    'SourcePostmarkappConfigurationArgs',
    'SourcePrestashopConfigurationArgs',
    'SourcePunkApiConfigurationArgs',
    'SourcePypiConfigurationArgs',
    'SourceQualarooConfigurationArgs',
    'SourceRailzConfigurationArgs',
    'SourceRechargeConfigurationArgs',
    'SourceRecreationConfigurationArgs',
    'SourceRecruiteeConfigurationArgs',
    'SourceRecurlyConfigurationArgs',
    'SourceRedshiftConfigurationArgs',
    'SourceRetentlyConfigurationArgs',
    'SourceRetentlyConfigurationCredentialsArgs',
    'SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuthArgs',
    'SourceRetentlyConfigurationCredentialsAuthenticateWithApiTokenArgs',
    'SourceRkiCovidConfigurationArgs',
    'SourceRssConfigurationArgs',
    'SourceS3ConfigurationArgs',
    'SourceS3ConfigurationFormatArgs',
    'SourceS3ConfigurationFormatAvroArgs',
    'SourceS3ConfigurationFormatCsvArgs',
    'SourceS3ConfigurationFormatJsonlArgs',
    'SourceS3ConfigurationFormatParquetArgs',
    'SourceS3ConfigurationProviderArgs',
    'SourceS3ConfigurationStreamArgs',
    'SourceS3ConfigurationStreamFormatArgs',
    'SourceS3ConfigurationStreamFormatAvroFormatArgs',
    'SourceS3ConfigurationStreamFormatCsvFormatArgs',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs',
    'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs',
    'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs',
    'SourceS3ConfigurationStreamFormatJsonlFormatArgs',
    'SourceS3ConfigurationStreamFormatParquetFormatArgs',
    'SourceSalesforceConfigurationArgs',
    'SourceSalesforceConfigurationStreamsCriteriaArgs',
    'SourceSalesloftConfigurationArgs',
    'SourceSalesloftConfigurationCredentialsArgs',
    'SourceSalesloftConfigurationCredentialsAuthenticateViaApiKeyArgs',
    'SourceSalesloftConfigurationCredentialsAuthenticateViaOAuthArgs',
    'SourceSapFieldglassConfigurationArgs',
    'SourceSecodaConfigurationArgs',
    'SourceSendgridConfigurationArgs',
    'SourceSendinblueConfigurationArgs',
    'SourceSenseforceConfigurationArgs',
    'SourceSentryConfigurationArgs',
    'SourceSftpBulkConfigurationArgs',
    'SourceSftpBulkConfigurationCredentialsArgs',
    'SourceSftpBulkConfigurationCredentialsAuthenticateViaPasswordArgs',
    'SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKeyArgs',
    'SourceSftpBulkConfigurationStreamArgs',
    'SourceSftpBulkConfigurationStreamFormatArgs',
    'SourceSftpBulkConfigurationStreamFormatAvroFormatArgs',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatArgs',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs',
    'SourceSftpBulkConfigurationStreamFormatJsonlFormatArgs',
    'SourceSftpBulkConfigurationStreamFormatParquetFormatArgs',
    'SourceSftpConfigurationArgs',
    'SourceSftpConfigurationCredentialsArgs',
    'SourceSftpConfigurationCredentialsPasswordAuthenticationArgs',
    'SourceSftpConfigurationCredentialsSshKeyAuthenticationArgs',
    'SourceShopifyConfigurationArgs',
    'SourceShopifyConfigurationCredentialsArgs',
    'SourceShopifyConfigurationCredentialsApiPasswordArgs',
    'SourceShopifyConfigurationCredentialsOAuth20Args',
    'SourceShortioConfigurationArgs',
    'SourceSlackConfigurationArgs',
    'SourceSlackConfigurationCredentialsArgs',
    'SourceSlackConfigurationCredentialsApiTokenArgs',
    'SourceSlackConfigurationCredentialsSignInViaSlackOAuthArgs',
    'SourceSmailyConfigurationArgs',
    'SourceSmartengageConfigurationArgs',
    'SourceSmartsheetsConfigurationArgs',
    'SourceSmartsheetsConfigurationCredentialsArgs',
    'SourceSmartsheetsConfigurationCredentialsApiAccessTokenArgs',
    'SourceSmartsheetsConfigurationCredentialsOAuth20Args',
    'SourceSnapchatMarketingConfigurationArgs',
    'SourceSnowflakeConfigurationArgs',
    'SourceSnowflakeConfigurationCredentialsArgs',
    'SourceSnowflakeConfigurationCredentialsOAuth20Args',
    'SourceSnowflakeConfigurationCredentialsUsernameAndPasswordArgs',
    'SourceSonarCloudConfigurationArgs',
    'SourceSpacexApiConfigurationArgs',
    'SourceSquareConfigurationArgs',
    'SourceSquareConfigurationCredentialsArgs',
    'SourceSquareConfigurationCredentialsApiKeyArgs',
    'SourceSquareConfigurationCredentialsOauthAuthenticationArgs',
    'SourceStravaConfigurationArgs',
    'SourceStripeConfigurationArgs',
    'SourceSurveySparrowConfigurationArgs',
    'SourceSurveySparrowConfigurationRegionArgs',
    'SourceSurveySparrowConfigurationRegionEuBasedAccountArgs',
    'SourceSurveySparrowConfigurationRegionGlobalAccountArgs',
    'SourceSurveymonkeyConfigurationArgs',
    'SourceSurveymonkeyConfigurationCredentialsArgs',
    'SourceTempoConfigurationArgs',
    'SourceTheGuardianApiConfigurationArgs',
    'SourceTiktokMarketingConfigurationArgs',
    'SourceTiktokMarketingConfigurationCredentialsArgs',
    'SourceTiktokMarketingConfigurationCredentialsOAuth20Args',
    'SourceTiktokMarketingConfigurationCredentialsSandboxAccessTokenArgs',
    'SourceTrelloConfigurationArgs',
    'SourceTrustpilotConfigurationArgs',
    'SourceTrustpilotConfigurationCredentialsArgs',
    'SourceTrustpilotConfigurationCredentialsApiKeyArgs',
    'SourceTrustpilotConfigurationCredentialsOAuth20Args',
    'SourceTvmazeScheduleConfigurationArgs',
    'SourceTwilioConfigurationArgs',
    'SourceTwilioTaskrouterConfigurationArgs',
    'SourceTwitterConfigurationArgs',
    'SourceTypeformConfigurationArgs',
    'SourceTypeformConfigurationCredentialsArgs',
    'SourceTypeformConfigurationCredentialsOAuth20Args',
    'SourceTypeformConfigurationCredentialsPrivateTokenArgs',
    'SourceUsCensusConfigurationArgs',
    'SourceVantageConfigurationArgs',
    'SourceWebflowConfigurationArgs',
    'SourceWhiskyHunterConfigurationArgs',
    'SourceWikipediaPageviewsConfigurationArgs',
    'SourceWoocommerceConfigurationArgs',
    'SourceXkcdConfigurationArgs',
    'SourceYandexMetricaConfigurationArgs',
    'SourceYotpoConfigurationArgs',
    'SourceYoutubeAnalyticsConfigurationArgs',
    'SourceYoutubeAnalyticsConfigurationCredentialsArgs',
    'SourceZendeskChatConfigurationArgs',
    'SourceZendeskChatConfigurationCredentialsArgs',
    'SourceZendeskChatConfigurationCredentialsAccessTokenArgs',
    'SourceZendeskChatConfigurationCredentialsOAuth20Args',
    'SourceZendeskSellConfigurationArgs',
    'SourceZendeskSunshineConfigurationArgs',
    'SourceZendeskSunshineConfigurationCredentialsArgs',
    'SourceZendeskSunshineConfigurationCredentialsApiTokenArgs',
    'SourceZendeskSunshineConfigurationCredentialsOAuth20Args',
    'SourceZendeskSupportConfigurationArgs',
    'SourceZendeskSupportConfigurationCredentialsArgs',
    'SourceZendeskSupportConfigurationCredentialsApiTokenArgs',
    'SourceZendeskSupportConfigurationCredentialsOAuth20Args',
    'SourceZendeskTalkConfigurationArgs',
    'SourceZendeskTalkConfigurationCredentialsArgs',
    'SourceZendeskTalkConfigurationCredentialsApiTokenArgs',
    'SourceZendeskTalkConfigurationCredentialsOAuth20Args',
    'SourceZenloopConfigurationArgs',
    'SourceZohoCrmConfigurationArgs',
    'SourceZoomConfigurationArgs',
]

@pulumi.input_type
class ConnectionConfigurationsArgs:
    def __init__(__self__, *,
                 streams: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionConfigurationsStreamArgs']]]] = None):
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def streams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionConfigurationsStreamArgs']]]]:
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectionConfigurationsStreamArgs']]]]):
        pulumi.set(self, "streams", value)


@pulumi.input_type
class ConnectionConfigurationsStreamArgs:
    def __init__(__self__, *,
                 cursor_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]] = None,
                 sync_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cursor_fields: Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
        :param pulumi.Input[str] name: Not Null
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]] primary_keys: Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
        :param pulumi.Input[str] sync_mode: must be one of ["full_refresh_overwrite", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
        """
        if cursor_fields is not None:
            pulumi.set(__self__, "cursor_fields", cursor_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if sync_mode is not None:
            pulumi.set(__self__, "sync_mode", sync_mode)

    @property
    @pulumi.getter(name="cursorFields")
    def cursor_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
        """
        return pulumi.get(self, "cursor_fields")

    @cursor_fields.setter
    def cursor_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cursor_fields", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Not Null
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]]:
        """
        Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
        """
        return pulumi.get(self, "primary_keys")

    @primary_keys.setter
    def primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]]):
        pulumi.set(self, "primary_keys", value)

    @property
    @pulumi.getter(name="syncMode")
    def sync_mode(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["full_refresh_overwrite", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
        """
        return pulumi.get(self, "sync_mode")

    @sync_mode.setter
    def sync_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sync_mode", value)


@pulumi.input_type
class ConnectionScheduleArgs:
    def __init__(__self__, *,
                 basic_timing: Optional[pulumi.Input[str]] = None,
                 cron_expression: Optional[pulumi.Input[str]] = None,
                 schedule_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] schedule_type: Not Null; must be one of ["manual", "cron"]
        """
        if basic_timing is not None:
            pulumi.set(__self__, "basic_timing", basic_timing)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if schedule_type is not None:
            pulumi.set(__self__, "schedule_type", schedule_type)

    @property
    @pulumi.getter(name="basicTiming")
    def basic_timing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "basic_timing")

    @basic_timing.setter
    def basic_timing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "basic_timing", value)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> Optional[pulumi.Input[str]]:
        """
        Not Null; must be one of ["manual", "cron"]
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_type", value)


@pulumi.input_type
class DestinationAstraConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationAstraConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationAstraConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationAstraConfigurationProcessingArgs'],
                 omit_raw_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DestinationAstraConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationAstraConfigurationIndexingArgs'] indexing: Astra DB gives developers the APIs, real-time data and ecosystem integrations to put accurate RAG and Gen AI apps with fewer hallucinations in production.
        :param pulumi.Input[bool] omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationAstraConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationAstraConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationAstraConfigurationIndexingArgs']:
        """
        Astra DB gives developers the APIs, real-time data and ecosystem integrations to put accurate RAG and Gen AI apps with fewer hallucinations in production.
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationAstraConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationAstraConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationAstraConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")

    @omit_raw_text.setter
    def omit_raw_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_raw_text", value)


@pulumi.input_type
class DestinationAstraConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 azure_open_ai: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingAzureOpenAiArgs']] = None,
                 cohere: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingCohereArgs']] = None,
                 fake: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingFakeArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiArgs']] = None,
                 open_ai_compatible: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs']] = None):
        """
        :param pulumi.Input['DestinationAstraConfigurationEmbeddingAzureOpenAiArgs'] azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationAstraConfigurationEmbeddingCohereArgs'] cohere: Use the Cohere API to embed text.
        :param pulumi.Input['DestinationAstraConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs'] open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingAzureOpenAiArgs']]:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @azure_open_ai.setter
    def azure_open_ai(self, value: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingAzureOpenAiArgs']]):
        pulumi.set(self, "azure_open_ai", value)

    @property
    @pulumi.getter
    def cohere(self) -> Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingCohereArgs']]:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @cohere.setter
    def cohere(self, value: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingCohereArgs']]):
        pulumi.set(self, "cohere", value)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs']]:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")

    @open_ai_compatible.setter
    def open_ai_compatible(self, value: Optional[pulumi.Input['DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs']]):
        pulumi.set(self, "open_ai_compatible", value)


@pulumi.input_type
class DestinationAstraConfigurationEmbeddingAzureOpenAiArgs:
    def __init__(__self__, *,
                 api_base: pulumi.Input[str],
                 deployment: pulumi.Input[str],
                 openai_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> pulumi.Input[str]:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @api_base.setter
    def api_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_base", value)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationAstraConfigurationEmbeddingCohereArgs:
    def __init__(__self__, *,
                 cohere_key: pulumi.Input[str]):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cohere_key")

    @cohere_key.setter
    def cohere_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "cohere_key", value)


@pulumi.input_type
class DestinationAstraConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationAstraConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 dimensions: pulumi.Input[int],
                 api_key: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The base URL for your OpenAI-compatible service
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] api_key: Default: ""
        :param pulumi.Input[str] model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)


@pulumi.input_type
class DestinationAstraConfigurationIndexingArgs:
    def __init__(__self__, *,
                 astra_db_app_token: pulumi.Input[str],
                 astra_db_endpoint: pulumi.Input[str],
                 astra_db_keyspace: pulumi.Input[str],
                 collection: pulumi.Input[str]):
        """
        :param pulumi.Input[str] astra_db_app_token: The application token authorizes a user to connect to a specific Astra DB database. It is created when the user clicks the Generate Token button on the Overview tab of the Database page in the Astra UI.
        :param pulumi.Input[str] astra_db_endpoint: The endpoint specifies which Astra DB database queries are sent to. It can be copied from the Database Details section of the Overview tab of the Database page in the Astra UI.
        :param pulumi.Input[str] astra_db_keyspace: Keyspaces (or Namespaces) serve as containers for organizing data within a database. You can create a new keyspace uisng the Data Explorer tab in the Astra UI. The keyspace default_keyspace is created for you when you create a Vector Database in Astra DB.
        :param pulumi.Input[str] collection: Collections hold data. They are analagous to tables in traditional Cassandra terminology. This tool will create the collection with the provided name automatically if it does not already exist. Alternatively, you can create one thorugh the Data Explorer tab in the Astra UI.
        """
        pulumi.set(__self__, "astra_db_app_token", astra_db_app_token)
        pulumi.set(__self__, "astra_db_endpoint", astra_db_endpoint)
        pulumi.set(__self__, "astra_db_keyspace", astra_db_keyspace)
        pulumi.set(__self__, "collection", collection)

    @property
    @pulumi.getter(name="astraDbAppToken")
    def astra_db_app_token(self) -> pulumi.Input[str]:
        """
        The application token authorizes a user to connect to a specific Astra DB database. It is created when the user clicks the Generate Token button on the Overview tab of the Database page in the Astra UI.
        """
        return pulumi.get(self, "astra_db_app_token")

    @astra_db_app_token.setter
    def astra_db_app_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "astra_db_app_token", value)

    @property
    @pulumi.getter(name="astraDbEndpoint")
    def astra_db_endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint specifies which Astra DB database queries are sent to. It can be copied from the Database Details section of the Overview tab of the Database page in the Astra UI.
        """
        return pulumi.get(self, "astra_db_endpoint")

    @astra_db_endpoint.setter
    def astra_db_endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "astra_db_endpoint", value)

    @property
    @pulumi.getter(name="astraDbKeyspace")
    def astra_db_keyspace(self) -> pulumi.Input[str]:
        """
        Keyspaces (or Namespaces) serve as containers for organizing data within a database. You can create a new keyspace uisng the Data Explorer tab in the Astra UI. The keyspace default_keyspace is created for you when you create a Vector Database in Astra DB.
        """
        return pulumi.get(self, "astra_db_keyspace")

    @astra_db_keyspace.setter
    def astra_db_keyspace(self, value: pulumi.Input[str]):
        pulumi.set(self, "astra_db_keyspace", value)

    @property
    @pulumi.getter
    def collection(self) -> pulumi.Input[str]:
        """
        Collections hold data. They are analagous to tables in traditional Cassandra terminology. This tool will create the collection with the provided name automatically if it does not already exist. Alternatively, you can create one thorugh the Data Explorer tab in the Astra UI.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection", value)


@pulumi.input_type
class DestinationAstraConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 chunk_overlap: Optional[pulumi.Input[int]] = None,
                 field_name_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationAstraConfigurationProcessingFieldNameMappingArgs']]]] = None,
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_splitter: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterArgs']] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input['DestinationAstraConfigurationProcessingFieldNameMappingArgs']]] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterArgs'] text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationAstraConfigurationProcessingFieldNameMappingArgs']]]]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @field_name_mappings.setter
    def field_name_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationAstraConfigurationProcessingFieldNameMappingArgs']]]]):
        pulumi.set(self, "field_name_mappings", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterArgs']]:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")

    @text_splitter.setter
    def text_splitter(self, value: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterArgs']]):
        pulumi.set(self, "text_splitter", value)


@pulumi.input_type
class DestinationAstraConfigurationProcessingFieldNameMappingArgs:
    def __init__(__self__, *,
                 from_field: pulumi.Input[str],
                 to_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_field: The field name in the source
        :param pulumi.Input[str] to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> pulumi.Input[str]:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> pulumi.Input[str]:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")

    @to_field.setter
    def to_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "to_field", value)


@pulumi.input_type
class DestinationAstraConfigurationProcessingTextSplitterArgs:
    def __init__(__self__, *,
                 by_markdown_header: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs']] = None,
                 by_programming_language: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs']] = None,
                 by_separator: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs']] = None):
        """
        :param pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs'] by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs'] by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs'] by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @by_markdown_header.setter
    def by_markdown_header(self, value: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]):
        pulumi.set(self, "by_markdown_header", value)

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @by_programming_language.setter
    def by_programming_language(self, value: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]):
        pulumi.set(self, "by_programming_language", value)

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs']]:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")

    @by_separator.setter
    def by_separator(self, value: Optional[pulumi.Input['DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs']]):
        pulumi.set(self, "by_separator", value)


@pulumi.input_type
class DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs:
    def __init__(__self__, *,
                 split_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[pulumi.Input[int]]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")

    @split_level.setter
    def split_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_level", value)


@pulumi.input_type
class DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[str]:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[str]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs:
    def __init__(__self__, *,
                 keep_separator: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @keep_separator.setter
    def keep_separator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_separator", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 credentials: pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsArgs'],
                 lakeformation_database_name: pulumi.Input[str],
                 aws_account_id: Optional[pulumi.Input[str]] = None,
                 bucket_prefix: Optional[pulumi.Input[str]] = None,
                 format: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatArgs']] = None,
                 glue_catalog_float_as_decimal: Optional[pulumi.Input[bool]] = None,
                 lakeformation_database_default_tag_key: Optional[pulumi.Input[str]] = None,
                 lakeformation_database_default_tag_values: Optional[pulumi.Input[str]] = None,
                 lakeformation_governed_tables: Optional[pulumi.Input[bool]] = None,
                 partitioning: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        :param pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsArgs'] credentials: Choose How to Authenticate to AWS.
        :param pulumi.Input[str] lakeformation_database_name: The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
        :param pulumi.Input[str] aws_account_id: target aws account id
        :param pulumi.Input[str] bucket_prefix: S3 prefix
        :param pulumi.Input['DestinationAwsDatalakeConfigurationFormatArgs'] format: Format of the data output.
        :param pulumi.Input[bool] glue_catalog_float_as_decimal: Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source. Default: false
        :param pulumi.Input[str] lakeformation_database_default_tag_key: Add a default tag key to databases created by this destination
        :param pulumi.Input[str] lakeformation_database_default_tag_values: Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
        :param pulumi.Input[bool] lakeformation_governed_tables: Whether to create tables as LF governed tables. Default: false
        :param pulumi.Input[str] partitioning: Partition data by cursor fields when a cursor field is a date. must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]; Default: "NO PARTITIONING"
        :param pulumi.Input[str] region: The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "lakeformation_database_name", lakeformation_database_name)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if glue_catalog_float_as_decimal is not None:
            pulumi.set(__self__, "glue_catalog_float_as_decimal", glue_catalog_float_as_decimal)
        if lakeformation_database_default_tag_key is not None:
            pulumi.set(__self__, "lakeformation_database_default_tag_key", lakeformation_database_default_tag_key)
        if lakeformation_database_default_tag_values is not None:
            pulumi.set(__self__, "lakeformation_database_default_tag_values", lakeformation_database_default_tag_values)
        if lakeformation_governed_tables is not None:
            pulumi.set(__self__, "lakeformation_governed_tables", lakeformation_governed_tables)
        if partitioning is not None:
            pulumi.set(__self__, "partitioning", partitioning)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsArgs']:
        """
        Choose How to Authenticate to AWS.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="lakeformationDatabaseName")
    def lakeformation_database_name(self) -> pulumi.Input[str]:
        """
        The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
        """
        return pulumi.get(self, "lakeformation_database_name")

    @lakeformation_database_name.setter
    def lakeformation_database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "lakeformation_database_name", value)

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        target aws account id
        """
        return pulumi.get(self, "aws_account_id")

    @aws_account_id.setter
    def aws_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_account_id", value)

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        S3 prefix
        """
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_prefix", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatArgs']]:
        """
        Format of the data output.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatArgs']]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="glueCatalogFloatAsDecimal")
    def glue_catalog_float_as_decimal(self) -> Optional[pulumi.Input[bool]]:
        """
        Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source. Default: false
        """
        return pulumi.get(self, "glue_catalog_float_as_decimal")

    @glue_catalog_float_as_decimal.setter
    def glue_catalog_float_as_decimal(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "glue_catalog_float_as_decimal", value)

    @property
    @pulumi.getter(name="lakeformationDatabaseDefaultTagKey")
    def lakeformation_database_default_tag_key(self) -> Optional[pulumi.Input[str]]:
        """
        Add a default tag key to databases created by this destination
        """
        return pulumi.get(self, "lakeformation_database_default_tag_key")

    @lakeformation_database_default_tag_key.setter
    def lakeformation_database_default_tag_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lakeformation_database_default_tag_key", value)

    @property
    @pulumi.getter(name="lakeformationDatabaseDefaultTagValues")
    def lakeformation_database_default_tag_values(self) -> Optional[pulumi.Input[str]]:
        """
        Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
        """
        return pulumi.get(self, "lakeformation_database_default_tag_values")

    @lakeformation_database_default_tag_values.setter
    def lakeformation_database_default_tag_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lakeformation_database_default_tag_values", value)

    @property
    @pulumi.getter(name="lakeformationGovernedTables")
    def lakeformation_governed_tables(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to create tables as LF governed tables. Default: false
        """
        return pulumi.get(self, "lakeformation_governed_tables")

    @lakeformation_governed_tables.setter
    def lakeformation_governed_tables(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lakeformation_governed_tables", value)

    @property
    @pulumi.getter
    def partitioning(self) -> Optional[pulumi.Input[str]]:
        """
        Partition data by cursor fields when a cursor field is a date. must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]; Default: "NO PARTITIONING"
        """
        return pulumi.get(self, "partitioning")

    @partitioning.setter
    def partitioning(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partitioning", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 iam_role: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsIamRoleArgs']] = None,
                 iam_user: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsIamUserArgs']] = None):
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if iam_user is not None:
            pulumi.set(__self__, "iam_user", iam_user)

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsIamRoleArgs']]:
        return pulumi.get(self, "iam_role")

    @iam_role.setter
    def iam_role(self, value: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsIamRoleArgs']]):
        pulumi.set(self, "iam_role", value)

    @property
    @pulumi.getter(name="iamUser")
    def iam_user(self) -> Optional[pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsIamUserArgs']]:
        return pulumi.get(self, "iam_user")

    @iam_user.setter
    def iam_user(self, value: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationCredentialsIamUserArgs']]):
        pulumi.set(self, "iam_user", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationCredentialsIamRoleArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[str] role_arn: Will assume this role to write data to s3
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        Will assume this role to write data to s3
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationCredentialsIamUserArgs:
    def __init__(__self__, *,
                 aws_access_key_id: pulumi.Input[str],
                 aws_secret_access_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] aws_access_key_id: AWS User Access Key Id
        :param pulumi.Input[str] aws_secret_access_key: Secret Access Key
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> pulumi.Input[str]:
        """
        AWS User Access Key Id
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> pulumi.Input[str]:
        """
        Secret Access Key
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_secret_access_key", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationFormatArgs:
    def __init__(__self__, *,
                 json_lines_newline_delimited_json: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']] = None,
                 parquet_columnar_storage: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatParquetColumnarStorageArgs']] = None):
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)
        if parquet_columnar_storage is not None:
            pulumi.set(__self__, "parquet_columnar_storage", parquet_columnar_storage)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @json_lines_newline_delimited_json.setter
    def json_lines_newline_delimited_json(self, value: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]):
        pulumi.set(self, "json_lines_newline_delimited_json", value)

    @property
    @pulumi.getter(name="parquetColumnarStorage")
    def parquet_columnar_storage(self) -> Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatParquetColumnarStorageArgs']]:
        return pulumi.get(self, "parquet_columnar_storage")

    @parquet_columnar_storage.setter
    def parquet_columnar_storage(self, value: Optional[pulumi.Input['DestinationAwsDatalakeConfigurationFormatParquetColumnarStorageArgs']]):
        pulumi.set(self, "parquet_columnar_storage", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJsonArgs:
    def __init__(__self__, *,
                 compression_codec: Optional[pulumi.Input[str]] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_codec: The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "GZIP"]; Default: "UNCOMPRESSED"
        :param pulumi.Input[str] format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[str]]:
        """
        The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "GZIP"]; Default: "UNCOMPRESSED"
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationAwsDatalakeConfigurationFormatParquetColumnarStorageArgs:
    def __init__(__self__, *,
                 compression_codec: Optional[pulumi.Input[str]] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_codec: The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "ZSTD"]; Default: "SNAPPY"
        :param pulumi.Input[str] format_type: must be one of ["Parquet"]; Default: "Parquet"
        """
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[str]]:
        """
        The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "ZSTD"]; Default: "SNAPPY"
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Parquet"]; Default: "Parquet"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationAzureBlobStorageConfigurationArgs:
    def __init__(__self__, *,
                 azure_blob_storage_account_key: pulumi.Input[str],
                 azure_blob_storage_account_name: pulumi.Input[str],
                 format: pulumi.Input['DestinationAzureBlobStorageConfigurationFormatArgs'],
                 azure_blob_storage_container_name: Optional[pulumi.Input[str]] = None,
                 azure_blob_storage_endpoint_domain_name: Optional[pulumi.Input[str]] = None,
                 azure_blob_storage_output_buffer_size: Optional[pulumi.Input[int]] = None,
                 azure_blob_storage_spill_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] azure_blob_storage_account_key: The Azure blob storage account key.
        :param pulumi.Input[str] azure_blob_storage_account_name: The account's name of the Azure Blob Storage.
        :param pulumi.Input['DestinationAzureBlobStorageConfigurationFormatArgs'] format: Output data format
        :param pulumi.Input[str] azure_blob_storage_container_name: The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
        :param pulumi.Input[str] azure_blob_storage_endpoint_domain_name: This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        :param pulumi.Input[int] azure_blob_storage_output_buffer_size: The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure. Default: 5
        :param pulumi.Input[int] azure_blob_storage_spill_size: The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable. Default: 500
        """
        pulumi.set(__self__, "azure_blob_storage_account_key", azure_blob_storage_account_key)
        pulumi.set(__self__, "azure_blob_storage_account_name", azure_blob_storage_account_name)
        pulumi.set(__self__, "format", format)
        if azure_blob_storage_container_name is not None:
            pulumi.set(__self__, "azure_blob_storage_container_name", azure_blob_storage_container_name)
        if azure_blob_storage_endpoint_domain_name is not None:
            pulumi.set(__self__, "azure_blob_storage_endpoint_domain_name", azure_blob_storage_endpoint_domain_name)
        if azure_blob_storage_output_buffer_size is not None:
            pulumi.set(__self__, "azure_blob_storage_output_buffer_size", azure_blob_storage_output_buffer_size)
        if azure_blob_storage_spill_size is not None:
            pulumi.set(__self__, "azure_blob_storage_spill_size", azure_blob_storage_spill_size)

    @property
    @pulumi.getter(name="azureBlobStorageAccountKey")
    def azure_blob_storage_account_key(self) -> pulumi.Input[str]:
        """
        The Azure blob storage account key.
        """
        return pulumi.get(self, "azure_blob_storage_account_key")

    @azure_blob_storage_account_key.setter
    def azure_blob_storage_account_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_account_key", value)

    @property
    @pulumi.getter(name="azureBlobStorageAccountName")
    def azure_blob_storage_account_name(self) -> pulumi.Input[str]:
        """
        The account's name of the Azure Blob Storage.
        """
        return pulumi.get(self, "azure_blob_storage_account_name")

    @azure_blob_storage_account_name.setter
    def azure_blob_storage_account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_account_name", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['DestinationAzureBlobStorageConfigurationFormatArgs']:
        """
        Output data format
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['DestinationAzureBlobStorageConfigurationFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="azureBlobStorageContainerName")
    def azure_blob_storage_container_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
        """
        return pulumi.get(self, "azure_blob_storage_container_name")

    @azure_blob_storage_container_name.setter
    def azure_blob_storage_container_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_blob_storage_container_name", value)

    @property
    @pulumi.getter(name="azureBlobStorageEndpointDomainName")
    def azure_blob_storage_endpoint_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        """
        return pulumi.get(self, "azure_blob_storage_endpoint_domain_name")

    @azure_blob_storage_endpoint_domain_name.setter
    def azure_blob_storage_endpoint_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_blob_storage_endpoint_domain_name", value)

    @property
    @pulumi.getter(name="azureBlobStorageOutputBufferSize")
    def azure_blob_storage_output_buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure. Default: 5
        """
        return pulumi.get(self, "azure_blob_storage_output_buffer_size")

    @azure_blob_storage_output_buffer_size.setter
    def azure_blob_storage_output_buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "azure_blob_storage_output_buffer_size", value)

    @property
    @pulumi.getter(name="azureBlobStorageSpillSize")
    def azure_blob_storage_spill_size(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable. Default: 500
        """
        return pulumi.get(self, "azure_blob_storage_spill_size")

    @azure_blob_storage_spill_size.setter
    def azure_blob_storage_spill_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "azure_blob_storage_spill_size", value)


@pulumi.input_type
class DestinationAzureBlobStorageConfigurationFormatArgs:
    def __init__(__self__, *,
                 csv_comma_separated_values: Optional[pulumi.Input['DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValuesArgs']] = None,
                 json_lines_newline_delimited_json: Optional[pulumi.Input['DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']] = None):
        if csv_comma_separated_values is not None:
            pulumi.set(__self__, "csv_comma_separated_values", csv_comma_separated_values)
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)

    @property
    @pulumi.getter(name="csvCommaSeparatedValues")
    def csv_comma_separated_values(self) -> Optional[pulumi.Input['DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValuesArgs']]:
        return pulumi.get(self, "csv_comma_separated_values")

    @csv_comma_separated_values.setter
    def csv_comma_separated_values(self, value: Optional[pulumi.Input['DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValuesArgs']]):
        pulumi.set(self, "csv_comma_separated_values", value)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional[pulumi.Input['DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @json_lines_newline_delimited_json.setter
    def json_lines_newline_delimited_json(self, value: Optional[pulumi.Input['DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]):
        pulumi.set(self, "json_lines_newline_delimited_json", value)


@pulumi.input_type
class DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValuesArgs:
    def __init__(__self__, *,
                 flattening: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] flattening: Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)

    @property
    @pulumi.getter
    def flattening(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @flattening.setter
    def flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flattening", value)


@pulumi.input_type
class DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJsonArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationBigqueryConfigurationArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 dataset_location: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 big_query_client_buffer_size_mb: Optional[pulumi.Input[int]] = None,
                 credentials_json: Optional[pulumi.Input[str]] = None,
                 disable_type_dedupe: Optional[pulumi.Input[bool]] = None,
                 loading_method: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodArgs']] = None,
                 raw_data_dataset: Optional[pulumi.Input[str]] = None,
                 transformation_priority: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id: The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more <a href="https://cloud.google.com/bigquery/docs/datasets#create-dataset">here</a>.
        :param pulumi.Input[str] dataset_location: The location of the dataset. Warning: Changes made after creation will not be applied. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>. must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "europe-west12", "me-central1", "me-central2", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-south1", "us-west1", "us-west2", "us-west3", "us-west4"]
        :param pulumi.Input[str] project_id: The GCP project ID for the project containing the target BigQuery dataset. Read more <a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">here</a>.
        :param pulumi.Input[int] big_query_client_buffer_size_mb: Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more <a href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html">here</a>. Default: 15
        :param pulumi.Input[str] credentials_json: The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/bigquery#service-account-key">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        :param pulumi.Input[bool] disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param pulumi.Input['DestinationBigqueryConfigurationLoadingMethodArgs'] loading_method: The way data will be uploaded to BigQuery.
        :param pulumi.Input[str] raw_data_dataset: The dataset to write raw tables into (default: airbyte_internal)
        :param pulumi.Input[str] transformation_priority: Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type <a href="https://cloud.google.com/bigquery/docs/running-queries#queries">here</a>. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries dont count towards your concurrent rate limit. Read more about batch queries <a href="https://cloud.google.com/bigquery/docs/running-queries#batch">here</a>. The default "interactive" value is used if not set explicitly. must be one of ["interactive", "batch"]; Default: "interactive"
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_location", dataset_location)
        pulumi.set(__self__, "project_id", project_id)
        if big_query_client_buffer_size_mb is not None:
            pulumi.set(__self__, "big_query_client_buffer_size_mb", big_query_client_buffer_size_mb)
        if credentials_json is not None:
            pulumi.set(__self__, "credentials_json", credentials_json)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if loading_method is not None:
            pulumi.set(__self__, "loading_method", loading_method)
        if raw_data_dataset is not None:
            pulumi.set(__self__, "raw_data_dataset", raw_data_dataset)
        if transformation_priority is not None:
            pulumi.set(__self__, "transformation_priority", transformation_priority)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more <a href="https://cloud.google.com/bigquery/docs/datasets#create-dataset">here</a>.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="datasetLocation")
    def dataset_location(self) -> pulumi.Input[str]:
        """
        The location of the dataset. Warning: Changes made after creation will not be applied. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>. must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "europe-west12", "me-central1", "me-central2", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-south1", "us-west1", "us-west2", "us-west3", "us-west4"]
        """
        return pulumi.get(self, "dataset_location")

    @dataset_location.setter
    def dataset_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_location", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The GCP project ID for the project containing the target BigQuery dataset. Read more <a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">here</a>.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="bigQueryClientBufferSizeMb")
    def big_query_client_buffer_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more <a href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html">here</a>. Default: 15
        """
        return pulumi.get(self, "big_query_client_buffer_size_mb")

    @big_query_client_buffer_size_mb.setter
    def big_query_client_buffer_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "big_query_client_buffer_size_mb", value)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> Optional[pulumi.Input[str]]:
        """
        The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/bigquery#service-account-key">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials_json", value)

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @disable_type_dedupe.setter
    def disable_type_dedupe(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_dedupe", value)

    @property
    @pulumi.getter(name="loadingMethod")
    def loading_method(self) -> Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodArgs']]:
        """
        The way data will be uploaded to BigQuery.
        """
        return pulumi.get(self, "loading_method")

    @loading_method.setter
    def loading_method(self, value: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodArgs']]):
        pulumi.set(self, "loading_method", value)

    @property
    @pulumi.getter(name="rawDataDataset")
    def raw_data_dataset(self) -> Optional[pulumi.Input[str]]:
        """
        The dataset to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_dataset")

    @raw_data_dataset.setter
    def raw_data_dataset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_dataset", value)

    @property
    @pulumi.getter(name="transformationPriority")
    def transformation_priority(self) -> Optional[pulumi.Input[str]]:
        """
        Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type <a href="https://cloud.google.com/bigquery/docs/running-queries#queries">here</a>. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries dont count towards your concurrent rate limit. Read more about batch queries <a href="https://cloud.google.com/bigquery/docs/running-queries#batch">here</a>. The default "interactive" value is used if not set explicitly. must be one of ["interactive", "batch"]; Default: "interactive"
        """
        return pulumi.get(self, "transformation_priority")

    @transformation_priority.setter
    def transformation_priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transformation_priority", value)


@pulumi.input_type
class DestinationBigqueryConfigurationLoadingMethodArgs:
    def __init__(__self__, *,
                 gcs_staging: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs']] = None,
                 standard_inserts: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs']] = None):
        """
        :param pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs'] gcs_staging: <i>(recommended)</i> Writes large batches of records to a file, uploads the file to GCS, then uses COPY INTO to load your data into BigQuery. Provides best-in-class speed, reliability and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.
        :param pulumi.Input['DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs'] standard_inserts: <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use GCS staging.
        """
        if gcs_staging is not None:
            pulumi.set(__self__, "gcs_staging", gcs_staging)
        if standard_inserts is not None:
            pulumi.set(__self__, "standard_inserts", standard_inserts)

    @property
    @pulumi.getter(name="gcsStaging")
    def gcs_staging(self) -> Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs']]:
        """
        <i>(recommended)</i> Writes large batches of records to a file, uploads the file to GCS, then uses COPY INTO to load your data into BigQuery. Provides best-in-class speed, reliability and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.
        """
        return pulumi.get(self, "gcs_staging")

    @gcs_staging.setter
    def gcs_staging(self, value: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs']]):
        pulumi.set(self, "gcs_staging", value)

    @property
    @pulumi.getter(name="standardInserts")
    def standard_inserts(self) -> Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs']]:
        """
        <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use GCS staging.
        """
        return pulumi.get(self, "standard_inserts")

    @standard_inserts.setter
    def standard_inserts(self, value: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs']]):
        pulumi.set(self, "standard_inserts", value)


@pulumi.input_type
class DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs:
    def __init__(__self__, *,
                 credential: pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs'],
                 gcs_bucket_name: pulumi.Input[str],
                 gcs_bucket_path: pulumi.Input[str],
                 keep_files_in_gcs_bucket: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs'] credential: An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        :param pulumi.Input[str] gcs_bucket_name: The name of the GCS bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        :param pulumi.Input[str] gcs_bucket_path: Directory under the GCS bucket where data will be written.
        :param pulumi.Input[str] keep_files_in_gcs_bucket: This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly. must be one of ["Delete all tmp files from GCS", "Keep all tmp files in GCS"]; Default: "Delete all tmp files from GCS"
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "gcs_bucket_name", gcs_bucket_name)
        pulumi.set(__self__, "gcs_bucket_path", gcs_bucket_path)
        if keep_files_in_gcs_bucket is not None:
            pulumi.set(__self__, "keep_files_in_gcs_bucket", keep_files_in_gcs_bucket)

    @property
    @pulumi.getter
    def credential(self) -> pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs']:
        """
        An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs']):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter(name="gcsBucketName")
    def gcs_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the GCS bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        """
        return pulumi.get(self, "gcs_bucket_name")

    @gcs_bucket_name.setter
    def gcs_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "gcs_bucket_name", value)

    @property
    @pulumi.getter(name="gcsBucketPath")
    def gcs_bucket_path(self) -> pulumi.Input[str]:
        """
        Directory under the GCS bucket where data will be written.
        """
        return pulumi.get(self, "gcs_bucket_path")

    @gcs_bucket_path.setter
    def gcs_bucket_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "gcs_bucket_path", value)

    @property
    @pulumi.getter(name="keepFilesInGcsBucket")
    def keep_files_in_gcs_bucket(self) -> Optional[pulumi.Input[str]]:
        """
        This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly. must be one of ["Delete all tmp files from GCS", "Keep all tmp files in GCS"]; Default: "Delete all tmp files from GCS"
        """
        return pulumi.get(self, "keep_files_in_gcs_bucket")

    @keep_files_in_gcs_bucket.setter
    def keep_files_in_gcs_bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keep_files_in_gcs_bucket", value)


@pulumi.input_type
class DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs:
    def __init__(__self__, *,
                 hmac_key: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKeyArgs']] = None):
        if hmac_key is not None:
            pulumi.set(__self__, "hmac_key", hmac_key)

    @property
    @pulumi.getter(name="hmacKey")
    def hmac_key(self) -> Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKeyArgs']]:
        return pulumi.get(self, "hmac_key")

    @hmac_key.setter
    def hmac_key(self, value: Optional[pulumi.Input['DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKeyArgs']]):
        pulumi.set(self, "hmac_key", value)


@pulumi.input_type
class DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKeyArgs:
    def __init__(__self__, *,
                 hmac_key_access_id: pulumi.Input[str],
                 hmac_key_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] hmac_key_access_id: HMAC key access ID. When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long.
        :param pulumi.Input[str] hmac_key_secret: The corresponding secret for the access ID. It is a 40-character base-64 encoded string.
        """
        pulumi.set(__self__, "hmac_key_access_id", hmac_key_access_id)
        pulumi.set(__self__, "hmac_key_secret", hmac_key_secret)

    @property
    @pulumi.getter(name="hmacKeyAccessId")
    def hmac_key_access_id(self) -> pulumi.Input[str]:
        """
        HMAC key access ID. When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long.
        """
        return pulumi.get(self, "hmac_key_access_id")

    @hmac_key_access_id.setter
    def hmac_key_access_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "hmac_key_access_id", value)

    @property
    @pulumi.getter(name="hmacKeySecret")
    def hmac_key_secret(self) -> pulumi.Input[str]:
        """
        The corresponding secret for the access ID. It is a 40-character base-64 encoded string.
        """
        return pulumi.get(self, "hmac_key_secret")

    @hmac_key_secret.setter
    def hmac_key_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "hmac_key_secret", value)


@pulumi.input_type
class DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationClickhouseConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[int] port: HTTP port of the database. Default: 8123
        :param pulumi.Input[str] raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param pulumi.Input['DestinationClickhouseConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP port of the database. Default: 8123
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationClickhouseConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationClickhouseConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationConvexConfigurationArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 deployment_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_key: API access key used to send data to a Convex deployment.
        :param pulumi.Input[str] deployment_url: URL of the Convex deployment that is the destination
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "deployment_url", deployment_url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        API access key used to send data to a Convex deployment.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="deploymentUrl")
    def deployment_url(self) -> pulumi.Input[str]:
        """
        URL of the Convex deployment that is the destination
        """
        return pulumi.get(self, "deployment_url")

    @deployment_url.setter
    def deployment_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment_url", value)


@pulumi.input_type
class DestinationDatabricksConfigurationArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input['DestinationDatabricksConfigurationDataSourceArgs'],
                 databricks_http_path: pulumi.Input[str],
                 databricks_personal_access_token: pulumi.Input[str],
                 databricks_server_hostname: pulumi.Input[str],
                 accept_terms: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 databricks_port: Optional[pulumi.Input[str]] = None,
                 enable_schema_evolution: Optional[pulumi.Input[bool]] = None,
                 purge_staging_data: Optional[pulumi.Input[bool]] = None,
                 schema: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationDatabricksConfigurationDataSourceArgs'] data_source: Storage on which the delta lake is built.
        :param pulumi.Input[str] databricks_http_path: Databricks Cluster HTTP Path.
        :param pulumi.Input[str] databricks_personal_access_token: Databricks Personal Access Token for making authenticated requests.
        :param pulumi.Input[str] databricks_server_hostname: Databricks Cluster Server Hostname.
        :param pulumi.Input[bool] accept_terms: You must agree to the Databricks JDBC Driver <a href="https://databricks.com/jdbc-odbc-driver-license">Terms & Conditions</a> to use this connector. Default: false
        :param pulumi.Input[str] database: The name of the catalog. If not specified otherwise, the "hive_metastore" will be used.
        :param pulumi.Input[str] databricks_port: Databricks Cluster Port. Default: "443"
        :param pulumi.Input[bool] enable_schema_evolution: Support schema evolution for all streams. If "false", the connector might fail when a stream's schema changes. Default: false
        :param pulumi.Input[bool] purge_staging_data: Default to 'true'. Switch it to 'false' for debugging purpose. Default: true
        :param pulumi.Input[str] schema: The default schema tables are written. If not specified otherwise, the "default" will be used. Default: "default"
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "databricks_http_path", databricks_http_path)
        pulumi.set(__self__, "databricks_personal_access_token", databricks_personal_access_token)
        pulumi.set(__self__, "databricks_server_hostname", databricks_server_hostname)
        if accept_terms is not None:
            pulumi.set(__self__, "accept_terms", accept_terms)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if databricks_port is not None:
            pulumi.set(__self__, "databricks_port", databricks_port)
        if enable_schema_evolution is not None:
            pulumi.set(__self__, "enable_schema_evolution", enable_schema_evolution)
        if purge_staging_data is not None:
            pulumi.set(__self__, "purge_staging_data", purge_staging_data)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input['DestinationDatabricksConfigurationDataSourceArgs']:
        """
        Storage on which the delta lake is built.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input['DestinationDatabricksConfigurationDataSourceArgs']):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="databricksHttpPath")
    def databricks_http_path(self) -> pulumi.Input[str]:
        """
        Databricks Cluster HTTP Path.
        """
        return pulumi.get(self, "databricks_http_path")

    @databricks_http_path.setter
    def databricks_http_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "databricks_http_path", value)

    @property
    @pulumi.getter(name="databricksPersonalAccessToken")
    def databricks_personal_access_token(self) -> pulumi.Input[str]:
        """
        Databricks Personal Access Token for making authenticated requests.
        """
        return pulumi.get(self, "databricks_personal_access_token")

    @databricks_personal_access_token.setter
    def databricks_personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "databricks_personal_access_token", value)

    @property
    @pulumi.getter(name="databricksServerHostname")
    def databricks_server_hostname(self) -> pulumi.Input[str]:
        """
        Databricks Cluster Server Hostname.
        """
        return pulumi.get(self, "databricks_server_hostname")

    @databricks_server_hostname.setter
    def databricks_server_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "databricks_server_hostname", value)

    @property
    @pulumi.getter(name="acceptTerms")
    def accept_terms(self) -> Optional[pulumi.Input[bool]]:
        """
        You must agree to the Databricks JDBC Driver <a href="https://databricks.com/jdbc-odbc-driver-license">Terms & Conditions</a> to use this connector. Default: false
        """
        return pulumi.get(self, "accept_terms")

    @accept_terms.setter
    def accept_terms(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accept_terms", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the catalog. If not specified otherwise, the "hive_metastore" will be used.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databricksPort")
    def databricks_port(self) -> Optional[pulumi.Input[str]]:
        """
        Databricks Cluster Port. Default: "443"
        """
        return pulumi.get(self, "databricks_port")

    @databricks_port.setter
    def databricks_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "databricks_port", value)

    @property
    @pulumi.getter(name="enableSchemaEvolution")
    def enable_schema_evolution(self) -> Optional[pulumi.Input[bool]]:
        """
        Support schema evolution for all streams. If "false", the connector might fail when a stream's schema changes. Default: false
        """
        return pulumi.get(self, "enable_schema_evolution")

    @enable_schema_evolution.setter
    def enable_schema_evolution(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_schema_evolution", value)

    @property
    @pulumi.getter(name="purgeStagingData")
    def purge_staging_data(self) -> Optional[pulumi.Input[bool]]:
        """
        Default to 'true'. Switch it to 'false' for debugging purpose. Default: true
        """
        return pulumi.get(self, "purge_staging_data")

    @purge_staging_data.setter
    def purge_staging_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "purge_staging_data", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema tables are written. If not specified otherwise, the "default" will be used. Default: "default"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)


@pulumi.input_type
class DestinationDatabricksConfigurationDataSourceArgs:
    def __init__(__self__, *,
                 amazon_s3: Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceAmazonS3Args']] = None,
                 azure_blob_storage: Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceAzureBlobStorageArgs']] = None,
                 recommended_managed_tables: Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceRecommendedManagedTablesArgs']] = None):
        if amazon_s3 is not None:
            pulumi.set(__self__, "amazon_s3", amazon_s3)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if recommended_managed_tables is not None:
            pulumi.set(__self__, "recommended_managed_tables", recommended_managed_tables)

    @property
    @pulumi.getter(name="amazonS3")
    def amazon_s3(self) -> Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceAmazonS3Args']]:
        return pulumi.get(self, "amazon_s3")

    @amazon_s3.setter
    def amazon_s3(self, value: Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceAmazonS3Args']]):
        pulumi.set(self, "amazon_s3", value)

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceAzureBlobStorageArgs']]:
        return pulumi.get(self, "azure_blob_storage")

    @azure_blob_storage.setter
    def azure_blob_storage(self, value: Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceAzureBlobStorageArgs']]):
        pulumi.set(self, "azure_blob_storage", value)

    @property
    @pulumi.getter(name="recommendedManagedTables")
    def recommended_managed_tables(self) -> Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceRecommendedManagedTablesArgs']]:
        return pulumi.get(self, "recommended_managed_tables")

    @recommended_managed_tables.setter
    def recommended_managed_tables(self, value: Optional[pulumi.Input['DestinationDatabricksConfigurationDataSourceRecommendedManagedTablesArgs']]):
        pulumi.set(self, "recommended_managed_tables", value)


@pulumi.input_type
class DestinationDatabricksConfigurationDataSourceAmazonS3Args:
    def __init__(__self__, *,
                 s3_access_key_id: pulumi.Input[str],
                 s3_bucket_name: pulumi.Input[str],
                 s3_bucket_path: pulumi.Input[str],
                 s3_secret_access_key: pulumi.Input[str],
                 file_name_pattern: Optional[pulumi.Input[str]] = None,
                 s3_bucket_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_access_key_id: The Access Key Id granting allow one to access the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket.
        :param pulumi.Input[str] s3_bucket_name: The name of the S3 bucket to use for intermittent staging of the data.
        :param pulumi.Input[str] s3_bucket_path: The directory under the S3 bucket where data will be written.
        :param pulumi.Input[str] s3_secret_access_key: The corresponding secret to the above access key id.
        :param pulumi.Input[str] file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param pulumi.Input[str] s3_bucket_region: The region of the S3 staging bucket to use if utilising a copy strategy. must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]; Default: ""
        """
        pulumi.set(__self__, "s3_access_key_id", s3_access_key_id)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        pulumi.set(__self__, "s3_secret_access_key", s3_secret_access_key)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)

    @property
    @pulumi.getter(name="s3AccessKeyId")
    def s3_access_key_id(self) -> pulumi.Input[str]:
        """
        The Access Key Id granting allow one to access the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket.
        """
        return pulumi.get(self, "s3_access_key_id")

    @s3_access_key_id.setter
    def s3_access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_access_key_id", value)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket to use for intermittent staging of the data.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> pulumi.Input[str]:
        """
        The directory under the S3 bucket where data will be written.
        """
        return pulumi.get(self, "s3_bucket_path")

    @s3_bucket_path.setter
    def s3_bucket_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_path", value)

    @property
    @pulumi.getter(name="s3SecretAccessKey")
    def s3_secret_access_key(self) -> pulumi.Input[str]:
        """
        The corresponding secret to the above access key id.
        """
        return pulumi.get(self, "s3_secret_access_key")

    @s3_secret_access_key.setter
    def s3_secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_secret_access_key", value)

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @file_name_pattern.setter
    def file_name_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_pattern", value)

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the S3 staging bucket to use if utilising a copy strategy. must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")

    @s3_bucket_region.setter
    def s3_bucket_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_region", value)


@pulumi.input_type
class DestinationDatabricksConfigurationDataSourceAzureBlobStorageArgs:
    def __init__(__self__, *,
                 azure_blob_storage_account_name: pulumi.Input[str],
                 azure_blob_storage_container_name: pulumi.Input[str],
                 azure_blob_storage_sas_token: pulumi.Input[str],
                 azure_blob_storage_endpoint_domain_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] azure_blob_storage_account_name: The account's name of the Azure Blob Storage.
        :param pulumi.Input[str] azure_blob_storage_container_name: The name of the Azure blob storage container.
        :param pulumi.Input[str] azure_blob_storage_sas_token: Shared access signature (SAS) token to grant limited access to objects in your storage account.
        :param pulumi.Input[str] azure_blob_storage_endpoint_domain_name: This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        """
        pulumi.set(__self__, "azure_blob_storage_account_name", azure_blob_storage_account_name)
        pulumi.set(__self__, "azure_blob_storage_container_name", azure_blob_storage_container_name)
        pulumi.set(__self__, "azure_blob_storage_sas_token", azure_blob_storage_sas_token)
        if azure_blob_storage_endpoint_domain_name is not None:
            pulumi.set(__self__, "azure_blob_storage_endpoint_domain_name", azure_blob_storage_endpoint_domain_name)

    @property
    @pulumi.getter(name="azureBlobStorageAccountName")
    def azure_blob_storage_account_name(self) -> pulumi.Input[str]:
        """
        The account's name of the Azure Blob Storage.
        """
        return pulumi.get(self, "azure_blob_storage_account_name")

    @azure_blob_storage_account_name.setter
    def azure_blob_storage_account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_account_name", value)

    @property
    @pulumi.getter(name="azureBlobStorageContainerName")
    def azure_blob_storage_container_name(self) -> pulumi.Input[str]:
        """
        The name of the Azure blob storage container.
        """
        return pulumi.get(self, "azure_blob_storage_container_name")

    @azure_blob_storage_container_name.setter
    def azure_blob_storage_container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_container_name", value)

    @property
    @pulumi.getter(name="azureBlobStorageSasToken")
    def azure_blob_storage_sas_token(self) -> pulumi.Input[str]:
        """
        Shared access signature (SAS) token to grant limited access to objects in your storage account.
        """
        return pulumi.get(self, "azure_blob_storage_sas_token")

    @azure_blob_storage_sas_token.setter
    def azure_blob_storage_sas_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_sas_token", value)

    @property
    @pulumi.getter(name="azureBlobStorageEndpointDomainName")
    def azure_blob_storage_endpoint_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        """
        return pulumi.get(self, "azure_blob_storage_endpoint_domain_name")

    @azure_blob_storage_endpoint_domain_name.setter
    def azure_blob_storage_endpoint_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_blob_storage_endpoint_domain_name", value)


@pulumi.input_type
class DestinationDatabricksConfigurationDataSourceRecommendedManagedTablesArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationDevNullConfigurationArgs:
    def __init__(__self__, *,
                 test_destination: pulumi.Input['DestinationDevNullConfigurationTestDestinationArgs']):
        """
        :param pulumi.Input['DestinationDevNullConfigurationTestDestinationArgs'] test_destination: The type of destination to be used
        """
        pulumi.set(__self__, "test_destination", test_destination)

    @property
    @pulumi.getter(name="testDestination")
    def test_destination(self) -> pulumi.Input['DestinationDevNullConfigurationTestDestinationArgs']:
        """
        The type of destination to be used
        """
        return pulumi.get(self, "test_destination")

    @test_destination.setter
    def test_destination(self, value: pulumi.Input['DestinationDevNullConfigurationTestDestinationArgs']):
        pulumi.set(self, "test_destination", value)


@pulumi.input_type
class DestinationDevNullConfigurationTestDestinationArgs:
    def __init__(__self__, *,
                 silent: Optional[pulumi.Input['DestinationDevNullConfigurationTestDestinationSilentArgs']] = None):
        if silent is not None:
            pulumi.set(__self__, "silent", silent)

    @property
    @pulumi.getter
    def silent(self) -> Optional[pulumi.Input['DestinationDevNullConfigurationTestDestinationSilentArgs']]:
        return pulumi.get(self, "silent")

    @silent.setter
    def silent(self, value: Optional[pulumi.Input['DestinationDevNullConfigurationTestDestinationSilentArgs']]):
        pulumi.set(self, "silent", value)


@pulumi.input_type
class DestinationDevNullConfigurationTestDestinationSilentArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationDuckdbConfigurationArgs:
    def __init__(__self__, *,
                 destination_path: pulumi.Input[str],
                 motherduck_api_key: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination_path: Path to the .duckdb file, or the text 'md:' to connect to MotherDuck. The file will be placed inside that local mount. For more information check out our <a href="https://docs.airbyte.io/integrations/destinations/duckdb">docs</a>
        :param pulumi.Input[str] motherduck_api_key: API key to use for authentication to a MotherDuck database.
        :param pulumi.Input[str] schema: Database schema name, default for duckdb is 'main'.
        """
        pulumi.set(__self__, "destination_path", destination_path)
        if motherduck_api_key is not None:
            pulumi.set(__self__, "motherduck_api_key", motherduck_api_key)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> pulumi.Input[str]:
        """
        Path to the .duckdb file, or the text 'md:' to connect to MotherDuck. The file will be placed inside that local mount. For more information check out our <a href="https://docs.airbyte.io/integrations/destinations/duckdb">docs</a>
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_path", value)

    @property
    @pulumi.getter(name="motherduckApiKey")
    def motherduck_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        API key to use for authentication to a MotherDuck database.
        """
        return pulumi.get(self, "motherduck_api_key")

    @motherduck_api_key.setter
    def motherduck_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "motherduck_api_key", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        Database schema name, default for duckdb is 'main'.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)


@pulumi.input_type
class DestinationDynamodbConfigurationArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[str],
                 dynamodb_table_name_prefix: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str],
                 dynamodb_endpoint: Optional[pulumi.Input[str]] = None,
                 dynamodb_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
        :param pulumi.Input[str] dynamodb_table_name_prefix: The prefix to use when naming DynamoDB tables.
        :param pulumi.Input[str] secret_access_key: The corresponding secret to the access key id.
        :param pulumi.Input[str] dynamodb_endpoint: This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty). Default: ""
        :param pulumi.Input[str] dynamodb_region: The region of the DynamoDB. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "dynamodb_table_name_prefix", dynamodb_table_name_prefix)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if dynamodb_endpoint is not None:
            pulumi.set(__self__, "dynamodb_endpoint", dynamodb_endpoint)
        if dynamodb_region is not None:
            pulumi.set(__self__, "dynamodb_region", dynamodb_region)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[str]:
        """
        The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="dynamodbTableNamePrefix")
    def dynamodb_table_name_prefix(self) -> pulumi.Input[str]:
        """
        The prefix to use when naming DynamoDB tables.
        """
        return pulumi.get(self, "dynamodb_table_name_prefix")

    @dynamodb_table_name_prefix.setter
    def dynamodb_table_name_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "dynamodb_table_name_prefix", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        """
        The corresponding secret to the access key id.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="dynamodbEndpoint")
    def dynamodb_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty). Default: ""
        """
        return pulumi.get(self, "dynamodb_endpoint")

    @dynamodb_endpoint.setter
    def dynamodb_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamodb_endpoint", value)

    @property
    @pulumi.getter(name="dynamodbRegion")
    def dynamodb_region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the DynamoDB. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "dynamodb_region")

    @dynamodb_region.setter
    def dynamodb_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dynamodb_region", value)


@pulumi.input_type
class DestinationElasticsearchConfigurationArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 authentication_method: Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodArgs']] = None,
                 ca_certificate: Optional[pulumi.Input[str]] = None,
                 upsert: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] endpoint: The full url of the Elasticsearch server
        :param pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodArgs'] authentication_method: The type of authentication to be used
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[bool] upsert: If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys. Default: true
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The full url of the Elasticsearch server
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodArgs']]:
        """
        The type of authentication to be used
        """
        return pulumi.get(self, "authentication_method")

    @authentication_method.setter
    def authentication_method(self, value: Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodArgs']]):
        pulumi.set(self, "authentication_method", value)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter
    def upsert(self) -> Optional[pulumi.Input[bool]]:
        """
        If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys. Default: true
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "upsert", value)


@pulumi.input_type
class DestinationElasticsearchConfigurationAuthenticationMethodArgs:
    def __init__(__self__, *,
                 api_key_secret: Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs']] = None,
                 username_password: Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs']] = None):
        """
        :param pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs'] api_key_secret: Use a api key and secret combination to authenticate
        :param pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs'] username_password: Basic auth header with a username and password
        """
        if api_key_secret is not None:
            pulumi.set(__self__, "api_key_secret", api_key_secret)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="apiKeySecret")
    def api_key_secret(self) -> Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs']]:
        """
        Use a api key and secret combination to authenticate
        """
        return pulumi.get(self, "api_key_secret")

    @api_key_secret.setter
    def api_key_secret(self, value: Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs']]):
        pulumi.set(self, "api_key_secret", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs']]:
        """
        Basic auth header with a username and password
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)


@pulumi.input_type
class DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs:
    def __init__(__self__, *,
                 api_key_id: pulumi.Input[str],
                 api_key_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key_id: The Key ID to used when accessing an enterprise Elasticsearch instance.
        :param pulumi.Input[str] api_key_secret: The secret associated with the API Key ID.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "api_key_secret", api_key_secret)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> pulumi.Input[str]:
        """
        The Key ID to used when accessing an enterprise Elasticsearch instance.
        """
        return pulumi.get(self, "api_key_id")

    @api_key_id.setter
    def api_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key_id", value)

    @property
    @pulumi.getter(name="apiKeySecret")
    def api_key_secret(self) -> pulumi.Input[str]:
        """
        The secret associated with the API Key ID.
        """
        return pulumi.get(self, "api_key_secret")

    @api_key_secret.setter
    def api_key_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key_secret", value)


@pulumi.input_type
class DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Basic auth password to access a secure Elasticsearch server
        :param pulumi.Input[str] username: Basic auth username to access a secure Elasticsearch server
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Basic auth password to access a secure Elasticsearch server
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Basic auth username to access a secure Elasticsearch server
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DestinationFirestoreConfigurationArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str],
                 credentials_json: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] project_id: The GCP project ID for the project containing the target BigQuery dataset.
        :param pulumi.Input[str] credentials_json: The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.io/integrations/destinations/firestore">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        """
        pulumi.set(__self__, "project_id", project_id)
        if credentials_json is not None:
            pulumi.set(__self__, "credentials_json", credentials_json)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The GCP project ID for the project containing the target BigQuery dataset.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> Optional[pulumi.Input[str]]:
        """
        The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.io/integrations/destinations/firestore">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credentials_json", value)


@pulumi.input_type
class DestinationGcsConfigurationArgs:
    def __init__(__self__, *,
                 credential: pulumi.Input['DestinationGcsConfigurationCredentialArgs'],
                 format: pulumi.Input['DestinationGcsConfigurationFormatArgs'],
                 gcs_bucket_name: pulumi.Input[str],
                 gcs_bucket_path: pulumi.Input[str],
                 gcs_bucket_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationGcsConfigurationCredentialArgs'] credential: An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        :param pulumi.Input['DestinationGcsConfigurationFormatArgs'] format: Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
        :param pulumi.Input[str] gcs_bucket_name: You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        :param pulumi.Input[str] gcs_bucket_path: GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
        :param pulumi.Input[str] gcs_bucket_region: Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>. must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]; Default: "us"
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "gcs_bucket_name", gcs_bucket_name)
        pulumi.set(__self__, "gcs_bucket_path", gcs_bucket_path)
        if gcs_bucket_region is not None:
            pulumi.set(__self__, "gcs_bucket_region", gcs_bucket_region)

    @property
    @pulumi.getter
    def credential(self) -> pulumi.Input['DestinationGcsConfigurationCredentialArgs']:
        """
        An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input['DestinationGcsConfigurationCredentialArgs']):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['DestinationGcsConfigurationFormatArgs']:
        """
        Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['DestinationGcsConfigurationFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="gcsBucketName")
    def gcs_bucket_name(self) -> pulumi.Input[str]:
        """
        You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        """
        return pulumi.get(self, "gcs_bucket_name")

    @gcs_bucket_name.setter
    def gcs_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "gcs_bucket_name", value)

    @property
    @pulumi.getter(name="gcsBucketPath")
    def gcs_bucket_path(self) -> pulumi.Input[str]:
        """
        GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
        """
        return pulumi.get(self, "gcs_bucket_path")

    @gcs_bucket_path.setter
    def gcs_bucket_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "gcs_bucket_path", value)

    @property
    @pulumi.getter(name="gcsBucketRegion")
    def gcs_bucket_region(self) -> Optional[pulumi.Input[str]]:
        """
        Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>. must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]; Default: "us"
        """
        return pulumi.get(self, "gcs_bucket_region")

    @gcs_bucket_region.setter
    def gcs_bucket_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gcs_bucket_region", value)


@pulumi.input_type
class DestinationGcsConfigurationCredentialArgs:
    def __init__(__self__, *,
                 hmac_key: Optional[pulumi.Input['DestinationGcsConfigurationCredentialHmacKeyArgs']] = None):
        if hmac_key is not None:
            pulumi.set(__self__, "hmac_key", hmac_key)

    @property
    @pulumi.getter(name="hmacKey")
    def hmac_key(self) -> Optional[pulumi.Input['DestinationGcsConfigurationCredentialHmacKeyArgs']]:
        return pulumi.get(self, "hmac_key")

    @hmac_key.setter
    def hmac_key(self, value: Optional[pulumi.Input['DestinationGcsConfigurationCredentialHmacKeyArgs']]):
        pulumi.set(self, "hmac_key", value)


@pulumi.input_type
class DestinationGcsConfigurationCredentialHmacKeyArgs:
    def __init__(__self__, *,
                 hmac_key_access_id: pulumi.Input[str],
                 hmac_key_secret: pulumi.Input[str],
                 credential_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hmac_key_access_id: When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
        :param pulumi.Input[str] hmac_key_secret: The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
        :param pulumi.Input[str] credential_type: must be one of ["HMAC_KEY"]; Default: "HMAC_KEY"
        """
        pulumi.set(__self__, "hmac_key_access_id", hmac_key_access_id)
        pulumi.set(__self__, "hmac_key_secret", hmac_key_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)

    @property
    @pulumi.getter(name="hmacKeyAccessId")
    def hmac_key_access_id(self) -> pulumi.Input[str]:
        """
        When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
        """
        return pulumi.get(self, "hmac_key_access_id")

    @hmac_key_access_id.setter
    def hmac_key_access_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "hmac_key_access_id", value)

    @property
    @pulumi.getter(name="hmacKeySecret")
    def hmac_key_secret(self) -> pulumi.Input[str]:
        """
        The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
        """
        return pulumi.get(self, "hmac_key_secret")

    @hmac_key_secret.setter
    def hmac_key_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "hmac_key_secret", value)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["HMAC_KEY"]; Default: "HMAC_KEY"
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatArgs:
    def __init__(__self__, *,
                 avro_apache_avro: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroArgs']] = None,
                 csv_comma_separated_values: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesArgs']] = None,
                 json_lines_newline_delimited_json: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']] = None,
                 parquet_columnar_storage: Optional[pulumi.Input['DestinationGcsConfigurationFormatParquetColumnarStorageArgs']] = None):
        if avro_apache_avro is not None:
            pulumi.set(__self__, "avro_apache_avro", avro_apache_avro)
        if csv_comma_separated_values is not None:
            pulumi.set(__self__, "csv_comma_separated_values", csv_comma_separated_values)
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)
        if parquet_columnar_storage is not None:
            pulumi.set(__self__, "parquet_columnar_storage", parquet_columnar_storage)

    @property
    @pulumi.getter(name="avroApacheAvro")
    def avro_apache_avro(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroArgs']]:
        return pulumi.get(self, "avro_apache_avro")

    @avro_apache_avro.setter
    def avro_apache_avro(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroArgs']]):
        pulumi.set(self, "avro_apache_avro", value)

    @property
    @pulumi.getter(name="csvCommaSeparatedValues")
    def csv_comma_separated_values(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesArgs']]:
        return pulumi.get(self, "csv_comma_separated_values")

    @csv_comma_separated_values.setter
    def csv_comma_separated_values(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesArgs']]):
        pulumi.set(self, "csv_comma_separated_values", value)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @json_lines_newline_delimited_json.setter
    def json_lines_newline_delimited_json(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]):
        pulumi.set(self, "json_lines_newline_delimited_json", value)

    @property
    @pulumi.getter(name="parquetColumnarStorage")
    def parquet_columnar_storage(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatParquetColumnarStorageArgs']]:
        return pulumi.get(self, "parquet_columnar_storage")

    @parquet_columnar_storage.setter
    def parquet_columnar_storage(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatParquetColumnarStorageArgs']]):
        pulumi.set(self, "parquet_columnar_storage", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroArgs:
    def __init__(__self__, *,
                 compression_codec: pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs'],
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs'] compression_codec: The compression algorithm used to compress data. Default to no compression.
        :param pulumi.Input[str] format_type: must be one of ["Avro"]; Default: "Avro"
        """
        pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs']:
        """
        The compression algorithm used to compress data. Default to no compression.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs']):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Avro"]; Default: "Avro"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs:
    def __init__(__self__, *,
                 bzip2: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args']] = None,
                 deflate: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs']] = None,
                 snappy: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs']] = None,
                 xz: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXzArgs']] = None,
                 zstandard: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs']] = None):
        if bzip2 is not None:
            pulumi.set(__self__, "bzip2", bzip2)
        if deflate is not None:
            pulumi.set(__self__, "deflate", deflate)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)
        if snappy is not None:
            pulumi.set(__self__, "snappy", snappy)
        if xz is not None:
            pulumi.set(__self__, "xz", xz)
        if zstandard is not None:
            pulumi.set(__self__, "zstandard", zstandard)

    @property
    @pulumi.getter
    def bzip2(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args']]:
        return pulumi.get(self, "bzip2")

    @bzip2.setter
    def bzip2(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args']]):
        pulumi.set(self, "bzip2", value)

    @property
    @pulumi.getter
    def deflate(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs']]:
        return pulumi.get(self, "deflate")

    @deflate.setter
    def deflate(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs']]):
        pulumi.set(self, "deflate", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)

    @property
    @pulumi.getter
    def snappy(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs']]:
        return pulumi.get(self, "snappy")

    @snappy.setter
    def snappy(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs']]):
        pulumi.set(self, "snappy", value)

    @property
    @pulumi.getter
    def xz(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXzArgs']]:
        return pulumi.get(self, "xz")

    @xz.setter
    def xz(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXzArgs']]):
        pulumi.set(self, "xz", value)

    @property
    @pulumi.getter
    def zstandard(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs']]:
        return pulumi.get(self, "zstandard")

    @zstandard.setter
    def zstandard(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs']]):
        pulumi.set(self, "zstandard", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["bzip2"]; Default: "bzip2"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["bzip2"]; Default: "bzip2"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None,
                 compression_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["Deflate"]; Default: "Deflate"
        :param pulumi.Input[int] compression_level: 0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Deflate"]; Default: "Deflate"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[pulumi.Input[int]]:
        """
        0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compression_level", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["no compression"]; Default: "no compression"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["no compression"]; Default: "no compression"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["snappy"]; Default: "snappy"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["snappy"]; Default: "snappy"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXzArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None,
                 compression_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["xz"]; Default: "xz"
        :param pulumi.Input[int] compression_level: The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["xz"]; Default: "xz"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[pulumi.Input[int]]:
        """
        The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compression_level", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None,
                 compression_level: Optional[pulumi.Input[int]] = None,
                 include_checksum: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["zstandard"]; Default: "zstandard"
        :param pulumi.Input[int] compression_level: Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        :param pulumi.Input[bool] include_checksum: If true, include a checksum with each data block. Default: false
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if include_checksum is not None:
            pulumi.set(__self__, "include_checksum", include_checksum)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["zstandard"]; Default: "zstandard"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[pulumi.Input[int]]:
        """
        Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compression_level", value)

    @property
    @pulumi.getter(name="includeChecksum")
    def include_checksum(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, include a checksum with each data block. Default: false
        """
        return pulumi.get(self, "include_checksum")

    @include_checksum.setter
    def include_checksum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_checksum", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesArgs:
    def __init__(__self__, *,
                 compression: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs']] = None,
                 flattening: Optional[pulumi.Input[str]] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs'] compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        :param pulumi.Input[str] flattening: Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        :param pulumi.Input[str] format_type: must be one of ["CSV"]; Default: "CSV"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs']]:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs']]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def flattening(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @flattening.setter
    def flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flattening", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["CSV"]; Default: "CSV"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs:
    def __init__(__self__, *,
                 gzip: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs']] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs']]:
        return pulumi.get(self, "gzip")

    @gzip.setter
    def gzip(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs']]):
        pulumi.set(self, "gzip", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonArgs:
    def __init__(__self__, *,
                 compression: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs'] compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        :param pulumi.Input[str] format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']]:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs:
    def __init__(__self__, *,
                 gzip: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']]:
        return pulumi.get(self, "gzip")

    @gzip.setter
    def gzip(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']]):
        pulumi.set(self, "gzip", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationGcsConfigurationFormatParquetColumnarStorageArgs:
    def __init__(__self__, *,
                 block_size_mb: Optional[pulumi.Input[int]] = None,
                 compression_codec: Optional[pulumi.Input[str]] = None,
                 dictionary_encoding: Optional[pulumi.Input[bool]] = None,
                 dictionary_page_size_kb: Optional[pulumi.Input[int]] = None,
                 format_type: Optional[pulumi.Input[str]] = None,
                 max_padding_size_mb: Optional[pulumi.Input[int]] = None,
                 page_size_kb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] block_size_mb: This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        :param pulumi.Input[str] compression_codec: The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        :param pulumi.Input[bool] dictionary_encoding: Default: true. Default: true
        :param pulumi.Input[int] dictionary_page_size_kb: There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        :param pulumi.Input[str] format_type: must be one of ["Parquet"]; Default: "Parquet"
        :param pulumi.Input[int] max_padding_size_mb: Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        :param pulumi.Input[int] page_size_kb: The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        if block_size_mb is not None:
            pulumi.set(__self__, "block_size_mb", block_size_mb)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if dictionary_encoding is not None:
            pulumi.set(__self__, "dictionary_encoding", dictionary_encoding)
        if dictionary_page_size_kb is not None:
            pulumi.set(__self__, "dictionary_page_size_kb", dictionary_page_size_kb)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)
        if max_padding_size_mb is not None:
            pulumi.set(__self__, "max_padding_size_mb", max_padding_size_mb)
        if page_size_kb is not None:
            pulumi.set(__self__, "page_size_kb", page_size_kb)

    @property
    @pulumi.getter(name="blockSizeMb")
    def block_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        """
        return pulumi.get(self, "block_size_mb")

    @block_size_mb.setter
    def block_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size_mb", value)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[str]]:
        """
        The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="dictionaryEncoding")
    def dictionary_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Default: true. Default: true
        """
        return pulumi.get(self, "dictionary_encoding")

    @dictionary_encoding.setter
    def dictionary_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dictionary_encoding", value)

    @property
    @pulumi.getter(name="dictionaryPageSizeKb")
    def dictionary_page_size_kb(self) -> Optional[pulumi.Input[int]]:
        """
        There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "dictionary_page_size_kb")

    @dictionary_page_size_kb.setter
    def dictionary_page_size_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dictionary_page_size_kb", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Parquet"]; Default: "Parquet"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)

    @property
    @pulumi.getter(name="maxPaddingSizeMb")
    def max_padding_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        """
        return pulumi.get(self, "max_padding_size_mb")

    @max_padding_size_mb.setter
    def max_padding_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_padding_size_mb", value)

    @property
    @pulumi.getter(name="pageSizeKb")
    def page_size_kb(self) -> Optional[pulumi.Input[int]]:
        """
        The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "page_size_kb")

    @page_size_kb.setter
    def page_size_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size_kb", value)


@pulumi.input_type
class DestinationGoogleSheetsConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['DestinationGoogleSheetsConfigurationCredentialsArgs'],
                 spreadsheet_id: pulumi.Input[str]):
        """
        :param pulumi.Input['DestinationGoogleSheetsConfigurationCredentialsArgs'] credentials: Google API Credentials for connecting to Google Sheets and Google Drive APIs
        :param pulumi.Input[str] spreadsheet_id: The link to your spreadsheet. See <a href='https://docs.airbyte.com/integrations/destinations/google-sheets#sheetlink'>this guide</a> for more details.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "spreadsheet_id", spreadsheet_id)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['DestinationGoogleSheetsConfigurationCredentialsArgs']:
        """
        Google API Credentials for connecting to Google Sheets and Google Drive APIs
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['DestinationGoogleSheetsConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="spreadsheetId")
    def spreadsheet_id(self) -> pulumi.Input[str]:
        """
        The link to your spreadsheet. See <a href='https://docs.airbyte.com/integrations/destinations/google-sheets#sheetlink'>this guide</a> for more details.
        """
        return pulumi.get(self, "spreadsheet_id")

    @spreadsheet_id.setter
    def spreadsheet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "spreadsheet_id", value)


@pulumi.input_type
class DestinationGoogleSheetsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Google Sheets developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Google Sheets developer application.
        :param pulumi.Input[str] refresh_token: The token for obtaining new access token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Google Sheets developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Google Sheets developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token for obtaining new access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class DestinationLangchainConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationLangchainConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationLangchainConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationLangchainConfigurationProcessingArgs']):
        """
        :param pulumi.Input['DestinationLangchainConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationLangchainConfigurationIndexingArgs'] indexing: Indexing configuration
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationLangchainConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationLangchainConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationLangchainConfigurationIndexingArgs']:
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationLangchainConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationLangchainConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationLangchainConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)


@pulumi.input_type
class DestinationLangchainConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 fake: Optional[pulumi.Input['DestinationLangchainConfigurationEmbeddingFakeArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationLangchainConfigurationEmbeddingOpenAiArgs']] = None):
        """
        :param pulumi.Input['DestinationLangchainConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationLangchainConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationLangchainConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationLangchainConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationLangchainConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationLangchainConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)


@pulumi.input_type
class DestinationLangchainConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationLangchainConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationLangchainConfigurationIndexingArgs:
    def __init__(__self__, *,
                 chroma_local_persistance: Optional[pulumi.Input['DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs']] = None,
                 doc_array_hnsw_search: Optional[pulumi.Input['DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs']] = None,
                 pinecone: Optional[pulumi.Input['DestinationLangchainConfigurationIndexingPineconeArgs']] = None):
        """
        :param pulumi.Input['DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs'] chroma_local_persistance: Chroma is a popular vector store that can be used to store and retrieve embeddings. It will build its index in memory and persist it to disk by the end of the sync.
        :param pulumi.Input['DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs'] doc_array_hnsw_search: DocArrayHnswSearch is a lightweight Document Index implementation provided by Docarray that runs fully locally and is best suited for small- to medium-sized datasets. It stores vectors on disk in hnswlib, and stores all other data in SQLite.
        :param pulumi.Input['DestinationLangchainConfigurationIndexingPineconeArgs'] pinecone: Pinecone is a popular vector store that can be used to store and retrieve embeddings. It is a managed service and can also be queried from outside of langchain.
        """
        if chroma_local_persistance is not None:
            pulumi.set(__self__, "chroma_local_persistance", chroma_local_persistance)
        if doc_array_hnsw_search is not None:
            pulumi.set(__self__, "doc_array_hnsw_search", doc_array_hnsw_search)
        if pinecone is not None:
            pulumi.set(__self__, "pinecone", pinecone)

    @property
    @pulumi.getter(name="chromaLocalPersistance")
    def chroma_local_persistance(self) -> Optional[pulumi.Input['DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs']]:
        """
        Chroma is a popular vector store that can be used to store and retrieve embeddings. It will build its index in memory and persist it to disk by the end of the sync.
        """
        return pulumi.get(self, "chroma_local_persistance")

    @chroma_local_persistance.setter
    def chroma_local_persistance(self, value: Optional[pulumi.Input['DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs']]):
        pulumi.set(self, "chroma_local_persistance", value)

    @property
    @pulumi.getter(name="docArrayHnswSearch")
    def doc_array_hnsw_search(self) -> Optional[pulumi.Input['DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs']]:
        """
        DocArrayHnswSearch is a lightweight Document Index implementation provided by Docarray that runs fully locally and is best suited for small- to medium-sized datasets. It stores vectors on disk in hnswlib, and stores all other data in SQLite.
        """
        return pulumi.get(self, "doc_array_hnsw_search")

    @doc_array_hnsw_search.setter
    def doc_array_hnsw_search(self, value: Optional[pulumi.Input['DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs']]):
        pulumi.set(self, "doc_array_hnsw_search", value)

    @property
    @pulumi.getter
    def pinecone(self) -> Optional[pulumi.Input['DestinationLangchainConfigurationIndexingPineconeArgs']]:
        """
        Pinecone is a popular vector store that can be used to store and retrieve embeddings. It is a managed service and can also be queried from outside of langchain.
        """
        return pulumi.get(self, "pinecone")

    @pinecone.setter
    def pinecone(self, value: Optional[pulumi.Input['DestinationLangchainConfigurationIndexingPineconeArgs']]):
        pulumi.set(self, "pinecone", value)


@pulumi.input_type
class DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs:
    def __init__(__self__, *,
                 destination_path: pulumi.Input[str],
                 collection_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination_path: Path to the directory where chroma files will be written. The files will be placed inside that local mount.
        :param pulumi.Input[str] collection_name: Name of the collection to use. Default: "langchain"
        """
        pulumi.set(__self__, "destination_path", destination_path)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> pulumi.Input[str]:
        """
        Path to the directory where chroma files will be written. The files will be placed inside that local mount.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_path", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the collection to use. Default: "langchain"
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)


@pulumi.input_type
class DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs:
    def __init__(__self__, *,
                 destination_path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination_path: Path to the directory where hnswlib and meta data files will be written. The files will be placed inside that local mount. All files in the specified destination directory will be deleted on each run.
        """
        pulumi.set(__self__, "destination_path", destination_path)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> pulumi.Input[str]:
        """
        Path to the directory where hnswlib and meta data files will be written. The files will be placed inside that local mount. All files in the specified destination directory will be deleted on each run.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_path", value)


@pulumi.input_type
class DestinationLangchainConfigurationIndexingPineconeArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 pinecone_environment: pulumi.Input[str],
                 pinecone_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] index: Pinecone index to use
        :param pulumi.Input[str] pinecone_environment: Pinecone environment to use
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "pinecone_environment", pinecone_environment)
        pulumi.set(__self__, "pinecone_key", pinecone_key)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        Pinecone index to use
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="pineconeEnvironment")
    def pinecone_environment(self) -> pulumi.Input[str]:
        """
        Pinecone environment to use
        """
        return pulumi.get(self, "pinecone_environment")

    @pinecone_environment.setter
    def pinecone_environment(self, value: pulumi.Input[str]):
        pulumi.set(self, "pinecone_environment", value)

    @property
    @pulumi.getter(name="pineconeKey")
    def pinecone_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pinecone_key")

    @pinecone_key.setter
    def pinecone_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "pinecone_key", value)


@pulumi.input_type
class DestinationLangchainConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 text_fields: pulumi.Input[Sequence[pulumi.Input[str]]],
                 chunk_overlap: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. All other fields are passed along as meta fields. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        pulumi.set(__self__, "text_fields", text_fields)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of fields in the record that should be used to calculate the embedding. All other fields are passed along as meta fields. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)


@pulumi.input_type
class DestinationMilvusConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationMilvusConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationMilvusConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationMilvusConfigurationProcessingArgs'],
                 omit_raw_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DestinationMilvusConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationMilvusConfigurationIndexingArgs'] indexing: Indexing configuration
        :param pulumi.Input[bool] omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationMilvusConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationMilvusConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationMilvusConfigurationIndexingArgs']:
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationMilvusConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationMilvusConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationMilvusConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")

    @omit_raw_text.setter
    def omit_raw_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_raw_text", value)


@pulumi.input_type
class DestinationMilvusConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 azure_open_ai: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs']] = None,
                 cohere: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingCohereArgs']] = None,
                 fake: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingFakeArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiArgs']] = None,
                 open_ai_compatible: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs']] = None):
        """
        :param pulumi.Input['DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs'] azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationMilvusConfigurationEmbeddingCohereArgs'] cohere: Use the Cohere API to embed text.
        :param pulumi.Input['DestinationMilvusConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs'] open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs']]:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @azure_open_ai.setter
    def azure_open_ai(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs']]):
        pulumi.set(self, "azure_open_ai", value)

    @property
    @pulumi.getter
    def cohere(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingCohereArgs']]:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @cohere.setter
    def cohere(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingCohereArgs']]):
        pulumi.set(self, "cohere", value)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs']]:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")

    @open_ai_compatible.setter
    def open_ai_compatible(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs']]):
        pulumi.set(self, "open_ai_compatible", value)


@pulumi.input_type
class DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs:
    def __init__(__self__, *,
                 api_base: pulumi.Input[str],
                 deployment: pulumi.Input[str],
                 openai_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> pulumi.Input[str]:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @api_base.setter
    def api_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_base", value)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationMilvusConfigurationEmbeddingCohereArgs:
    def __init__(__self__, *,
                 cohere_key: pulumi.Input[str]):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cohere_key")

    @cohere_key.setter
    def cohere_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "cohere_key", value)


@pulumi.input_type
class DestinationMilvusConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMilvusConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 dimensions: pulumi.Input[int],
                 api_key: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The base URL for your OpenAI-compatible service
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] api_key: Default: ""
        :param pulumi.Input[str] model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)


@pulumi.input_type
class DestinationMilvusConfigurationIndexingArgs:
    def __init__(__self__, *,
                 auth: pulumi.Input['DestinationMilvusConfigurationIndexingAuthArgs'],
                 collection: pulumi.Input[str],
                 host: pulumi.Input[str],
                 db: Optional[pulumi.Input[str]] = None,
                 text_field: Optional[pulumi.Input[str]] = None,
                 vector_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationMilvusConfigurationIndexingAuthArgs'] auth: Authentication method
        :param pulumi.Input[str] collection: The collection to load data into
        :param pulumi.Input[str] host: The public endpoint of the Milvus instance.
        :param pulumi.Input[str] db: The database to connect to. Default: ""
        :param pulumi.Input[str] text_field: The field in the entity that contains the embedded text. Default: "text"
        :param pulumi.Input[str] vector_field: The field in the entity that contains the vector. Default: "vector"
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "host", host)
        if db is not None:
            pulumi.set(__self__, "db", db)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter
    def auth(self) -> pulumi.Input['DestinationMilvusConfigurationIndexingAuthArgs']:
        """
        Authentication method
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: pulumi.Input['DestinationMilvusConfigurationIndexingAuthArgs']):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def collection(self) -> pulumi.Input[str]:
        """
        The collection to load data into
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The public endpoint of the Milvus instance.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def db(self) -> Optional[pulumi.Input[str]]:
        """
        The database to connect to. Default: ""
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[str]]:
        """
        The field in the entity that contains the embedded text. Default: "text"
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[pulumi.Input[str]]:
        """
        The field in the entity that contains the vector. Default: "vector"
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vector_field", value)


@pulumi.input_type
class DestinationMilvusConfigurationIndexingAuthArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthApiTokenArgs']] = None,
                 no_auth: Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthNoAuthArgs']] = None,
                 username_password: Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs']] = None):
        """
        :param pulumi.Input['DestinationMilvusConfigurationIndexingAuthApiTokenArgs'] api_token: Authenticate using an API token (suitable for Zilliz Cloud)
        :param pulumi.Input['DestinationMilvusConfigurationIndexingAuthNoAuthArgs'] no_auth: Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        :param pulumi.Input['DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs'] username_password: Authenticate using username and password (suitable for self-managed Milvus clusters)
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthApiTokenArgs']]:
        """
        Authenticate using an API token (suitable for Zilliz Cloud)
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthNoAuthArgs']]:
        """
        Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        """
        return pulumi.get(self, "no_auth")

    @no_auth.setter
    def no_auth(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthNoAuthArgs']]):
        pulumi.set(self, "no_auth", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs']]:
        """
        Authenticate using username and password (suitable for self-managed Milvus clusters)
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)


@pulumi.input_type
class DestinationMilvusConfigurationIndexingAuthApiTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: API Token for the Milvus instance
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        API Token for the Milvus instance
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class DestinationMilvusConfigurationIndexingAuthNoAuthArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Password for the Milvus instance
        :param pulumi.Input[str] username: Username for the Milvus instance
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the Milvus instance
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the Milvus instance
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DestinationMilvusConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 chunk_overlap: Optional[pulumi.Input[int]] = None,
                 field_name_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationMilvusConfigurationProcessingFieldNameMappingArgs']]]] = None,
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_splitter: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterArgs']] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input['DestinationMilvusConfigurationProcessingFieldNameMappingArgs']]] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterArgs'] text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationMilvusConfigurationProcessingFieldNameMappingArgs']]]]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @field_name_mappings.setter
    def field_name_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationMilvusConfigurationProcessingFieldNameMappingArgs']]]]):
        pulumi.set(self, "field_name_mappings", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterArgs']]:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")

    @text_splitter.setter
    def text_splitter(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterArgs']]):
        pulumi.set(self, "text_splitter", value)


@pulumi.input_type
class DestinationMilvusConfigurationProcessingFieldNameMappingArgs:
    def __init__(__self__, *,
                 from_field: pulumi.Input[str],
                 to_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_field: The field name in the source
        :param pulumi.Input[str] to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> pulumi.Input[str]:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> pulumi.Input[str]:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")

    @to_field.setter
    def to_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "to_field", value)


@pulumi.input_type
class DestinationMilvusConfigurationProcessingTextSplitterArgs:
    def __init__(__self__, *,
                 by_markdown_header: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs']] = None,
                 by_programming_language: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs']] = None,
                 by_separator: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs']] = None):
        """
        :param pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs'] by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs'] by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs'] by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @by_markdown_header.setter
    def by_markdown_header(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]):
        pulumi.set(self, "by_markdown_header", value)

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @by_programming_language.setter
    def by_programming_language(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]):
        pulumi.set(self, "by_programming_language", value)

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs']]:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")

    @by_separator.setter
    def by_separator(self, value: Optional[pulumi.Input['DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs']]):
        pulumi.set(self, "by_separator", value)


@pulumi.input_type
class DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs:
    def __init__(__self__, *,
                 split_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[pulumi.Input[int]]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")

    @split_level.setter
    def split_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_level", value)


@pulumi.input_type
class DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[str]:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[str]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs:
    def __init__(__self__, *,
                 keep_separator: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @keep_separator.setter
    def keep_separator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_separator", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


@pulumi.input_type
class DestinationMongodbConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DestinationMongodbConfigurationAuthTypeArgs'],
                 database: pulumi.Input[str],
                 instance_type: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input['DestinationMongodbConfigurationAuthTypeArgs'] auth_type: Authorization type.
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input['DestinationMongodbConfigurationInstanceTypeArgs'] instance_type: MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
        :param pulumi.Input['DestinationMongodbConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "database", database)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DestinationMongodbConfigurationAuthTypeArgs']:
        """
        Authorization type.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DestinationMongodbConfigurationAuthTypeArgs']):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeArgs']]:
        """
        MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeArgs']]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationMongodbConfigurationAuthTypeArgs:
    def __init__(__self__, *,
                 login_password: Optional[pulumi.Input['DestinationMongodbConfigurationAuthTypeLoginPasswordArgs']] = None,
                 none: Optional[pulumi.Input['DestinationMongodbConfigurationAuthTypeNoneArgs']] = None):
        """
        :param pulumi.Input['DestinationMongodbConfigurationAuthTypeLoginPasswordArgs'] login_password: Login/Password.
        :param pulumi.Input['DestinationMongodbConfigurationAuthTypeNoneArgs'] none: None.
        """
        if login_password is not None:
            pulumi.set(__self__, "login_password", login_password)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter(name="loginPassword")
    def login_password(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationAuthTypeLoginPasswordArgs']]:
        """
        Login/Password.
        """
        return pulumi.get(self, "login_password")

    @login_password.setter
    def login_password(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationAuthTypeLoginPasswordArgs']]):
        pulumi.set(self, "login_password", value)

    @property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationAuthTypeNoneArgs']]:
        """
        None.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationAuthTypeNoneArgs']]):
        pulumi.set(self, "none", value)


@pulumi.input_type
class DestinationMongodbConfigurationAuthTypeLoginPasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[str] username: Username to use to access the database.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DestinationMongodbConfigurationAuthTypeNoneArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMongodbConfigurationInstanceTypeArgs:
    def __init__(__self__, *,
                 mongo_db_atlas: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeMongoDbAtlasArgs']] = None,
                 replica_set: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeReplicaSetArgs']] = None,
                 standalone_mongo_db_instance: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstanceArgs']] = None):
        if mongo_db_atlas is not None:
            pulumi.set(__self__, "mongo_db_atlas", mongo_db_atlas)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if standalone_mongo_db_instance is not None:
            pulumi.set(__self__, "standalone_mongo_db_instance", standalone_mongo_db_instance)

    @property
    @pulumi.getter(name="mongoDbAtlas")
    def mongo_db_atlas(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeMongoDbAtlasArgs']]:
        return pulumi.get(self, "mongo_db_atlas")

    @mongo_db_atlas.setter
    def mongo_db_atlas(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeMongoDbAtlasArgs']]):
        pulumi.set(self, "mongo_db_atlas", value)

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeReplicaSetArgs']]:
        return pulumi.get(self, "replica_set")

    @replica_set.setter
    def replica_set(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeReplicaSetArgs']]):
        pulumi.set(self, "replica_set", value)

    @property
    @pulumi.getter(name="standaloneMongoDbInstance")
    def standalone_mongo_db_instance(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstanceArgs']]:
        return pulumi.get(self, "standalone_mongo_db_instance")

    @standalone_mongo_db_instance.setter
    def standalone_mongo_db_instance(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstanceArgs']]):
        pulumi.set(self, "standalone_mongo_db_instance", value)


@pulumi.input_type
class DestinationMongodbConfigurationInstanceTypeMongoDbAtlasArgs:
    def __init__(__self__, *,
                 cluster_url: pulumi.Input[str],
                 instance: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_url: URL of a cluster to connect to.
        :param pulumi.Input[str] instance: must be one of ["atlas"]; Default: "atlas"
        """
        pulumi.set(__self__, "cluster_url", cluster_url)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)

    @property
    @pulumi.getter(name="clusterUrl")
    def cluster_url(self) -> pulumi.Input[str]:
        """
        URL of a cluster to connect to.
        """
        return pulumi.get(self, "cluster_url")

    @cluster_url.setter
    def cluster_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_url", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["atlas"]; Default: "atlas"
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)


@pulumi.input_type
class DestinationMongodbConfigurationInstanceTypeReplicaSetArgs:
    def __init__(__self__, *,
                 server_addresses: pulumi.Input[str],
                 instance: Optional[pulumi.Input[str]] = None,
                 replica_set: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] server_addresses: The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
        :param pulumi.Input[str] instance: must be one of ["replica"]; Default: "replica"
        :param pulumi.Input[str] replica_set: A replica set name.
        """
        pulumi.set(__self__, "server_addresses", server_addresses)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)

    @property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> pulumi.Input[str]:
        """
        The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
        """
        return pulumi.get(self, "server_addresses")

    @server_addresses.setter
    def server_addresses(self, value: pulumi.Input[str]):
        pulumi.set(self, "server_addresses", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["replica"]; Default: "replica"
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[pulumi.Input[str]]:
        """
        A replica set name.
        """
        return pulumi.get(self, "replica_set")

    @replica_set.setter
    def replica_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set", value)


@pulumi.input_type
class DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstanceArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 instance: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: The Host of a Mongo database to be replicated.
        :param pulumi.Input[str] instance: must be one of ["standalone"]; Default: "standalone"
        :param pulumi.Input[int] port: The Port of a Mongo database to be replicated. Default: 27017
        """
        pulumi.set(__self__, "host", host)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The Host of a Mongo database to be replicated.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["standalone"]; Default: "standalone"
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The Port of a Mongo database to be replicated. Default: 27017
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class DestinationMongodbConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationMongodbConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationMongodbConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMongodbConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationMongodbConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationMssqlConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 ssl_method: Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: The name of the MSSQL database.
        :param pulumi.Input[str] host: The host name of the MSSQL database.
        :param pulumi.Input[str] username: The username which is used to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: The password associated with this username.
        :param pulumi.Input[int] port: The port of the MSSQL database. Default: 1433
        :param pulumi.Input[str] raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param pulumi.Input[str] schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        :param pulumi.Input['DestinationMssqlConfigurationSslMethodArgs'] ssl_method: The encryption method which is used to communicate with the database.
        :param pulumi.Input['DestinationMssqlConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl_method is not None:
            pulumi.set(__self__, "ssl_method", ssl_method)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the MSSQL database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host name of the MSSQL database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the MSSQL database. Default: 1433
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="sslMethod")
    def ssl_method(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodArgs']]:
        """
        The encryption method which is used to communicate with the database.
        """
        return pulumi.get(self, "ssl_method")

    @ssl_method.setter
    def ssl_method(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodArgs']]):
        pulumi.set(self, "ssl_method", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationMssqlConfigurationSslMethodArgs:
    def __init__(__self__, *,
                 encrypted_trust_server_certificate: Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs']] = None,
                 encrypted_verify_certificate: Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs']] = None):
        """
        :param pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs'] encrypted_trust_server_certificate: Use the certificate provided by the server without verification. (For testing purposes only!)
        :param pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs'] encrypted_verify_certificate: Verify and use the certificate provided by the server.
        """
        if encrypted_trust_server_certificate is not None:
            pulumi.set(__self__, "encrypted_trust_server_certificate", encrypted_trust_server_certificate)
        if encrypted_verify_certificate is not None:
            pulumi.set(__self__, "encrypted_verify_certificate", encrypted_verify_certificate)

    @property
    @pulumi.getter(name="encryptedTrustServerCertificate")
    def encrypted_trust_server_certificate(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs']]:
        """
        Use the certificate provided by the server without verification. (For testing purposes only!)
        """
        return pulumi.get(self, "encrypted_trust_server_certificate")

    @encrypted_trust_server_certificate.setter
    def encrypted_trust_server_certificate(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs']]):
        pulumi.set(self, "encrypted_trust_server_certificate", value)

    @property
    @pulumi.getter(name="encryptedVerifyCertificate")
    def encrypted_verify_certificate(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs']]:
        """
        Verify and use the certificate provided by the server.
        """
        return pulumi.get(self, "encrypted_verify_certificate")

    @encrypted_verify_certificate.setter
    def encrypted_verify_certificate(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs']]):
        pulumi.set(self, "encrypted_verify_certificate", value)


@pulumi.input_type
class DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs:
    def __init__(__self__, *,
                 host_name_in_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_name_in_certificate: Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        if host_name_in_certificate is not None:
            pulumi.set(__self__, "host_name_in_certificate", host_name_in_certificate)

    @property
    @pulumi.getter(name="hostNameInCertificate")
    def host_name_in_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        return pulumi.get(self, "host_name_in_certificate")

    @host_name_in_certificate.setter
    def host_name_in_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name_in_certificate", value)


@pulumi.input_type
class DestinationMssqlConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationMssqlConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMssqlConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationMysqlConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 disable_type_dedupe: Optional[pulumi.Input[bool]] = None,
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[bool] disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[int] port: Port of the database. Default: 3306
        :param pulumi.Input[str] raw_data_schema: The database to write raw tables into
        :param pulumi.Input['DestinationMysqlConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @disable_type_dedupe.setter
    def disable_type_dedupe(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_dedupe", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database. Default: 3306
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The database to write raw tables into
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationMysqlConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationMysqlConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationMysqlConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationOracleConfigurationArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 sid: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] host: The hostname of the database.
        :param pulumi.Input[str] sid: The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
        :param pulumi.Input[str] username: The username to access the database. This user must have CREATE USER privileges in the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: The password associated with the username.
        :param pulumi.Input[int] port: The port of the database. Default: 1521
        :param pulumi.Input[str] raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param pulumi.Input[str] schema: The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema. Default: "airbyte"
        :param pulumi.Input['DestinationOracleConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "sid", sid)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def sid(self) -> pulumi.Input[str]:
        """
        The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
        """
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: pulumi.Input[str]):
        pulumi.set(self, "sid", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username to access the database. This user must have CREATE USER privileges in the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the database. Default: 1521
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema. Default: "airbyte"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationOracleConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationOracleConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationOracleConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationOracleConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationOracleConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationPineconeConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationPineconeConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationPineconeConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationPineconeConfigurationProcessingArgs'],
                 omit_raw_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DestinationPineconeConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationPineconeConfigurationIndexingArgs'] indexing: Pinecone is a popular vector store that can be used to store and retrieve embeddings.
        :param pulumi.Input[bool] omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationPineconeConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationPineconeConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationPineconeConfigurationIndexingArgs']:
        """
        Pinecone is a popular vector store that can be used to store and retrieve embeddings.
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationPineconeConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationPineconeConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationPineconeConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")

    @omit_raw_text.setter
    def omit_raw_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_raw_text", value)


@pulumi.input_type
class DestinationPineconeConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 azure_open_ai: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs']] = None,
                 cohere: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingCohereArgs']] = None,
                 fake: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingFakeArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiArgs']] = None,
                 open_ai_compatible: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs']] = None):
        """
        :param pulumi.Input['DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs'] azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationPineconeConfigurationEmbeddingCohereArgs'] cohere: Use the Cohere API to embed text.
        :param pulumi.Input['DestinationPineconeConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs'] open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs']]:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @azure_open_ai.setter
    def azure_open_ai(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs']]):
        pulumi.set(self, "azure_open_ai", value)

    @property
    @pulumi.getter
    def cohere(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingCohereArgs']]:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @cohere.setter
    def cohere(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingCohereArgs']]):
        pulumi.set(self, "cohere", value)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs']]:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")

    @open_ai_compatible.setter
    def open_ai_compatible(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs']]):
        pulumi.set(self, "open_ai_compatible", value)


@pulumi.input_type
class DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs:
    def __init__(__self__, *,
                 api_base: pulumi.Input[str],
                 deployment: pulumi.Input[str],
                 openai_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> pulumi.Input[str]:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @api_base.setter
    def api_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_base", value)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationPineconeConfigurationEmbeddingCohereArgs:
    def __init__(__self__, *,
                 cohere_key: pulumi.Input[str]):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cohere_key")

    @cohere_key.setter
    def cohere_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "cohere_key", value)


@pulumi.input_type
class DestinationPineconeConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationPineconeConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 dimensions: pulumi.Input[int],
                 api_key: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The base URL for your OpenAI-compatible service
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] api_key: Default: ""
        :param pulumi.Input[str] model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)


@pulumi.input_type
class DestinationPineconeConfigurationIndexingArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 pinecone_environment: pulumi.Input[str],
                 pinecone_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] index: Pinecone index in your project to load data into
        :param pulumi.Input[str] pinecone_environment: Pinecone Cloud environment to use
        :param pulumi.Input[str] pinecone_key: The Pinecone API key to use matching the environment (copy from Pinecone console)
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "pinecone_environment", pinecone_environment)
        pulumi.set(__self__, "pinecone_key", pinecone_key)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        Pinecone index in your project to load data into
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="pineconeEnvironment")
    def pinecone_environment(self) -> pulumi.Input[str]:
        """
        Pinecone Cloud environment to use
        """
        return pulumi.get(self, "pinecone_environment")

    @pinecone_environment.setter
    def pinecone_environment(self, value: pulumi.Input[str]):
        pulumi.set(self, "pinecone_environment", value)

    @property
    @pulumi.getter(name="pineconeKey")
    def pinecone_key(self) -> pulumi.Input[str]:
        """
        The Pinecone API key to use matching the environment (copy from Pinecone console)
        """
        return pulumi.get(self, "pinecone_key")

    @pinecone_key.setter
    def pinecone_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "pinecone_key", value)


@pulumi.input_type
class DestinationPineconeConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 chunk_overlap: Optional[pulumi.Input[int]] = None,
                 field_name_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationPineconeConfigurationProcessingFieldNameMappingArgs']]]] = None,
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_splitter: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterArgs']] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input['DestinationPineconeConfigurationProcessingFieldNameMappingArgs']]] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterArgs'] text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationPineconeConfigurationProcessingFieldNameMappingArgs']]]]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @field_name_mappings.setter
    def field_name_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationPineconeConfigurationProcessingFieldNameMappingArgs']]]]):
        pulumi.set(self, "field_name_mappings", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterArgs']]:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")

    @text_splitter.setter
    def text_splitter(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterArgs']]):
        pulumi.set(self, "text_splitter", value)


@pulumi.input_type
class DestinationPineconeConfigurationProcessingFieldNameMappingArgs:
    def __init__(__self__, *,
                 from_field: pulumi.Input[str],
                 to_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_field: The field name in the source
        :param pulumi.Input[str] to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> pulumi.Input[str]:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> pulumi.Input[str]:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")

    @to_field.setter
    def to_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "to_field", value)


@pulumi.input_type
class DestinationPineconeConfigurationProcessingTextSplitterArgs:
    def __init__(__self__, *,
                 by_markdown_header: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs']] = None,
                 by_programming_language: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs']] = None,
                 by_separator: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs']] = None):
        """
        :param pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs'] by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs'] by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs'] by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @by_markdown_header.setter
    def by_markdown_header(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]):
        pulumi.set(self, "by_markdown_header", value)

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @by_programming_language.setter
    def by_programming_language(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]):
        pulumi.set(self, "by_programming_language", value)

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs']]:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")

    @by_separator.setter
    def by_separator(self, value: Optional[pulumi.Input['DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs']]):
        pulumi.set(self, "by_separator", value)


@pulumi.input_type
class DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs:
    def __init__(__self__, *,
                 split_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[pulumi.Input[int]]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")

    @split_level.setter
    def split_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_level", value)


@pulumi.input_type
class DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[str]:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[str]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs:
    def __init__(__self__, *,
                 keep_separator: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @keep_separator.setter
    def keep_separator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_separator", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


@pulumi.input_type
class DestinationPostgresConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 disable_type_dedupe: Optional[pulumi.Input[bool]] = None,
                 drop_cascade: Optional[pulumi.Input[bool]] = None,
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 ssl_mode: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[bool] disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param pulumi.Input[bool] drop_cascade: Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[int] port: Port of the database. Default: 5432
        :param pulumi.Input[str] raw_data_schema: The schema to write raw tables into
        :param pulumi.Input[str] schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        :param pulumi.Input['DestinationPostgresConfigurationSslModeArgs'] ssl_mode: SSL connection modes. 
                <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
                <b>allow</b> - Chose this mode to enable encryption only when required by the source database
                <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
                <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
                 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
                 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
                See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        :param pulumi.Input['DestinationPostgresConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if drop_cascade is not None:
            pulumi.set(__self__, "drop_cascade", drop_cascade)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @disable_type_dedupe.setter
    def disable_type_dedupe(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_dedupe", value)

    @property
    @pulumi.getter(name="dropCascade")
    def drop_cascade(self) -> Optional[pulumi.Input[bool]]:
        """
        Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        """
        return pulumi.get(self, "drop_cascade")

    @drop_cascade.setter
    def drop_cascade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_cascade", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database. Default: 5432
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema to write raw tables into
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModeArgs']]:
        """
        SSL connection modes. 
         <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
         <b>allow</b> - Chose this mode to enable encryption only when required by the source database
         <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
         <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
          <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
          <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
         See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeArgs']]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationPostgresConfigurationSslModeArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeAllowArgs']] = None,
                 disable: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeDisableArgs']] = None,
                 prefer: Optional[pulumi.Input['DestinationPostgresConfigurationSslModePreferArgs']] = None,
                 require: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeRequireArgs']] = None,
                 verify_ca: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeVerifyCaArgs']] = None,
                 verify_full: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeVerifyFullArgs']] = None):
        """
        :param pulumi.Input['DestinationPostgresConfigurationSslModeAllowArgs'] allow: Allow SSL mode.
        :param pulumi.Input['DestinationPostgresConfigurationSslModeDisableArgs'] disable: Disable SSL.
        :param pulumi.Input['DestinationPostgresConfigurationSslModePreferArgs'] prefer: Prefer SSL mode.
        :param pulumi.Input['DestinationPostgresConfigurationSslModeRequireArgs'] require: Require SSL mode.
        :param pulumi.Input['DestinationPostgresConfigurationSslModeVerifyCaArgs'] verify_ca: Verify-ca SSL mode.
        :param pulumi.Input['DestinationPostgresConfigurationSslModeVerifyFullArgs'] verify_full: Verify-full SSL mode.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModeAllowArgs']]:
        """
        Allow SSL mode.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModeDisableArgs']]:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeDisableArgs']]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def prefer(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModePreferArgs']]:
        """
        Prefer SSL mode.
        """
        return pulumi.get(self, "prefer")

    @prefer.setter
    def prefer(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModePreferArgs']]):
        pulumi.set(self, "prefer", value)

    @property
    @pulumi.getter
    def require(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModeRequireArgs']]:
        """
        Require SSL mode.
        """
        return pulumi.get(self, "require")

    @require.setter
    def require(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeRequireArgs']]):
        pulumi.set(self, "require", value)

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModeVerifyCaArgs']]:
        """
        Verify-ca SSL mode.
        """
        return pulumi.get(self, "verify_ca")

    @verify_ca.setter
    def verify_ca(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeVerifyCaArgs']]):
        pulumi.set(self, "verify_ca", value)

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationSslModeVerifyFullArgs']]:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")

    @verify_full.setter
    def verify_full(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationSslModeVerifyFullArgs']]):
        pulumi.set(self, "verify_full", value)


@pulumi.input_type
class DestinationPostgresConfigurationSslModeAllowArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationPostgresConfigurationSslModeDisableArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationPostgresConfigurationSslModePreferArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationPostgresConfigurationSslModeRequireArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationPostgresConfigurationSslModeVerifyCaArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class DestinationPostgresConfigurationSslModeVerifyFullArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_certificate: pulumi.Input[str],
                 client_key: pulumi.Input[str],
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_certificate: Client certificate
        :param pulumi.Input[str] client_key: Client key
        :param pulumi.Input[str] client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Input[str]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> pulumi.Input[str]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class DestinationPostgresConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationPostgresConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationPostgresConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationPostgresConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationPostgresConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationPubsubConfigurationArgs:
    def __init__(__self__, *,
                 credentials_json: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 topic_id: pulumi.Input[str],
                 batching_delay_threshold: Optional[pulumi.Input[int]] = None,
                 batching_element_count_threshold: Optional[pulumi.Input[int]] = None,
                 batching_enabled: Optional[pulumi.Input[bool]] = None,
                 batching_request_bytes_threshold: Optional[pulumi.Input[int]] = None,
                 ordering_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] credentials_json: The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/pubsub">docs</a> if you need help generating this key.
        :param pulumi.Input[str] project_id: The GCP project ID for the project containing the target PubSub.
        :param pulumi.Input[str] topic_id: The PubSub topic ID in the given GCP project ID.
        :param pulumi.Input[int] batching_delay_threshold: Number of ms before the buffer is flushed. Default: 1
        :param pulumi.Input[int] batching_element_count_threshold: Number of messages before the buffer is flushed. Default: 1
        :param pulumi.Input[bool] batching_enabled: If TRUE messages will be buffered instead of sending them one by one. Default: false
        :param pulumi.Input[int] batching_request_bytes_threshold: Number of bytes before the buffer is flushed. Default: 1
        :param pulumi.Input[bool] ordering_enabled: If TRUE PubSub publisher will have <a href="https://cloud.google.com/pubsub/docs/ordering">message ordering</a> enabled. Every message will have an ordering key of stream. Default: false
        """
        pulumi.set(__self__, "credentials_json", credentials_json)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "topic_id", topic_id)
        if batching_delay_threshold is not None:
            pulumi.set(__self__, "batching_delay_threshold", batching_delay_threshold)
        if batching_element_count_threshold is not None:
            pulumi.set(__self__, "batching_element_count_threshold", batching_element_count_threshold)
        if batching_enabled is not None:
            pulumi.set(__self__, "batching_enabled", batching_enabled)
        if batching_request_bytes_threshold is not None:
            pulumi.set(__self__, "batching_request_bytes_threshold", batching_request_bytes_threshold)
        if ordering_enabled is not None:
            pulumi.set(__self__, "ordering_enabled", ordering_enabled)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> pulumi.Input[str]:
        """
        The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/pubsub">docs</a> if you need help generating this key.
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_json", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The GCP project ID for the project containing the target PubSub.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[str]:
        """
        The PubSub topic ID in the given GCP project ID.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_id", value)

    @property
    @pulumi.getter(name="batchingDelayThreshold")
    def batching_delay_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of ms before the buffer is flushed. Default: 1
        """
        return pulumi.get(self, "batching_delay_threshold")

    @batching_delay_threshold.setter
    def batching_delay_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batching_delay_threshold", value)

    @property
    @pulumi.getter(name="batchingElementCountThreshold")
    def batching_element_count_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of messages before the buffer is flushed. Default: 1
        """
        return pulumi.get(self, "batching_element_count_threshold")

    @batching_element_count_threshold.setter
    def batching_element_count_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batching_element_count_threshold", value)

    @property
    @pulumi.getter(name="batchingEnabled")
    def batching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If TRUE messages will be buffered instead of sending them one by one. Default: false
        """
        return pulumi.get(self, "batching_enabled")

    @batching_enabled.setter
    def batching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batching_enabled", value)

    @property
    @pulumi.getter(name="batchingRequestBytesThreshold")
    def batching_request_bytes_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Number of bytes before the buffer is flushed. Default: 1
        """
        return pulumi.get(self, "batching_request_bytes_threshold")

    @batching_request_bytes_threshold.setter
    def batching_request_bytes_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batching_request_bytes_threshold", value)

    @property
    @pulumi.getter(name="orderingEnabled")
    def ordering_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If TRUE PubSub publisher will have <a href="https://cloud.google.com/pubsub/docs/ordering">message ordering</a> enabled. Every message will have an ordering key of stream. Default: false
        """
        return pulumi.get(self, "ordering_enabled")

    @ordering_enabled.setter
    def ordering_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ordering_enabled", value)


@pulumi.input_type
class DestinationQdrantConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationQdrantConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationQdrantConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationQdrantConfigurationProcessingArgs'],
                 omit_raw_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DestinationQdrantConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationQdrantConfigurationIndexingArgs'] indexing: Indexing configuration
        :param pulumi.Input[bool] omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationQdrantConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationQdrantConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationQdrantConfigurationIndexingArgs']:
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationQdrantConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationQdrantConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationQdrantConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")

    @omit_raw_text.setter
    def omit_raw_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_raw_text", value)


@pulumi.input_type
class DestinationQdrantConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 azure_open_ai: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs']] = None,
                 cohere: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingCohereArgs']] = None,
                 fake: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingFakeArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiArgs']] = None,
                 open_ai_compatible: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs']] = None):
        """
        :param pulumi.Input['DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs'] azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationQdrantConfigurationEmbeddingCohereArgs'] cohere: Use the Cohere API to embed text.
        :param pulumi.Input['DestinationQdrantConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs'] open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs']]:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @azure_open_ai.setter
    def azure_open_ai(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs']]):
        pulumi.set(self, "azure_open_ai", value)

    @property
    @pulumi.getter
    def cohere(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingCohereArgs']]:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @cohere.setter
    def cohere(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingCohereArgs']]):
        pulumi.set(self, "cohere", value)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs']]:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")

    @open_ai_compatible.setter
    def open_ai_compatible(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs']]):
        pulumi.set(self, "open_ai_compatible", value)


@pulumi.input_type
class DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs:
    def __init__(__self__, *,
                 api_base: pulumi.Input[str],
                 deployment: pulumi.Input[str],
                 openai_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> pulumi.Input[str]:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @api_base.setter
    def api_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_base", value)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationQdrantConfigurationEmbeddingCohereArgs:
    def __init__(__self__, *,
                 cohere_key: pulumi.Input[str]):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cohere_key")

    @cohere_key.setter
    def cohere_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "cohere_key", value)


@pulumi.input_type
class DestinationQdrantConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationQdrantConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 dimensions: pulumi.Input[int],
                 api_key: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The base URL for your OpenAI-compatible service
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] api_key: Default: ""
        :param pulumi.Input[str] model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)


@pulumi.input_type
class DestinationQdrantConfigurationIndexingArgs:
    def __init__(__self__, *,
                 collection: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auth_method: Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodArgs']] = None,
                 distance_metric: Optional[pulumi.Input[str]] = None,
                 prefer_grpc: Optional[pulumi.Input[bool]] = None,
                 text_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] collection: The collection to load data into
        :param pulumi.Input[str] url: Public Endpoint of the Qdrant cluser
        :param pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodArgs'] auth_method: Method to authenticate with the Qdrant Instance
        :param pulumi.Input[str] distance_metric: The Distance metric used to measure similarities among vectors. This field is only used if the collection defined in the does not exist yet and is created automatically by the connector. must be one of ["dot", "cos", "euc"]; Default: "cos"
        :param pulumi.Input[bool] prefer_grpc: Whether to prefer gRPC over HTTP. Set to true for Qdrant cloud clusters. Default: true
        :param pulumi.Input[str] text_field: The field in the payload that contains the embedded text. Default: "text"
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "url", url)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if distance_metric is not None:
            pulumi.set(__self__, "distance_metric", distance_metric)
        if prefer_grpc is not None:
            pulumi.set(__self__, "prefer_grpc", prefer_grpc)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter
    def collection(self) -> pulumi.Input[str]:
        """
        The collection to load data into
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Public Endpoint of the Qdrant cluser
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodArgs']]:
        """
        Method to authenticate with the Qdrant Instance
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodArgs']]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="distanceMetric")
    def distance_metric(self) -> Optional[pulumi.Input[str]]:
        """
        The Distance metric used to measure similarities among vectors. This field is only used if the collection defined in the does not exist yet and is created automatically by the connector. must be one of ["dot", "cos", "euc"]; Default: "cos"
        """
        return pulumi.get(self, "distance_metric")

    @distance_metric.setter
    def distance_metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "distance_metric", value)

    @property
    @pulumi.getter(name="preferGrpc")
    def prefer_grpc(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to prefer gRPC over HTTP. Set to true for Qdrant cloud clusters. Default: true
        """
        return pulumi.get(self, "prefer_grpc")

    @prefer_grpc.setter
    def prefer_grpc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prefer_grpc", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[str]]:
        """
        The field in the payload that contains the embedded text. Default: "text"
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_field", value)


@pulumi.input_type
class DestinationQdrantConfigurationIndexingAuthMethodArgs:
    def __init__(__self__, *,
                 api_key_auth: Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuthArgs']] = None,
                 no_auth: Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodNoAuthArgs']] = None):
        if api_key_auth is not None:
            pulumi.set(__self__, "api_key_auth", api_key_auth)
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)

    @property
    @pulumi.getter(name="apiKeyAuth")
    def api_key_auth(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuthArgs']]:
        return pulumi.get(self, "api_key_auth")

    @api_key_auth.setter
    def api_key_auth(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuthArgs']]):
        pulumi.set(self, "api_key_auth", value)

    @property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodNoAuthArgs']]:
        return pulumi.get(self, "no_auth")

    @no_auth.setter
    def no_auth(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationIndexingAuthMethodNoAuthArgs']]):
        pulumi.set(self, "no_auth", value)


@pulumi.input_type
class DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuthArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key for the Qdrant instance
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key for the Qdrant instance
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class DestinationQdrantConfigurationIndexingAuthMethodNoAuthArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationQdrantConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 chunk_overlap: Optional[pulumi.Input[int]] = None,
                 field_name_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationQdrantConfigurationProcessingFieldNameMappingArgs']]]] = None,
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_splitter: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterArgs']] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input['DestinationQdrantConfigurationProcessingFieldNameMappingArgs']]] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterArgs'] text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationQdrantConfigurationProcessingFieldNameMappingArgs']]]]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @field_name_mappings.setter
    def field_name_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationQdrantConfigurationProcessingFieldNameMappingArgs']]]]):
        pulumi.set(self, "field_name_mappings", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterArgs']]:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")

    @text_splitter.setter
    def text_splitter(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterArgs']]):
        pulumi.set(self, "text_splitter", value)


@pulumi.input_type
class DestinationQdrantConfigurationProcessingFieldNameMappingArgs:
    def __init__(__self__, *,
                 from_field: pulumi.Input[str],
                 to_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_field: The field name in the source
        :param pulumi.Input[str] to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> pulumi.Input[str]:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> pulumi.Input[str]:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")

    @to_field.setter
    def to_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "to_field", value)


@pulumi.input_type
class DestinationQdrantConfigurationProcessingTextSplitterArgs:
    def __init__(__self__, *,
                 by_markdown_header: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs']] = None,
                 by_programming_language: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs']] = None,
                 by_separator: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs']] = None):
        """
        :param pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs'] by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs'] by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs'] by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @by_markdown_header.setter
    def by_markdown_header(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]):
        pulumi.set(self, "by_markdown_header", value)

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @by_programming_language.setter
    def by_programming_language(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]):
        pulumi.set(self, "by_programming_language", value)

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs']]:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")

    @by_separator.setter
    def by_separator(self, value: Optional[pulumi.Input['DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs']]):
        pulumi.set(self, "by_separator", value)


@pulumi.input_type
class DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs:
    def __init__(__self__, *,
                 split_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[pulumi.Input[int]]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")

    @split_level.setter
    def split_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_level", value)


@pulumi.input_type
class DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[str]:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[str]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs:
    def __init__(__self__, *,
                 keep_separator: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @keep_separator.setter
    def keep_separator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_separator", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


@pulumi.input_type
class DestinationRedisConfigurationArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 cache_type: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 ssl_mode: Optional[pulumi.Input['DestinationRedisConfigurationSslModeArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] host: Redis host to connect to.
        :param pulumi.Input[str] username: Username associated with Redis.
        :param pulumi.Input[str] cache_type: Redis cache type to store data in. must be one of ["hash"]; Default: "hash"
        :param pulumi.Input[str] password: Password associated with Redis.
        :param pulumi.Input[int] port: Port of Redis. Default: 6379
        :param pulumi.Input[bool] ssl: Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible. Default: false
        :param pulumi.Input['DestinationRedisConfigurationSslModeArgs'] ssl_mode: SSL connection modes. 
                 <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
        :param pulumi.Input['DestinationRedisConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if cache_type is not None:
            pulumi.set(__self__, "cache_type", cache_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Redis host to connect to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username associated with Redis.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> Optional[pulumi.Input[str]]:
        """
        Redis cache type to store data in. must be one of ["hash"]; Default: "hash"
        """
        return pulumi.get(self, "cache_type")

    @cache_type.setter
    def cache_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cache_type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with Redis.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of Redis. Default: 6379
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible. Default: false
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input['DestinationRedisConfigurationSslModeArgs']]:
        """
        SSL connection modes. 
          <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input['DestinationRedisConfigurationSslModeArgs']]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationRedisConfigurationSslModeArgs:
    def __init__(__self__, *,
                 disable: Optional[pulumi.Input['DestinationRedisConfigurationSslModeDisableArgs']] = None,
                 verify_full: Optional[pulumi.Input['DestinationRedisConfigurationSslModeVerifyFullArgs']] = None):
        """
        :param pulumi.Input['DestinationRedisConfigurationSslModeDisableArgs'] disable: Disable SSL.
        :param pulumi.Input['DestinationRedisConfigurationSslModeVerifyFullArgs'] verify_full: Verify-full SSL mode.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['DestinationRedisConfigurationSslModeDisableArgs']]:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['DestinationRedisConfigurationSslModeDisableArgs']]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional[pulumi.Input['DestinationRedisConfigurationSslModeVerifyFullArgs']]:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")

    @verify_full.setter
    def verify_full(self, value: Optional[pulumi.Input['DestinationRedisConfigurationSslModeVerifyFullArgs']]):
        pulumi.set(self, "verify_full", value)


@pulumi.input_type
class DestinationRedisConfigurationSslModeDisableArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationRedisConfigurationSslModeVerifyFullArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_certificate: pulumi.Input[str],
                 client_key: pulumi.Input[str],
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_certificate: Client certificate
        :param pulumi.Input[str] client_key: Client key
        :param pulumi.Input[str] client_key_password: Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Input[str]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> pulumi.Input[str]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class DestinationRedisConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationRedisConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationRedisConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationRedisConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationRedisConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationRedshiftConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 disable_type_dedupe: Optional[pulumi.Input[bool]] = None,
                 drop_cascade: Optional[pulumi.Input[bool]] = None,
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodArgs']] = None,
                 uploading_method: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[bool] disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param pulumi.Input[bool] drop_cascade: Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[int] port: Port of the database. Default: 5439
        :param pulumi.Input[str] raw_data_schema: The schema to write raw tables into (default: airbyte_internal).
        :param pulumi.Input[str] schema: The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public". Default: "public"
        :param pulumi.Input['DestinationRedshiftConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        :param pulumi.Input['DestinationRedshiftConfigurationUploadingMethodArgs'] uploading_method: The way data will be uploaded to Redshift.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if drop_cascade is not None:
            pulumi.set(__self__, "drop_cascade", drop_cascade)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)
        if uploading_method is not None:
            pulumi.set(__self__, "uploading_method", uploading_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @disable_type_dedupe.setter
    def disable_type_dedupe(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_dedupe", value)

    @property
    @pulumi.getter(name="dropCascade")
    def drop_cascade(self) -> Optional[pulumi.Input[bool]]:
        """
        Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        """
        return pulumi.get(self, "drop_cascade")

    @drop_cascade.setter
    def drop_cascade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_cascade", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database. Default: 5439
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema to write raw tables into (default: airbyte_internal).
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)

    @property
    @pulumi.getter(name="uploadingMethod")
    def uploading_method(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodArgs']]:
        """
        The way data will be uploaded to Redshift.
        """
        return pulumi.get(self, "uploading_method")

    @uploading_method.setter
    def uploading_method(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodArgs']]):
        pulumi.set(self, "uploading_method", value)


@pulumi.input_type
class DestinationRedshiftConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationRedshiftConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationRedshiftConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationRedshiftConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationRedshiftConfigurationUploadingMethodArgs:
    def __init__(__self__, *,
                 awss3_staging: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs']] = None,
                 standard: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodStandardArgs']] = None):
        """
        :param pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs'] awss3_staging: <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
        :param pulumi.Input['DestinationRedshiftConfigurationUploadingMethodStandardArgs'] standard: <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use S3 uploading.
        """
        if awss3_staging is not None:
            pulumi.set(__self__, "awss3_staging", awss3_staging)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter(name="awss3Staging")
    def awss3_staging(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs']]:
        """
        <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
        """
        return pulumi.get(self, "awss3_staging")

    @awss3_staging.setter
    def awss3_staging(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs']]):
        pulumi.set(self, "awss3_staging", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodStandardArgs']]:
        """
        <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use S3 uploading.
        """
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodStandardArgs']]):
        pulumi.set(self, "standard", value)


@pulumi.input_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[str],
                 s3_bucket_name: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str],
                 encryption: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs']] = None,
                 file_name_pattern: Optional[pulumi.Input[str]] = None,
                 purge_staging_data: Optional[pulumi.Input[bool]] = None,
                 s3_bucket_path: Optional[pulumi.Input[str]] = None,
                 s3_bucket_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        :param pulumi.Input[str] s3_bucket_name: The name of the staging S3 bucket.
        :param pulumi.Input[str] secret_access_key: The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        :param pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs'] encryption: How to encrypt the staging data
        :param pulumi.Input[str] file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param pulumi.Input[bool] purge_staging_data: Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details. Default: true
        :param pulumi.Input[str] s3_bucket_path: The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
        :param pulumi.Input[str] s3_bucket_region: The region of the S3 staging bucket. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if purge_staging_data is not None:
            pulumi.set(__self__, "purge_staging_data", purge_staging_data)
        if s3_bucket_path is not None:
            pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[str]:
        """
        This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the staging S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        """
        The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs']]:
        """
        How to encrypt the staging data
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @file_name_pattern.setter
    def file_name_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_pattern", value)

    @property
    @pulumi.getter(name="purgeStagingData")
    def purge_staging_data(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details. Default: true
        """
        return pulumi.get(self, "purge_staging_data")

    @purge_staging_data.setter
    def purge_staging_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "purge_staging_data", value)

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
        """
        return pulumi.get(self, "s3_bucket_path")

    @s3_bucket_path.setter
    def s3_bucket_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_path", value)

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the S3 staging bucket. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")

    @s3_bucket_region.setter
    def s3_bucket_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_region", value)


@pulumi.input_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs:
    def __init__(__self__, *,
                 aescbc_envelope_encryption: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs']] = None,
                 no_encryption: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs']] = None):
        """
        :param pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs'] aescbc_envelope_encryption: Staging data will be encrypted using AES-CBC envelope encryption.
        :param pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs'] no_encryption: Staging data will be stored in plaintext.
        """
        if aescbc_envelope_encryption is not None:
            pulumi.set(__self__, "aescbc_envelope_encryption", aescbc_envelope_encryption)
        if no_encryption is not None:
            pulumi.set(__self__, "no_encryption", no_encryption)

    @property
    @pulumi.getter(name="aescbcEnvelopeEncryption")
    def aescbc_envelope_encryption(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs']]:
        """
        Staging data will be encrypted using AES-CBC envelope encryption.
        """
        return pulumi.get(self, "aescbc_envelope_encryption")

    @aescbc_envelope_encryption.setter
    def aescbc_envelope_encryption(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs']]):
        pulumi.set(self, "aescbc_envelope_encryption", value)

    @property
    @pulumi.getter(name="noEncryption")
    def no_encryption(self) -> Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs']]:
        """
        Staging data will be stored in plaintext.
        """
        return pulumi.get(self, "no_encryption")

    @no_encryption.setter
    def no_encryption(self, value: Optional[pulumi.Input['DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs']]):
        pulumi.set(self, "no_encryption", value)


@pulumi.input_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs:
    def __init__(__self__, *,
                 key_encrypting_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_encrypting_key: The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
        """
        if key_encrypting_key is not None:
            pulumi.set(__self__, "key_encrypting_key", key_encrypting_key)

    @property
    @pulumi.getter(name="keyEncryptingKey")
    def key_encrypting_key(self) -> Optional[pulumi.Input[str]]:
        """
        The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
        """
        return pulumi.get(self, "key_encrypting_key")

    @key_encrypting_key.setter
    def key_encrypting_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_encrypting_key", value)


@pulumi.input_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationRedshiftConfigurationUploadingMethodStandardArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationS3ConfigurationArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['DestinationS3ConfigurationFormatArgs'],
                 s3_bucket_name: pulumi.Input[str],
                 s3_bucket_path: pulumi.Input[str],
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 file_name_pattern: Optional[pulumi.Input[str]] = None,
                 s3_bucket_region: Optional[pulumi.Input[str]] = None,
                 s3_endpoint: Optional[pulumi.Input[str]] = None,
                 s3_path_format: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationS3ConfigurationFormatArgs'] format: Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        :param pulumi.Input[str] s3_bucket_name: The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        :param pulumi.Input[str] s3_bucket_path: Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        :param pulumi.Input[str] access_key_id: The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        :param pulumi.Input[str] file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param pulumi.Input[str] s3_bucket_region: The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        :param pulumi.Input[str] s3_endpoint: Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        :param pulumi.Input[str] s3_path_format: Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        :param pulumi.Input[str] secret_access_key: The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)
        if s3_endpoint is not None:
            pulumi.set(__self__, "s3_endpoint", s3_endpoint)
        if s3_path_format is not None:
            pulumi.set(__self__, "s3_path_format", s3_path_format)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['DestinationS3ConfigurationFormatArgs']:
        """
        Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['DestinationS3ConfigurationFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> pulumi.Input[str]:
        """
        Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        """
        return pulumi.get(self, "s3_bucket_path")

    @s3_bucket_path.setter
    def s3_bucket_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_path", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @file_name_pattern.setter
    def file_name_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_pattern", value)

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")

    @s3_bucket_region.setter
    def s3_bucket_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_region", value)

    @property
    @pulumi.getter(name="s3Endpoint")
    def s3_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        """
        return pulumi.get(self, "s3_endpoint")

    @s3_endpoint.setter
    def s3_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_endpoint", value)

    @property
    @pulumi.getter(name="s3PathFormat")
    def s3_path_format(self) -> Optional[pulumi.Input[str]]:
        """
        Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        """
        return pulumi.get(self, "s3_path_format")

    @s3_path_format.setter
    def s3_path_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_path_format", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatArgs:
    def __init__(__self__, *,
                 avro_apache_avro: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroArgs']] = None,
                 csv_comma_separated_values: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesArgs']] = None,
                 json_lines_newline_delimited_json: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']] = None,
                 parquet_columnar_storage: Optional[pulumi.Input['DestinationS3ConfigurationFormatParquetColumnarStorageArgs']] = None):
        if avro_apache_avro is not None:
            pulumi.set(__self__, "avro_apache_avro", avro_apache_avro)
        if csv_comma_separated_values is not None:
            pulumi.set(__self__, "csv_comma_separated_values", csv_comma_separated_values)
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)
        if parquet_columnar_storage is not None:
            pulumi.set(__self__, "parquet_columnar_storage", parquet_columnar_storage)

    @property
    @pulumi.getter(name="avroApacheAvro")
    def avro_apache_avro(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroArgs']]:
        return pulumi.get(self, "avro_apache_avro")

    @avro_apache_avro.setter
    def avro_apache_avro(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroArgs']]):
        pulumi.set(self, "avro_apache_avro", value)

    @property
    @pulumi.getter(name="csvCommaSeparatedValues")
    def csv_comma_separated_values(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesArgs']]:
        return pulumi.get(self, "csv_comma_separated_values")

    @csv_comma_separated_values.setter
    def csv_comma_separated_values(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesArgs']]):
        pulumi.set(self, "csv_comma_separated_values", value)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @json_lines_newline_delimited_json.setter
    def json_lines_newline_delimited_json(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]):
        pulumi.set(self, "json_lines_newline_delimited_json", value)

    @property
    @pulumi.getter(name="parquetColumnarStorage")
    def parquet_columnar_storage(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatParquetColumnarStorageArgs']]:
        return pulumi.get(self, "parquet_columnar_storage")

    @parquet_columnar_storage.setter
    def parquet_columnar_storage(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatParquetColumnarStorageArgs']]):
        pulumi.set(self, "parquet_columnar_storage", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroArgs:
    def __init__(__self__, *,
                 compression_codec: pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs'],
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs'] compression_codec: The compression algorithm used to compress data. Default to no compression.
        :param pulumi.Input[str] format_type: must be one of ["Avro"]; Default: "Avro"
        """
        pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs']:
        """
        The compression algorithm used to compress data. Default to no compression.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs']):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Avro"]; Default: "Avro"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs:
    def __init__(__self__, *,
                 bzip2: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args']] = None,
                 deflate: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs']] = None,
                 snappy: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs']] = None,
                 xz: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXzArgs']] = None,
                 zstandard: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs']] = None):
        if bzip2 is not None:
            pulumi.set(__self__, "bzip2", bzip2)
        if deflate is not None:
            pulumi.set(__self__, "deflate", deflate)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)
        if snappy is not None:
            pulumi.set(__self__, "snappy", snappy)
        if xz is not None:
            pulumi.set(__self__, "xz", xz)
        if zstandard is not None:
            pulumi.set(__self__, "zstandard", zstandard)

    @property
    @pulumi.getter
    def bzip2(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args']]:
        return pulumi.get(self, "bzip2")

    @bzip2.setter
    def bzip2(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args']]):
        pulumi.set(self, "bzip2", value)

    @property
    @pulumi.getter
    def deflate(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs']]:
        return pulumi.get(self, "deflate")

    @deflate.setter
    def deflate(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs']]):
        pulumi.set(self, "deflate", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)

    @property
    @pulumi.getter
    def snappy(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs']]:
        return pulumi.get(self, "snappy")

    @snappy.setter
    def snappy(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs']]):
        pulumi.set(self, "snappy", value)

    @property
    @pulumi.getter
    def xz(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXzArgs']]:
        return pulumi.get(self, "xz")

    @xz.setter
    def xz(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXzArgs']]):
        pulumi.set(self, "xz", value)

    @property
    @pulumi.getter
    def zstandard(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs']]:
        return pulumi.get(self, "zstandard")

    @zstandard.setter
    def zstandard(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs']]):
        pulumi.set(self, "zstandard", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2Args:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["bzip2"]; Default: "bzip2"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["bzip2"]; Default: "bzip2"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflateArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None,
                 compression_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["Deflate"]; Default: "Deflate"
        :param pulumi.Input[int] compression_level: 0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Deflate"]; Default: "Deflate"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[pulumi.Input[int]]:
        """
        0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compression_level", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompressionArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["no compression"]; Default: "no compression"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["no compression"]; Default: "no compression"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappyArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["snappy"]; Default: "snappy"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["snappy"]; Default: "snappy"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXzArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None,
                 compression_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["xz"]; Default: "xz"
        :param pulumi.Input[int] compression_level: See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["xz"]; Default: "xz"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[pulumi.Input[int]]:
        """
        See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compression_level", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandardArgs:
    def __init__(__self__, *,
                 codec: Optional[pulumi.Input[str]] = None,
                 compression_level: Optional[pulumi.Input[int]] = None,
                 include_checksum: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] codec: must be one of ["zstandard"]; Default: "zstandard"
        :param pulumi.Input[int] compression_level: Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        :param pulumi.Input[bool] include_checksum: If true, include a checksum with each data block. Default: false
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if include_checksum is not None:
            pulumi.set(__self__, "include_checksum", include_checksum)

    @property
    @pulumi.getter
    def codec(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["zstandard"]; Default: "zstandard"
        """
        return pulumi.get(self, "codec")

    @codec.setter
    def codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "codec", value)

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[pulumi.Input[int]]:
        """
        Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        """
        return pulumi.get(self, "compression_level")

    @compression_level.setter
    def compression_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compression_level", value)

    @property
    @pulumi.getter(name="includeChecksum")
    def include_checksum(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, include a checksum with each data block. Default: false
        """
        return pulumi.get(self, "include_checksum")

    @include_checksum.setter
    def include_checksum(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_checksum", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesArgs:
    def __init__(__self__, *,
                 compression: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs']] = None,
                 flattening: Optional[pulumi.Input[str]] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs'] compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        :param pulumi.Input[str] flattening: Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        :param pulumi.Input[str] format_type: must be one of ["CSV"]; Default: "CSV"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs']]:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs']]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def flattening(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @flattening.setter
    def flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flattening", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["CSV"]; Default: "CSV"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs:
    def __init__(__self__, *,
                 gzip: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs']] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs']]:
        return pulumi.get(self, "gzip")

    @gzip.setter
    def gzip(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs']]):
        pulumi.set(self, "gzip", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzipArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompressionArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonArgs:
    def __init__(__self__, *,
                 compression: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']] = None,
                 flattening: Optional[pulumi.Input[str]] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs'] compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        :param pulumi.Input[str] flattening: Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        :param pulumi.Input[str] format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']]:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def flattening(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @flattening.setter
    def flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flattening", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs:
    def __init__(__self__, *,
                 gzip: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']]:
        return pulumi.get(self, "gzip")

    @gzip.setter
    def gzip(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']]):
        pulumi.set(self, "gzip", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationS3ConfigurationFormatParquetColumnarStorageArgs:
    def __init__(__self__, *,
                 block_size_mb: Optional[pulumi.Input[int]] = None,
                 compression_codec: Optional[pulumi.Input[str]] = None,
                 dictionary_encoding: Optional[pulumi.Input[bool]] = None,
                 dictionary_page_size_kb: Optional[pulumi.Input[int]] = None,
                 format_type: Optional[pulumi.Input[str]] = None,
                 max_padding_size_mb: Optional[pulumi.Input[int]] = None,
                 page_size_kb: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] block_size_mb: This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        :param pulumi.Input[str] compression_codec: The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        :param pulumi.Input[bool] dictionary_encoding: Default: true. Default: true
        :param pulumi.Input[int] dictionary_page_size_kb: There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        :param pulumi.Input[str] format_type: must be one of ["Parquet"]; Default: "Parquet"
        :param pulumi.Input[int] max_padding_size_mb: Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        :param pulumi.Input[int] page_size_kb: The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        if block_size_mb is not None:
            pulumi.set(__self__, "block_size_mb", block_size_mb)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if dictionary_encoding is not None:
            pulumi.set(__self__, "dictionary_encoding", dictionary_encoding)
        if dictionary_page_size_kb is not None:
            pulumi.set(__self__, "dictionary_page_size_kb", dictionary_page_size_kb)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)
        if max_padding_size_mb is not None:
            pulumi.set(__self__, "max_padding_size_mb", max_padding_size_mb)
        if page_size_kb is not None:
            pulumi.set(__self__, "page_size_kb", page_size_kb)

    @property
    @pulumi.getter(name="blockSizeMb")
    def block_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        """
        return pulumi.get(self, "block_size_mb")

    @block_size_mb.setter
    def block_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size_mb", value)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[str]]:
        """
        The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_codec", value)

    @property
    @pulumi.getter(name="dictionaryEncoding")
    def dictionary_encoding(self) -> Optional[pulumi.Input[bool]]:
        """
        Default: true. Default: true
        """
        return pulumi.get(self, "dictionary_encoding")

    @dictionary_encoding.setter
    def dictionary_encoding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dictionary_encoding", value)

    @property
    @pulumi.getter(name="dictionaryPageSizeKb")
    def dictionary_page_size_kb(self) -> Optional[pulumi.Input[int]]:
        """
        There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "dictionary_page_size_kb")

    @dictionary_page_size_kb.setter
    def dictionary_page_size_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dictionary_page_size_kb", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["Parquet"]; Default: "Parquet"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)

    @property
    @pulumi.getter(name="maxPaddingSizeMb")
    def max_padding_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        """
        return pulumi.get(self, "max_padding_size_mb")

    @max_padding_size_mb.setter
    def max_padding_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_padding_size_mb", value)

    @property
    @pulumi.getter(name="pageSizeKb")
    def page_size_kb(self) -> Optional[pulumi.Input[int]]:
        """
        The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "page_size_kb")

    @page_size_kb.setter
    def page_size_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size_kb", value)


@pulumi.input_type
class DestinationS3GlueConfigurationArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['DestinationS3GlueConfigurationFormatArgs'],
                 glue_database: pulumi.Input[str],
                 s3_bucket_name: pulumi.Input[str],
                 s3_bucket_path: pulumi.Input[str],
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 file_name_pattern: Optional[pulumi.Input[str]] = None,
                 glue_serialization_library: Optional[pulumi.Input[str]] = None,
                 s3_bucket_region: Optional[pulumi.Input[str]] = None,
                 s3_endpoint: Optional[pulumi.Input[str]] = None,
                 s3_path_format: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationS3GlueConfigurationFormatArgs'] format: Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        :param pulumi.Input[str] glue_database: Name of the glue database for creating the tables, leave blank if no integration
        :param pulumi.Input[str] s3_bucket_name: The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        :param pulumi.Input[str] s3_bucket_path: Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        :param pulumi.Input[str] access_key_id: The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        :param pulumi.Input[str] file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param pulumi.Input[str] glue_serialization_library: The library that your query engine will use for reading and writing data in your lake. must be one of ["org.openx.data.jsonserde.JsonSerDe", "org.apache.hive.hcatalog.data.JsonSerDe"]; Default: "org.openx.data.jsonserde.JsonSerDe"
        :param pulumi.Input[str] s3_bucket_region: The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        :param pulumi.Input[str] s3_endpoint: Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        :param pulumi.Input[str] s3_path_format: Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        :param pulumi.Input[str] secret_access_key: The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "glue_database", glue_database)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if glue_serialization_library is not None:
            pulumi.set(__self__, "glue_serialization_library", glue_serialization_library)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)
        if s3_endpoint is not None:
            pulumi.set(__self__, "s3_endpoint", s3_endpoint)
        if s3_path_format is not None:
            pulumi.set(__self__, "s3_path_format", s3_path_format)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['DestinationS3GlueConfigurationFormatArgs']:
        """
        Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['DestinationS3GlueConfigurationFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="glueDatabase")
    def glue_database(self) -> pulumi.Input[str]:
        """
        Name of the glue database for creating the tables, leave blank if no integration
        """
        return pulumi.get(self, "glue_database")

    @glue_database.setter
    def glue_database(self, value: pulumi.Input[str]):
        pulumi.set(self, "glue_database", value)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> pulumi.Input[str]:
        """
        Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        """
        return pulumi.get(self, "s3_bucket_path")

    @s3_bucket_path.setter
    def s3_bucket_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_path", value)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @file_name_pattern.setter
    def file_name_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_name_pattern", value)

    @property
    @pulumi.getter(name="glueSerializationLibrary")
    def glue_serialization_library(self) -> Optional[pulumi.Input[str]]:
        """
        The library that your query engine will use for reading and writing data in your lake. must be one of ["org.openx.data.jsonserde.JsonSerDe", "org.apache.hive.hcatalog.data.JsonSerDe"]; Default: "org.openx.data.jsonserde.JsonSerDe"
        """
        return pulumi.get(self, "glue_serialization_library")

    @glue_serialization_library.setter
    def glue_serialization_library(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "glue_serialization_library", value)

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")

    @s3_bucket_region.setter
    def s3_bucket_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_region", value)

    @property
    @pulumi.getter(name="s3Endpoint")
    def s3_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        """
        return pulumi.get(self, "s3_endpoint")

    @s3_endpoint.setter
    def s3_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_endpoint", value)

    @property
    @pulumi.getter(name="s3PathFormat")
    def s3_path_format(self) -> Optional[pulumi.Input[str]]:
        """
        Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        """
        return pulumi.get(self, "s3_path_format")

    @s3_path_format.setter
    def s3_path_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_path_format", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


@pulumi.input_type
class DestinationS3GlueConfigurationFormatArgs:
    def __init__(__self__, *,
                 json_lines_newline_delimited_json: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']] = None):
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @json_lines_newline_delimited_json.setter
    def json_lines_newline_delimited_json(self, value: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonArgs']]):
        pulumi.set(self, "json_lines_newline_delimited_json", value)


@pulumi.input_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonArgs:
    def __init__(__self__, *,
                 compression: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']] = None,
                 flattening: Optional[pulumi.Input[str]] = None,
                 format_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs'] compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        :param pulumi.Input[str] flattening: Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "Root level flattening"
        :param pulumi.Input[str] format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']]:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs']]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter
    def flattening(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "Root level flattening"
        """
        return pulumi.get(self, "flattening")

    @flattening.setter
    def flattening(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flattening", value)

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")

    @format_type.setter
    def format_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_type", value)


@pulumi.input_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs:
    def __init__(__self__, *,
                 gzip: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']] = None,
                 no_compression: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']]:
        return pulumi.get(self, "gzip")

    @gzip.setter
    def gzip(self, value: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs']]):
        pulumi.set(self, "gzip", value)

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']]:
        return pulumi.get(self, "no_compression")

    @no_compression.setter
    def no_compression(self, value: Optional[pulumi.Input['DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs']]):
        pulumi.set(self, "no_compression", value)


@pulumi.input_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzipArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompressionArgs:
    def __init__(__self__, *,
                 compression_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)


@pulumi.input_type
class DestinationSftpJsonConfigurationArgs:
    def __init__(__self__, *,
                 destination_path: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] destination_path: Path to the directory where json files will be written.
        :param pulumi.Input[str] host: Hostname of the SFTP server.
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[str] username: Username to use to access the SFTP server.
        :param pulumi.Input[int] port: Port of the SFTP server. Default: 22
        """
        pulumi.set(__self__, "destination_path", destination_path)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> pulumi.Input[str]:
        """
        Path to the directory where json files will be written.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_path", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the SFTP server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the SFTP server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the SFTP server. Default: 22
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class DestinationSnowflakeConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 role: pulumi.Input[str],
                 schema: pulumi.Input[str],
                 username: pulumi.Input[str],
                 warehouse: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsArgs']] = None,
                 disable_type_dedupe: Optional[pulumi.Input[bool]] = None,
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 raw_data_schema: Optional[pulumi.Input[str]] = None,
                 retention_period_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: Enter the name of the <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">database</a> you want to sync data into
        :param pulumi.Input[str] host: Enter your Snowflake account's <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier">locator</a> (in the format <account_locator>.<region>.<cloud>.snowflakecomputing.com)
        :param pulumi.Input[str] role: Enter the <a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#roles">role</a> that you want to use to access Snowflake
        :param pulumi.Input[str] schema: Enter the name of the default <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">schema</a>
        :param pulumi.Input[str] username: Enter the name of the user you want to use to access the database
        :param pulumi.Input[str] warehouse: Enter the name of the <a href="https://docs.snowflake.com/en/user-guide/warehouses-overview.html#overview-of-warehouses">warehouse</a> that you want to sync data into
        :param pulumi.Input[bool] disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param pulumi.Input[str] jdbc_url_params: Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
        :param pulumi.Input[str] raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param pulumi.Input[int] retention_period_days: The number of days of Snowflake Time Travel to enable on the tables. See <a href="https://docs.snowflake.com/en/user-guide/data-time-travel#data-retention-period">Snowflake's documentation</a> for more information. Setting a nonzero value will incur increased storage costs in your Snowflake instance. Default: 1
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "warehouse", warehouse)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Enter the name of the <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">database</a> you want to sync data into
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Enter your Snowflake account's <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier">locator</a> (in the format <account_locator>.<region>.<cloud>.snowflakecomputing.com)
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        Enter the <a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#roles">role</a> that you want to use to access Snowflake
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Enter the name of the default <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">schema</a>
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Enter the name of the user you want to use to access the database
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[str]:
        """
        Enter the name of the <a href="https://docs.snowflake.com/en/user-guide/warehouses-overview.html#overview-of-warehouses">warehouse</a> that you want to sync data into
        """
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[str]):
        pulumi.set(self, "warehouse", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @disable_type_dedupe.setter
    def disable_type_dedupe(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_type_dedupe", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @raw_data_schema.setter
    def raw_data_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_data_schema", value)

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days of Snowflake Time Travel to enable on the tables. See <a href="https://docs.snowflake.com/en/user-guide/data-time-travel#data-retention-period">Snowflake's documentation</a> for more information. Setting a nonzero value will incur increased storage costs in your Snowflake instance. Default: 1
        """
        return pulumi.get(self, "retention_period_days")

    @retention_period_days.setter
    def retention_period_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_period_days", value)


@pulumi.input_type
class DestinationSnowflakeConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 key_pair_authentication: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsKeyPairAuthenticationArgs']] = None,
                 o_auth20: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsOAuth20Args']] = None,
                 username_and_password: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsUsernameAndPasswordArgs']] = None):
        if key_pair_authentication is not None:
            pulumi.set(__self__, "key_pair_authentication", key_pair_authentication)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if username_and_password is not None:
            pulumi.set(__self__, "username_and_password", username_and_password)

    @property
    @pulumi.getter(name="keyPairAuthentication")
    def key_pair_authentication(self) -> Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsKeyPairAuthenticationArgs']]:
        return pulumi.get(self, "key_pair_authentication")

    @key_pair_authentication.setter
    def key_pair_authentication(self, value: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsKeyPairAuthenticationArgs']]):
        pulumi.set(self, "key_pair_authentication", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)

    @property
    @pulumi.getter(name="usernameAndPassword")
    def username_and_password(self) -> Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsUsernameAndPasswordArgs']]:
        return pulumi.get(self, "username_and_password")

    @username_and_password.setter
    def username_and_password(self, value: Optional[pulumi.Input['DestinationSnowflakeConfigurationCredentialsUsernameAndPasswordArgs']]):
        pulumi.set(self, "username_and_password", value)


@pulumi.input_type
class DestinationSnowflakeConfigurationCredentialsKeyPairAuthenticationArgs:
    def __init__(__self__, *,
                 private_key: pulumi.Input[str],
                 private_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_key: RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/destinations/snowflake">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] private_key_password: Passphrase for private key
        """
        pulumi.set(__self__, "private_key", private_key)
        if private_key_password is not None:
            pulumi.set(__self__, "private_key_password", private_key_password)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/destinations/snowflake">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyPassword")
    def private_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Passphrase for private key
        """
        return pulumi.get(self, "private_key_password")

    @private_key_password.setter
    def private_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_password", value)


@pulumi.input_type
class DestinationSnowflakeConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Enter you application's Access Token
        :param pulumi.Input[str] refresh_token: Enter your application's Refresh Token
        :param pulumi.Input[str] client_id: Enter your application's Client ID
        :param pulumi.Input[str] client_secret: Enter your application's Client secret
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Enter you application's Access Token
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Enter your application's Refresh Token
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Enter your application's Client ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Enter your application's Client secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class DestinationSnowflakeConfigurationCredentialsUsernameAndPasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Enter the password associated with the username.
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Enter the password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingArgs'],
                 omit_raw_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingArgs'] indexing: Snowflake can be used to store vector data and retrieve embeddings.
        :param pulumi.Input[bool] omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingArgs']:
        """
        Snowflake can be used to store vector data and retrieve embeddings.
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")

    @omit_raw_text.setter
    def omit_raw_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_raw_text", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 azure_open_ai: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs']] = None,
                 cohere: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs']] = None,
                 fake: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs']] = None,
                 open_ai_compatible: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs']] = None):
        """
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs'] azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs'] cohere: Use the Cohere API to embed text.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs'] open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs']]:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @azure_open_ai.setter
    def azure_open_ai(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs']]):
        pulumi.set(self, "azure_open_ai", value)

    @property
    @pulumi.getter
    def cohere(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs']]:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @cohere.setter
    def cohere(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs']]):
        pulumi.set(self, "cohere", value)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs']]:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")

    @open_ai_compatible.setter
    def open_ai_compatible(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs']]):
        pulumi.set(self, "open_ai_compatible", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs:
    def __init__(__self__, *,
                 api_base: pulumi.Input[str],
                 deployment: pulumi.Input[str],
                 openai_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> pulumi.Input[str]:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @api_base.setter
    def api_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_base", value)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs:
    def __init__(__self__, *,
                 cohere_key: pulumi.Input[str]):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cohere_key")

    @cohere_key.setter
    def cohere_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "cohere_key", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 dimensions: pulumi.Input[int],
                 api_key: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The base URL for your OpenAI-compatible service
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] api_key: Default: ""
        :param pulumi.Input[str] model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationIndexingArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingCredentialsArgs'],
                 database: pulumi.Input[str],
                 default_schema: pulumi.Input[str],
                 host: pulumi.Input[str],
                 role: pulumi.Input[str],
                 username: pulumi.Input[str],
                 warehouse: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database: Enter the name of the database that you want to sync data into
        :param pulumi.Input[str] default_schema: Enter the name of the default schema
        :param pulumi.Input[str] host: Enter the account name you want to use to access the database. This is usually the identifier before .snowflakecomputing.com
        :param pulumi.Input[str] role: Enter the role that you want to use to access Snowflake
        :param pulumi.Input[str] username: Enter the name of the user you want to use to access the database
        :param pulumi.Input[str] warehouse: Enter the name of the warehouse that you want to sync data into
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "default_schema", default_schema)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "warehouse", warehouse)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['DestinationSnowflakeCortexConfigurationIndexingCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Enter the name of the database that you want to sync data into
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="defaultSchema")
    def default_schema(self) -> pulumi.Input[str]:
        """
        Enter the name of the default schema
        """
        return pulumi.get(self, "default_schema")

    @default_schema.setter
    def default_schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_schema", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Enter the account name you want to use to access the database. This is usually the identifier before .snowflakecomputing.com
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        Enter the role that you want to use to access Snowflake
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Enter the name of the user you want to use to access the database
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[str]:
        """
        Enter the name of the warehouse that you want to sync data into
        """
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[str]):
        pulumi.set(self, "warehouse", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationIndexingCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Enter the password you want to use to access the database
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Enter the password you want to use to access the database
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 chunk_overlap: Optional[pulumi.Input[int]] = None,
                 field_name_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs']]]] = None,
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_splitter: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs']] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs']]] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs'] text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs']]]]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @field_name_mappings.setter
    def field_name_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs']]]]):
        pulumi.set(self, "field_name_mappings", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs']]:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")

    @text_splitter.setter
    def text_splitter(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs']]):
        pulumi.set(self, "text_splitter", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs:
    def __init__(__self__, *,
                 from_field: pulumi.Input[str],
                 to_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_field: The field name in the source
        :param pulumi.Input[str] to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> pulumi.Input[str]:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> pulumi.Input[str]:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")

    @to_field.setter
    def to_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "to_field", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs:
    def __init__(__self__, *,
                 by_markdown_header: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs']] = None,
                 by_programming_language: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs']] = None,
                 by_separator: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs']] = None):
        """
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs'] by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs'] by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs'] by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @by_markdown_header.setter
    def by_markdown_header(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]):
        pulumi.set(self, "by_markdown_header", value)

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @by_programming_language.setter
    def by_programming_language(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]):
        pulumi.set(self, "by_programming_language", value)

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs']]:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")

    @by_separator.setter
    def by_separator(self, value: Optional[pulumi.Input['DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs']]):
        pulumi.set(self, "by_separator", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs:
    def __init__(__self__, *,
                 split_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[pulumi.Input[int]]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")

    @split_level.setter
    def split_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_level", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[str]:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[str]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs:
    def __init__(__self__, *,
                 keep_separator: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @keep_separator.setter
    def keep_separator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_separator", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


@pulumi.input_type
class DestinationTeradataConfigurationArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 ssl_mode: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeArgs']] = None):
        """
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[str] schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "airbyte_td"
        :param pulumi.Input[bool] ssl: Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        :param pulumi.Input['DestinationTeradataConfigurationSslModeArgs'] ssl_mode: SSL connection modes. 
                <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
                <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
                <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
                <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
                 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
                 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
                See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "airbyte_td"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModeArgs']]:
        """
        SSL connection modes. 
         <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
         <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
         <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
         <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
          <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
          <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
         See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeArgs']]):
        pulumi.set(self, "ssl_mode", value)


@pulumi.input_type
class DestinationTeradataConfigurationSslModeArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeAllowArgs']] = None,
                 disable: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeDisableArgs']] = None,
                 prefer: Optional[pulumi.Input['DestinationTeradataConfigurationSslModePreferArgs']] = None,
                 require: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeRequireArgs']] = None,
                 verify_ca: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeVerifyCaArgs']] = None,
                 verify_full: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeVerifyFullArgs']] = None):
        """
        :param pulumi.Input['DestinationTeradataConfigurationSslModeAllowArgs'] allow: Allow SSL mode.
        :param pulumi.Input['DestinationTeradataConfigurationSslModeDisableArgs'] disable: Disable SSL.
        :param pulumi.Input['DestinationTeradataConfigurationSslModePreferArgs'] prefer: Prefer SSL mode.
        :param pulumi.Input['DestinationTeradataConfigurationSslModeRequireArgs'] require: Require SSL mode.
        :param pulumi.Input['DestinationTeradataConfigurationSslModeVerifyCaArgs'] verify_ca: Verify-ca SSL mode.
        :param pulumi.Input['DestinationTeradataConfigurationSslModeVerifyFullArgs'] verify_full: Verify-full SSL mode.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModeAllowArgs']]:
        """
        Allow SSL mode.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModeDisableArgs']]:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeDisableArgs']]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def prefer(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModePreferArgs']]:
        """
        Prefer SSL mode.
        """
        return pulumi.get(self, "prefer")

    @prefer.setter
    def prefer(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModePreferArgs']]):
        pulumi.set(self, "prefer", value)

    @property
    @pulumi.getter
    def require(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModeRequireArgs']]:
        """
        Require SSL mode.
        """
        return pulumi.get(self, "require")

    @require.setter
    def require(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeRequireArgs']]):
        pulumi.set(self, "require", value)

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModeVerifyCaArgs']]:
        """
        Verify-ca SSL mode.
        """
        return pulumi.get(self, "verify_ca")

    @verify_ca.setter
    def verify_ca(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeVerifyCaArgs']]):
        pulumi.set(self, "verify_ca", value)

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional[pulumi.Input['DestinationTeradataConfigurationSslModeVerifyFullArgs']]:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")

    @verify_full.setter
    def verify_full(self, value: Optional[pulumi.Input['DestinationTeradataConfigurationSslModeVerifyFullArgs']]):
        pulumi.set(self, "verify_full", value)


@pulumi.input_type
class DestinationTeradataConfigurationSslModeAllowArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationTeradataConfigurationSslModeDisableArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationTeradataConfigurationSslModePreferArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationTeradataConfigurationSslModeRequireArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationTeradataConfigurationSslModeVerifyCaArgs:
    def __init__(__self__, *,
                 ssl_ca_certificate: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ssl_ca_certificate: Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
                See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> pulumi.Input[str]:
        """
        Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
         See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_ca_certificate")

    @ssl_ca_certificate.setter
    def ssl_ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssl_ca_certificate", value)


@pulumi.input_type
class DestinationTeradataConfigurationSslModeVerifyFullArgs:
    def __init__(__self__, *,
                 ssl_ca_certificate: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ssl_ca_certificate: Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
                See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> pulumi.Input[str]:
        """
        Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
         See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_ca_certificate")

    @ssl_ca_certificate.setter
    def ssl_ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssl_ca_certificate", value)


@pulumi.input_type
class DestinationTypesenseConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 host: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Typesense API Key
        :param pulumi.Input[str] host: Hostname of the Typesense instance without protocol.
        :param pulumi.Input[int] batch_size: How many documents should be imported together. Default 1000
        :param pulumi.Input[str] path: Path of the Typesense instance. Default is none
        :param pulumi.Input[str] port: Port of the Typesense instance. Ex: 8108, 80, 443. Default is 443
        :param pulumi.Input[str] protocol: Protocol of the Typesense instance. Ex: http or https. Default is https
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "host", host)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Typesense API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the Typesense instance without protocol.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        How many documents should be imported together. Default 1000
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path of the Typesense instance. Default is none
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Port of the Typesense instance. Ex: 8108, 80, 443. Default is 443
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Protocol of the Typesense instance. Ex: http or https. Default is https
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class DestinationVectaraConfigurationArgs:
    def __init__(__self__, *,
                 corpus_name: pulumi.Input[str],
                 customer_id: pulumi.Input[str],
                 oauth2: pulumi.Input['DestinationVectaraConfigurationOauth2Args'],
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 parallelize: Optional[pulumi.Input[bool]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 title_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] corpus_name: The Name of Corpus to load data into
        :param pulumi.Input[str] customer_id: Your customer id as it is in the authenticaion url
        :param pulumi.Input['DestinationVectaraConfigurationOauth2Args'] oauth2: OAuth2.0 credentials used to authenticate admin actions (creating/deleting corpora)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[bool] parallelize: Parallelize indexing into Vectara with multiple threads. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be in the section of the document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input[str] title_field: A field that will be used to populate the `title` of each document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. Default: ""
        """
        pulumi.set(__self__, "corpus_name", corpus_name)
        pulumi.set(__self__, "customer_id", customer_id)
        pulumi.set(__self__, "oauth2", oauth2)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if parallelize is not None:
            pulumi.set(__self__, "parallelize", parallelize)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if title_field is not None:
            pulumi.set(__self__, "title_field", title_field)

    @property
    @pulumi.getter(name="corpusName")
    def corpus_name(self) -> pulumi.Input[str]:
        """
        The Name of Corpus to load data into
        """
        return pulumi.get(self, "corpus_name")

    @corpus_name.setter
    def corpus_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "corpus_name", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> pulumi.Input[str]:
        """
        Your customer id as it is in the authenticaion url
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "customer_id", value)

    @property
    @pulumi.getter
    def oauth2(self) -> pulumi.Input['DestinationVectaraConfigurationOauth2Args']:
        """
        OAuth2.0 credentials used to authenticate admin actions (creating/deleting corpora)
        """
        return pulumi.get(self, "oauth2")

    @oauth2.setter
    def oauth2(self, value: pulumi.Input['DestinationVectaraConfigurationOauth2Args']):
        pulumi.set(self, "oauth2", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter
    def parallelize(self) -> Optional[pulumi.Input[bool]]:
        """
        Parallelize indexing into Vectara with multiple threads. Default: false
        """
        return pulumi.get(self, "parallelize")

    @parallelize.setter
    def parallelize(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parallelize", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be in the section of the document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="titleField")
    def title_field(self) -> Optional[pulumi.Input[str]]:
        """
        A field that will be used to populate the `title` of each document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. Default: ""
        """
        return pulumi.get(self, "title_field")

    @title_field.setter
    def title_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title_field", value)


@pulumi.input_type
class DestinationVectaraConfigurationOauth2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: OAuth2.0 client id
        :param pulumi.Input[str] client_secret: OAuth2.0 client secret
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        OAuth2.0 client id
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        OAuth2.0 client secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class DestinationWeaviateConfigurationArgs:
    def __init__(__self__, *,
                 embedding: pulumi.Input['DestinationWeaviateConfigurationEmbeddingArgs'],
                 indexing: pulumi.Input['DestinationWeaviateConfigurationIndexingArgs'],
                 processing: pulumi.Input['DestinationWeaviateConfigurationProcessingArgs'],
                 omit_raw_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingArgs'] embedding: Embedding configuration
        :param pulumi.Input['DestinationWeaviateConfigurationIndexingArgs'] indexing: Indexing configuration
        :param pulumi.Input[bool] omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> pulumi.Input['DestinationWeaviateConfigurationEmbeddingArgs']:
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @embedding.setter
    def embedding(self, value: pulumi.Input['DestinationWeaviateConfigurationEmbeddingArgs']):
        pulumi.set(self, "embedding", value)

    @property
    @pulumi.getter
    def indexing(self) -> pulumi.Input['DestinationWeaviateConfigurationIndexingArgs']:
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @indexing.setter
    def indexing(self, value: pulumi.Input['DestinationWeaviateConfigurationIndexingArgs']):
        pulumi.set(self, "indexing", value)

    @property
    @pulumi.getter
    def processing(self) -> pulumi.Input['DestinationWeaviateConfigurationProcessingArgs']:
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: pulumi.Input['DestinationWeaviateConfigurationProcessingArgs']):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")

    @omit_raw_text.setter
    def omit_raw_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_raw_text", value)


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingArgs:
    def __init__(__self__, *,
                 azure_open_ai: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs']] = None,
                 cohere: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingCohereArgs']] = None,
                 fake: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingFakeArgs']] = None,
                 from_field: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingFromFieldArgs']] = None,
                 no_external_embedding: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs']] = None,
                 open_ai: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiArgs']] = None,
                 open_ai_compatible: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs']] = None):
        """
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs'] azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingCohereArgs'] cohere: Use the Cohere API to embed text.
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingFakeArgs'] fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingFromFieldArgs'] from_field: Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs'] no_external_embedding: Do not calculate and pass embeddings to Weaviate. Suitable for clusters with configured vectorizers to calculate embeddings within Weaviate or for classes that should only support regular text search.
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiArgs'] open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs'] open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if from_field is not None:
            pulumi.set(__self__, "from_field", from_field)
        if no_external_embedding is not None:
            pulumi.set(__self__, "no_external_embedding", no_external_embedding)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs']]:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @azure_open_ai.setter
    def azure_open_ai(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs']]):
        pulumi.set(self, "azure_open_ai", value)

    @property
    @pulumi.getter
    def cohere(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingCohereArgs']]:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @cohere.setter
    def cohere(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingCohereArgs']]):
        pulumi.set(self, "cohere", value)

    @property
    @pulumi.getter
    def fake(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingFakeArgs']]:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @fake.setter
    def fake(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingFakeArgs']]):
        pulumi.set(self, "fake", value)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingFromFieldArgs']]:
        """
        Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingFromFieldArgs']]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="noExternalEmbedding")
    def no_external_embedding(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs']]:
        """
        Do not calculate and pass embeddings to Weaviate. Suitable for clusters with configured vectorizers to calculate embeddings within Weaviate or for classes that should only support regular text search.
        """
        return pulumi.get(self, "no_external_embedding")

    @no_external_embedding.setter
    def no_external_embedding(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs']]):
        pulumi.set(self, "no_external_embedding", value)

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiArgs']]:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @open_ai.setter
    def open_ai(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiArgs']]):
        pulumi.set(self, "open_ai", value)

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs']]:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")

    @open_ai_compatible.setter
    def open_ai_compatible(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs']]):
        pulumi.set(self, "open_ai_compatible", value)


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs:
    def __init__(__self__, *,
                 api_base: pulumi.Input[str],
                 deployment: pulumi.Input[str],
                 openai_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param pulumi.Input[str] openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> pulumi.Input[str]:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @api_base.setter
    def api_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_base", value)

    @property
    @pulumi.getter
    def deployment(self) -> pulumi.Input[str]:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @deployment.setter
    def deployment(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment", value)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingCohereArgs:
    def __init__(__self__, *,
                 cohere_key: pulumi.Input[str]):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cohere_key")

    @cohere_key.setter
    def cohere_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "cohere_key", value)


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingFakeArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingFromFieldArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[int],
                 field_name: pulumi.Input[str]):
        """
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] field_name: Name of the field in the record that contains the embedding
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "field_name", field_name)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        """
        Name of the field in the record that contains the embedding
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingOpenAiArgs:
    def __init__(__self__, *,
                 openai_key: pulumi.Input[str]):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "openai_key")

    @openai_key.setter
    def openai_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "openai_key", value)


@pulumi.input_type
class DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 dimensions: pulumi.Input[int],
                 api_key: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The base URL for your OpenAI-compatible service
        :param pulumi.Input[int] dimensions: The number of dimensions the embedding model is generating
        :param pulumi.Input[str] api_key: Default: ""
        :param pulumi.Input[str] model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[int]:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[int]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)


@pulumi.input_type
class DestinationWeaviateConfigurationIndexingArgs:
    def __init__(__self__, *,
                 auth: pulumi.Input['DestinationWeaviateConfigurationIndexingAuthArgs'],
                 host: pulumi.Input[str],
                 additional_headers: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs']]]] = None,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 default_vectorizer: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 text_field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DestinationWeaviateConfigurationIndexingAuthArgs'] auth: Authentication method
        :param pulumi.Input[str] host: The public endpoint of the Weaviate cluster.
        :param pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs']]] additional_headers: Additional HTTP headers to send with every request.
        :param pulumi.Input[int] batch_size: The number of records to send to Weaviate in each batch. Default: 128
        :param pulumi.Input[str] default_vectorizer: The vectorizer to use if new classes need to be created. must be one of ["none", "text2vec-cohere", "text2vec-huggingface", "text2vec-openai", "text2vec-palm", "text2vec-contextionary", "text2vec-transformers", "text2vec-gpt4all"]; Default: "none"
        :param pulumi.Input[str] tenant_id: The tenant ID to use for multi tenancy. Default: ""
        :param pulumi.Input[str] text_field: The field in the object that contains the embedded text. Default: "text"
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "host", host)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if default_vectorizer is not None:
            pulumi.set(__self__, "default_vectorizer", default_vectorizer)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter
    def auth(self) -> pulumi.Input['DestinationWeaviateConfigurationIndexingAuthArgs']:
        """
        Authentication method
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: pulumi.Input['DestinationWeaviateConfigurationIndexingAuthArgs']):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The public endpoint of the Weaviate cluster.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs']]]]:
        """
        Additional HTTP headers to send with every request.
        """
        return pulumi.get(self, "additional_headers")

    @additional_headers.setter
    def additional_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs']]]]):
        pulumi.set(self, "additional_headers", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of records to send to Weaviate in each batch. Default: 128
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="defaultVectorizer")
    def default_vectorizer(self) -> Optional[pulumi.Input[str]]:
        """
        The vectorizer to use if new classes need to be created. must be one of ["none", "text2vec-cohere", "text2vec-huggingface", "text2vec-openai", "text2vec-palm", "text2vec-contextionary", "text2vec-transformers", "text2vec-gpt4all"]; Default: "none"
        """
        return pulumi.get(self, "default_vectorizer")

    @default_vectorizer.setter
    def default_vectorizer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_vectorizer", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The tenant ID to use for multi tenancy. Default: ""
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[pulumi.Input[str]]:
        """
        The field in the object that contains the embedded text. Default: "text"
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text_field", value)


@pulumi.input_type
class DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs:
    def __init__(__self__, *,
                 header_key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "header_key", header_key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerKey")
    def header_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "header_key")

    @header_key.setter
    def header_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "header_key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DestinationWeaviateConfigurationIndexingAuthArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthApiTokenArgs']] = None,
                 no_authentication: Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs']] = None,
                 username_password: Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs']] = None):
        """
        :param pulumi.Input['DestinationWeaviateConfigurationIndexingAuthApiTokenArgs'] api_token: Authenticate using an API token (suitable for Weaviate Cloud)
        :param pulumi.Input['DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs'] no_authentication: Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        :param pulumi.Input['DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs'] username_password: Authenticate using username and password (suitable for self-managed Weaviate clusters)
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if no_authentication is not None:
            pulumi.set(__self__, "no_authentication", no_authentication)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthApiTokenArgs']]:
        """
        Authenticate using an API token (suitable for Weaviate Cloud)
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="noAuthentication")
    def no_authentication(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs']]:
        """
        Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        """
        return pulumi.get(self, "no_authentication")

    @no_authentication.setter
    def no_authentication(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs']]):
        pulumi.set(self, "no_authentication", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs']]:
        """
        Authenticate using username and password (suitable for self-managed Weaviate clusters)
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)


@pulumi.input_type
class DestinationWeaviateConfigurationIndexingAuthApiTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: API Token for the Weaviate instance
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        API Token for the Weaviate instance
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Password for the Weaviate cluster
        :param pulumi.Input[str] username: Username for the Weaviate cluster
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the Weaviate cluster
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the Weaviate cluster
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DestinationWeaviateConfigurationProcessingArgs:
    def __init__(__self__, *,
                 chunk_size: pulumi.Input[int],
                 chunk_overlap: Optional[pulumi.Input[int]] = None,
                 field_name_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationProcessingFieldNameMappingArgs']]]] = None,
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 text_splitter: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterArgs']] = None):
        """
        :param pulumi.Input[int] chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param pulumi.Input[int] chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationProcessingFieldNameMappingArgs']]] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterArgs'] text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> pulumi.Input[int]:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[pulumi.Input[int]]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @chunk_overlap.setter
    def chunk_overlap(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_overlap", value)

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationProcessingFieldNameMappingArgs']]]]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @field_name_mappings.setter
    def field_name_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationWeaviateConfigurationProcessingFieldNameMappingArgs']]]]):
        pulumi.set(self, "field_name_mappings", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @text_fields.setter
    def text_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "text_fields", value)

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterArgs']]:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")

    @text_splitter.setter
    def text_splitter(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterArgs']]):
        pulumi.set(self, "text_splitter", value)


@pulumi.input_type
class DestinationWeaviateConfigurationProcessingFieldNameMappingArgs:
    def __init__(__self__, *,
                 from_field: pulumi.Input[str],
                 to_field: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_field: The field name in the source
        :param pulumi.Input[str] to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> pulumi.Input[str]:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @from_field.setter
    def from_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_field", value)

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> pulumi.Input[str]:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")

    @to_field.setter
    def to_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "to_field", value)


@pulumi.input_type
class DestinationWeaviateConfigurationProcessingTextSplitterArgs:
    def __init__(__self__, *,
                 by_markdown_header: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs']] = None,
                 by_programming_language: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs']] = None,
                 by_separator: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs']] = None):
        """
        :param pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs'] by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs'] by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs'] by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @by_markdown_header.setter
    def by_markdown_header(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs']]):
        pulumi.set(self, "by_markdown_header", value)

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @by_programming_language.setter
    def by_programming_language(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs']]):
        pulumi.set(self, "by_programming_language", value)

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs']]:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")

    @by_separator.setter
    def by_separator(self, value: Optional[pulumi.Input['DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs']]):
        pulumi.set(self, "by_separator", value)


@pulumi.input_type
class DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs:
    def __init__(__self__, *,
                 split_level: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[pulumi.Input[int]]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")

    @split_level.setter
    def split_level(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_level", value)


@pulumi.input_type
class DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs:
    def __init__(__self__, *,
                 language: pulumi.Input[str]):
        """
        :param pulumi.Input[str] language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> pulumi.Input[str]:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input[str]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs:
    def __init__(__self__, *,
                 keep_separator: Optional[pulumi.Input[bool]] = None,
                 separators: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @keep_separator.setter
    def keep_separator(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_separator", value)

    @property
    @pulumi.getter
    def separators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")

    @separators.setter
    def separators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "separators", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[bool]] = None,
                 ssl_mode: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[int] port: Port of the database. Default: 5432
        :param pulumi.Input[str] schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        :param pulumi.Input[bool] ssl: Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModeArgs'] ssl_mode: SSL connection modes. 
                <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
                <b>allow</b> - Chose this mode to enable encryption only when required by the source database
                <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
                <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
                 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
                 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
                See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        :param pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database. Default: 5432
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeArgs']]:
        """
        SSL connection modes. 
         <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
         <b>allow</b> - Chose this mode to enable encryption only when required by the source database
         <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
         <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
          <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
          <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
         See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeArgs']]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModeArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeAllowArgs']] = None,
                 disable: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeDisableArgs']] = None,
                 prefer: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModePreferArgs']] = None,
                 require: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeRequireArgs']] = None,
                 verify_ca: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyCaArgs']] = None,
                 verify_full: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyFullArgs']] = None):
        """
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModeAllowArgs'] allow: Allow SSL mode.
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModeDisableArgs'] disable: Disable SSL.
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModePreferArgs'] prefer: Prefer SSL mode.
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModeRequireArgs'] require: Require SSL mode.
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyCaArgs'] verify_ca: Verify-ca SSL mode.
        :param pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyFullArgs'] verify_full: Verify-full SSL mode.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeAllowArgs']]:
        """
        Allow SSL mode.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeDisableArgs']]:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeDisableArgs']]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def prefer(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModePreferArgs']]:
        """
        Prefer SSL mode.
        """
        return pulumi.get(self, "prefer")

    @prefer.setter
    def prefer(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModePreferArgs']]):
        pulumi.set(self, "prefer", value)

    @property
    @pulumi.getter
    def require(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeRequireArgs']]:
        """
        Require SSL mode.
        """
        return pulumi.get(self, "require")

    @require.setter
    def require(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeRequireArgs']]):
        pulumi.set(self, "require", value)

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyCaArgs']]:
        """
        Verify-ca SSL mode.
        """
        return pulumi.get(self, "verify_ca")

    @verify_ca.setter
    def verify_ca(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyCaArgs']]):
        pulumi.set(self, "verify_ca", value)

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyFullArgs']]:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")

    @verify_full.setter
    def verify_full(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationSslModeVerifyFullArgs']]):
        pulumi.set(self, "verify_full", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModeAllowArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModeDisableArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModePreferArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModeRequireArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModeVerifyCaArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationSslModeVerifyFullArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_certificate: pulumi.Input[str],
                 client_key: pulumi.Input[str],
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_certificate: Client certificate
        :param pulumi.Input[str] client_key: Client key
        :param pulumi.Input[str] client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> pulumi.Input[str]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> pulumi.Input[str]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class DestinationYellowbrickConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceAhaConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key
        :param pulumi.Input[str] url: URL
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SourceAircallConfigurationArgs:
    def __init__(__self__, *,
                 api_id: pulumi.Input[str],
                 api_token: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_id: App ID found at settings https://dashboard.aircall.io/integrations/api-keys
        :param pulumi.Input[str] api_token: App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
        :param pulumi.Input[str] start_date: Date time filter for incremental filter, Specify which date to extract from.
        """
        pulumi.set(__self__, "api_id", api_id)
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiId")
    def api_id(self) -> pulumi.Input[str]:
        """
        App ID found at settings https://dashboard.aircall.io/integrations/api-keys
        """
        return pulumi.get(self, "api_id")

    @api_id.setter
    def api_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_id", value)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Date time filter for incremental filter, Specify which date to extract from.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceAirtableConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceAirtableConfigurationCredentialsArgs']] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceAirtableConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceAirtableConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceAirtableConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth20: Optional[pulumi.Input['SourceAirtableConfigurationCredentialsOAuth20Args']] = None,
                 personal_access_token: Optional[pulumi.Input['SourceAirtableConfigurationCredentialsPersonalAccessTokenArgs']] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceAirtableConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceAirtableConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional[pulumi.Input['SourceAirtableConfigurationCredentialsPersonalAccessTokenArgs']]:
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: Optional[pulumi.Input['SourceAirtableConfigurationCredentialsPersonalAccessTokenArgs']]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class SourceAirtableConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None,
                 token_expiry_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The client ID of the Airtable developer application.
        :param pulumi.Input[str] client_secret: The client secret the Airtable developer application.
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access token.
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if token_expiry_date is not None:
            pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID of the Airtable developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret the Airtable developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The key to refresh the expired access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")

    @token_expiry_date.setter
    def token_expiry_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_expiry_date", value)


@pulumi.input_type
class SourceAirtableConfigurationCredentialsPersonalAccessTokenArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceAmazonAdsConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 look_back_window: Optional[pulumi.Input[int]] = None,
                 marketplace_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 report_record_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 state_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] client_id: The client ID of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        :param pulumi.Input[str] client_secret: The client secret of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        :param pulumi.Input[str] refresh_token: Amazon Ads refresh token. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens">docs</a> for more information on how to obtain this token.
        :param pulumi.Input[int] look_back_window: The amount of days to go back in time to get the updated data from Amazon Ads. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] marketplace_ids: Marketplace IDs you want to fetch data for. Note: If Profile IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] profiles: Profile IDs you want to fetch data for. The Amazon Ads source connector supports only profiles with seller and vendor type, profiles with agency type will be ignored. See <a href="https://advertising.amazon.com/API/docs/en-us/concepts/authorization/profiles">docs</a> for more details. Note: If Marketplace IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        :param pulumi.Input[str] region: Region to pull data from (EU/NA/FE). See <a href="https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints">docs</a> for more details. must be one of ["NA", "EU", "FE"]; Default: "NA"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] report_record_types: Optional configuration which accepts an array of string of record types. Leave blank for default behaviour to pull all report types. Use this config option only if you want to pull specific report type(s). See <a href="https://advertising.amazon.com/API/docs/en-us/reporting/v2/report-types">docs</a> for more details
        :param pulumi.Input[str] start_date: The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
        :param pulumi.Input[Sequence[pulumi.Input[str]]] state_filters: Reflects the state of the Display, Product, and Brand Campaign streams as enabled, paused, or archived. If you do not populate this field, it will be ignored completely.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if look_back_window is not None:
            pulumi.set(__self__, "look_back_window", look_back_window)
        if marketplace_ids is not None:
            pulumi.set(__self__, "marketplace_ids", marketplace_ids)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if report_record_types is not None:
            pulumi.set(__self__, "report_record_types", report_record_types)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if state_filters is not None:
            pulumi.set(__self__, "state_filters", state_filters)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Amazon Ads refresh token. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens">docs</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="lookBackWindow")
    def look_back_window(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of days to go back in time to get the updated data from Amazon Ads. Default: 3
        """
        return pulumi.get(self, "look_back_window")

    @look_back_window.setter
    def look_back_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "look_back_window", value)

    @property
    @pulumi.getter(name="marketplaceIds")
    def marketplace_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Marketplace IDs you want to fetch data for. Note: If Profile IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        """
        return pulumi.get(self, "marketplace_ids")

    @marketplace_ids.setter
    def marketplace_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "marketplace_ids", value)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Profile IDs you want to fetch data for. The Amazon Ads source connector supports only profiles with seller and vendor type, profiles with agency type will be ignored. See <a href="https://advertising.amazon.com/API/docs/en-us/concepts/authorization/profiles">docs</a> for more details. Note: If Marketplace IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        """
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region to pull data from (EU/NA/FE). See <a href="https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints">docs</a> for more details. must be one of ["NA", "EU", "FE"]; Default: "NA"
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="reportRecordTypes")
    def report_record_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional configuration which accepts an array of string of record types. Leave blank for default behaviour to pull all report types. Use this config option only if you want to pull specific report type(s). See <a href="https://advertising.amazon.com/API/docs/en-us/reporting/v2/report-types">docs</a> for more details
        """
        return pulumi.get(self, "report_record_types")

    @report_record_types.setter
    def report_record_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "report_record_types", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="stateFilters")
    def state_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Reflects the state of the Display, Product, and Brand Campaign streams as enabled, paused, or archived. If you do not populate this field, it will be ignored completely.
        """
        return pulumi.get(self, "state_filters")

    @state_filters.setter
    def state_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "state_filters", value)


@pulumi.input_type
class SourceAmazonSellerPartnerConfigurationArgs:
    def __init__(__self__, *,
                 lwa_app_id: pulumi.Input[str],
                 lwa_client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 account_type: Optional[pulumi.Input[str]] = None,
                 aws_environment: Optional[pulumi.Input[str]] = None,
                 period_in_days: Optional[pulumi.Input[int]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 replication_end_date: Optional[pulumi.Input[str]] = None,
                 replication_start_date: Optional[pulumi.Input[str]] = None,
                 report_options_lists: Optional[pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListArgs']]]] = None):
        """
        :param pulumi.Input[str] lwa_app_id: Your Login with Amazon Client ID.
        :param pulumi.Input[str] lwa_client_secret: Your Login with Amazon Client Secret.
        :param pulumi.Input[str] refresh_token: The Refresh Token obtained via OAuth flow authorization.
        :param pulumi.Input[str] account_type: Type of the Account you're going to authorize the Airbyte application by. must be one of ["Seller", "Vendor"]; Default: "Seller"
        :param pulumi.Input[str] aws_environment: Select the AWS Environment. must be one of ["PRODUCTION", "SANDBOX"]; Default: "PRODUCTION"
        :param pulumi.Input[int] period_in_days: For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day. Default: 90
        :param pulumi.Input[str] region: Select the AWS Region. must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]; Default: "US"
        :param pulumi.Input[str] replication_end_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        :param pulumi.Input[str] replication_start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided, the date 2 years ago from today will be used.
        :param pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListArgs']]] report_options_lists: Additional information passed to reports. This varies by report type.
        """
        pulumi.set(__self__, "lwa_app_id", lwa_app_id)
        pulumi.set(__self__, "lwa_client_secret", lwa_client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if account_type is not None:
            pulumi.set(__self__, "account_type", account_type)
        if aws_environment is not None:
            pulumi.set(__self__, "aws_environment", aws_environment)
        if period_in_days is not None:
            pulumi.set(__self__, "period_in_days", period_in_days)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if replication_end_date is not None:
            pulumi.set(__self__, "replication_end_date", replication_end_date)
        if replication_start_date is not None:
            pulumi.set(__self__, "replication_start_date", replication_start_date)
        if report_options_lists is not None:
            pulumi.set(__self__, "report_options_lists", report_options_lists)

    @property
    @pulumi.getter(name="lwaAppId")
    def lwa_app_id(self) -> pulumi.Input[str]:
        """
        Your Login with Amazon Client ID.
        """
        return pulumi.get(self, "lwa_app_id")

    @lwa_app_id.setter
    def lwa_app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lwa_app_id", value)

    @property
    @pulumi.getter(name="lwaClientSecret")
    def lwa_client_secret(self) -> pulumi.Input[str]:
        """
        Your Login with Amazon Client Secret.
        """
        return pulumi.get(self, "lwa_client_secret")

    @lwa_client_secret.setter
    def lwa_client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "lwa_client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The Refresh Token obtained via OAuth flow authorization.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="accountType")
    def account_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the Account you're going to authorize the Airbyte application by. must be one of ["Seller", "Vendor"]; Default: "Seller"
        """
        return pulumi.get(self, "account_type")

    @account_type.setter
    def account_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_type", value)

    @property
    @pulumi.getter(name="awsEnvironment")
    def aws_environment(self) -> Optional[pulumi.Input[str]]:
        """
        Select the AWS Environment. must be one of ["PRODUCTION", "SANDBOX"]; Default: "PRODUCTION"
        """
        return pulumi.get(self, "aws_environment")

    @aws_environment.setter
    def aws_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_environment", value)

    @property
    @pulumi.getter(name="periodInDays")
    def period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day. Default: 90
        """
        return pulumi.get(self, "period_in_days")

    @period_in_days.setter
    def period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_in_days", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Select the AWS Region. must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]; Default: "US"
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="replicationEndDate")
    def replication_end_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "replication_end_date")

    @replication_end_date.setter
    def replication_end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_end_date", value)

    @property
    @pulumi.getter(name="replicationStartDate")
    def replication_start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided, the date 2 years ago from today will be used.
        """
        return pulumi.get(self, "replication_start_date")

    @replication_start_date.setter
    def replication_start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_start_date", value)

    @property
    @pulumi.getter(name="reportOptionsLists")
    def report_options_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListArgs']]]]:
        """
        Additional information passed to reports. This varies by report type.
        """
        return pulumi.get(self, "report_options_lists")

    @report_options_lists.setter
    def report_options_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListArgs']]]]):
        pulumi.set(self, "report_options_lists", value)


@pulumi.input_type
class SourceAmazonSellerPartnerConfigurationReportOptionsListArgs:
    def __init__(__self__, *,
                 options_lists: pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs']]],
                 stream_name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs']]] options_lists: List of options
        :param pulumi.Input[str] stream_name: must be one of ["GET_AFN_INVENTORY_DATA", "GET_AFN_INVENTORY_DATA_BY_COUNTRY", "GET_AMAZON_FULFILLED_SHIPMENTS_DATA_GENERAL", "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_RETURNS_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_PROMOTION_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_REPLACEMENT_DATA", "GET_FBA_FULFILLMENT_REMOVAL_ORDER_DETAIL_DATA", "GET_FBA_FULFILLMENT_REMOVAL_SHIPMENT_DETAIL_DATA", "GET_FBA_INVENTORY_PLANNING_DATA", "GET_FBA_MYI_UNSUPPRESSED_INVENTORY_DATA", "GET_FBA_REIMBURSEMENTS_DATA", "GET_FBA_SNS_FORECAST_DATA", "GET_FBA_SNS_PERFORMANCE_DATA", "GET_FBA_STORAGE_FEE_CHARGES_DATA", "GET_FLAT_FILE_ACTIONABLE_ORDER_DATA_SHIPPING", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_LAST_UPDATE_GENERAL", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_FLAT_FILE_ARCHIVED_ORDERS_DATA_BY_ORDER_DATE", "GET_FLAT_FILE_OPEN_LISTINGS_DATA", "GET_FLAT_FILE_RETURNS_DATA_BY_RETURN_DATE", "GET_LEDGER_DETAIL_VIEW_DATA", "GET_LEDGER_SUMMARY_VIEW_DATA", "GET_MERCHANT_CANCELLED_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_ALL_DATA", "GET_MERCHANT_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_DATA_BACK_COMPAT", "GET_MERCHANT_LISTINGS_INACTIVE_DATA", "GET_MERCHANTS_LISTINGS_FYP_REPORT", "GET_ORDER_REPORT_DATA_SHIPPING", "GET_RESTOCK_INVENTORY_RECOMMENDATIONS_REPORT", "GET_SELLER_FEEDBACK_DATA", "GET_STRANDED_INVENTORY_UI_DATA", "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE", "GET_XML_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_XML_BROWSE_TREE_DATA"]
        """
        pulumi.set(__self__, "options_lists", options_lists)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter(name="optionsLists")
    def options_lists(self) -> pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs']]]:
        """
        List of options
        """
        return pulumi.get(self, "options_lists")

    @options_lists.setter
    def options_lists(self, value: pulumi.Input[Sequence[pulumi.Input['SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs']]]):
        pulumi.set(self, "options_lists", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        must be one of ["GET_AFN_INVENTORY_DATA", "GET_AFN_INVENTORY_DATA_BY_COUNTRY", "GET_AMAZON_FULFILLED_SHIPMENTS_DATA_GENERAL", "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_RETURNS_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_PROMOTION_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_REPLACEMENT_DATA", "GET_FBA_FULFILLMENT_REMOVAL_ORDER_DETAIL_DATA", "GET_FBA_FULFILLMENT_REMOVAL_SHIPMENT_DETAIL_DATA", "GET_FBA_INVENTORY_PLANNING_DATA", "GET_FBA_MYI_UNSUPPRESSED_INVENTORY_DATA", "GET_FBA_REIMBURSEMENTS_DATA", "GET_FBA_SNS_FORECAST_DATA", "GET_FBA_SNS_PERFORMANCE_DATA", "GET_FBA_STORAGE_FEE_CHARGES_DATA", "GET_FLAT_FILE_ACTIONABLE_ORDER_DATA_SHIPPING", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_LAST_UPDATE_GENERAL", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_FLAT_FILE_ARCHIVED_ORDERS_DATA_BY_ORDER_DATE", "GET_FLAT_FILE_OPEN_LISTINGS_DATA", "GET_FLAT_FILE_RETURNS_DATA_BY_RETURN_DATE", "GET_LEDGER_DETAIL_VIEW_DATA", "GET_LEDGER_SUMMARY_VIEW_DATA", "GET_MERCHANT_CANCELLED_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_ALL_DATA", "GET_MERCHANT_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_DATA_BACK_COMPAT", "GET_MERCHANT_LISTINGS_INACTIVE_DATA", "GET_MERCHANTS_LISTINGS_FYP_REPORT", "GET_ORDER_REPORT_DATA_SHIPPING", "GET_RESTOCK_INVENTORY_RECOMMENDATIONS_REPORT", "GET_SELLER_FEEDBACK_DATA", "GET_STRANDED_INVENTORY_UI_DATA", "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE", "GET_XML_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_XML_BROWSE_TREE_DATA"]
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)


@pulumi.input_type
class SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs:
    def __init__(__self__, *,
                 option_name: pulumi.Input[str],
                 option_value: pulumi.Input[str]):
        pulumi.set(__self__, "option_name", option_name)
        pulumi.set(__self__, "option_value", option_value)

    @property
    @pulumi.getter(name="optionName")
    def option_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "option_name")

    @option_name.setter
    def option_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "option_name", value)

    @property
    @pulumi.getter(name="optionValue")
    def option_value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "option_value")

    @option_value.setter
    def option_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "option_value", value)


@pulumi.input_type
class SourceAmazonSqsConfigurationArgs:
    def __init__(__self__, *,
                 queue_url: pulumi.Input[str],
                 region: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 attributes_to_return: Optional[pulumi.Input[str]] = None,
                 delete_messages: Optional[pulumi.Input[bool]] = None,
                 max_batch_size: Optional[pulumi.Input[int]] = None,
                 max_wait_time: Optional[pulumi.Input[int]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 visibility_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] queue_url: URL of the SQS Queue
        :param pulumi.Input[str] region: AWS Region of the SQS Queue. must be one of ["af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
        :param pulumi.Input[str] access_key: The Access Key ID of the AWS IAM Role to use for pulling messages
        :param pulumi.Input[str] attributes_to_return: Comma separated list of Mesage Attribute names to return
        :param pulumi.Input[bool] delete_messages: If Enabled, messages will be deleted from the SQS Queue after being read. If Disabled, messages are left in the queue and can be read more than once. WARNING: Enabling this option can result in data loss in cases of failure, use with caution, see documentation for more detail. . Default: false
        :param pulumi.Input[int] max_batch_size: Max amount of messages to get in one batch (10 max)
        :param pulumi.Input[int] max_wait_time: Max amount of time in seconds to wait for messages in a single poll (20 max)
        :param pulumi.Input[str] secret_key: The Secret Key of the AWS IAM Role to use for pulling messages
        :param pulumi.Input[int] visibility_timeout: Modify the Visibility Timeout of the individual message from the Queue's default (seconds).
        """
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if attributes_to_return is not None:
            pulumi.set(__self__, "attributes_to_return", attributes_to_return)
        if delete_messages is not None:
            pulumi.set(__self__, "delete_messages", delete_messages)
        if max_batch_size is not None:
            pulumi.set(__self__, "max_batch_size", max_batch_size)
        if max_wait_time is not None:
            pulumi.set(__self__, "max_wait_time", max_wait_time)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> pulumi.Input[str]:
        """
        URL of the SQS Queue
        """
        return pulumi.get(self, "queue_url")

    @queue_url.setter
    def queue_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_url", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        AWS Region of the SQS Queue. must be one of ["af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Access Key ID of the AWS IAM Role to use for pulling messages
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="attributesToReturn")
    def attributes_to_return(self) -> Optional[pulumi.Input[str]]:
        """
        Comma separated list of Mesage Attribute names to return
        """
        return pulumi.get(self, "attributes_to_return")

    @attributes_to_return.setter
    def attributes_to_return(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attributes_to_return", value)

    @property
    @pulumi.getter(name="deleteMessages")
    def delete_messages(self) -> Optional[pulumi.Input[bool]]:
        """
        If Enabled, messages will be deleted from the SQS Queue after being read. If Disabled, messages are left in the queue and can be read more than once. WARNING: Enabling this option can result in data loss in cases of failure, use with caution, see documentation for more detail. . Default: false
        """
        return pulumi.get(self, "delete_messages")

    @delete_messages.setter
    def delete_messages(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_messages", value)

    @property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Max amount of messages to get in one batch (10 max)
        """
        return pulumi.get(self, "max_batch_size")

    @max_batch_size.setter
    def max_batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_batch_size", value)

    @property
    @pulumi.getter(name="maxWaitTime")
    def max_wait_time(self) -> Optional[pulumi.Input[int]]:
        """
        Max amount of time in seconds to wait for messages in a single poll (20 max)
        """
        return pulumi.get(self, "max_wait_time")

    @max_wait_time.setter
    def max_wait_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_wait_time", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Secret Key of the AWS IAM Role to use for pulling messages
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Modify the Visibility Timeout of the individual message from the Queue's default (seconds).
        """
        return pulumi.get(self, "visibility_timeout")

    @visibility_timeout.setter
    def visibility_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "visibility_timeout", value)


@pulumi.input_type
class SourceAmplitudeConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 data_region: Optional[pulumi.Input[str]] = None,
                 request_time_range: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] api_key: Amplitude API Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        :param pulumi.Input[str] secret_key: Amplitude Secret Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[str] data_region: Amplitude data region server. must be one of ["Standard Server", "EU Residency Server"]; Default: "Standard Server"
        :param pulumi.Input[int] request_time_range: According to <a href="https://www.docs.developers.amplitude.com/analytics/apis/export-api/#considerations">Considerations</a> too big time range in request can cause a timeout error. In this case, set shorter time interval in hours. Default: 24
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)
        if data_region is not None:
            pulumi.set(__self__, "data_region", data_region)
        if request_time_range is not None:
            pulumi.set(__self__, "request_time_range", request_time_range)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Amplitude API Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        Amplitude Secret Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="dataRegion")
    def data_region(self) -> Optional[pulumi.Input[str]]:
        """
        Amplitude data region server. must be one of ["Standard Server", "EU Residency Server"]; Default: "Standard Server"
        """
        return pulumi.get(self, "data_region")

    @data_region.setter
    def data_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_region", value)

    @property
    @pulumi.getter(name="requestTimeRange")
    def request_time_range(self) -> Optional[pulumi.Input[int]]:
        """
        According to <a href="https://www.docs.developers.amplitude.com/analytics/apis/export-api/#considerations">Considerations</a> too big time range in request can cause a timeout error. In this case, set shorter time interval in hours. Default: 24
        """
        return pulumi.get(self, "request_time_range")

    @request_time_range.setter
    def request_time_range(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_time_range", value)


@pulumi.input_type
class SourceApifyDatasetConfigurationArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: ID of the dataset you would like to load to Airbyte. In Apify Console, you can view your datasets in the <a href="https://console.apify.com/storage/datasets">Storage section under the Datasets tab</a> after you login. See the <a href="https://docs.apify.com/platform/storage/dataset">Apify Docs</a> for more information.
        :param pulumi.Input[str] token: Personal API token of your Apify account. In Apify Console, you can find your API token in the <a href="https://console.apify.com/account/integrations">Settings section under the Integrations tab</a> after you login. See the <a href="https://docs.apify.com/platform/integrations/api#api-token">Apify Docs</a> for more information.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        ID of the dataset you would like to load to Airbyte. In Apify Console, you can view your datasets in the <a href="https://console.apify.com/storage/datasets">Storage section under the Datasets tab</a> after you login. See the <a href="https://docs.apify.com/platform/storage/dataset">Apify Docs</a> for more information.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Personal API token of your Apify account. In Apify Console, you can find your API token in the <a href="https://console.apify.com/account/integrations">Settings section under the Integrations tab</a> after you login. See the <a href="https://docs.apify.com/platform/integrations/api#api-token">Apify Docs</a> for more information.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class SourceAppfollowConfigurationArgs:
    def __init__(__self__, *,
                 api_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_secret: API Key provided by Appfollow
        """
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[pulumi.Input[str]]:
        """
        API Key provided by Appfollow
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_secret", value)


@pulumi.input_type
class SourceAsanaConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceAsanaConfigurationCredentialsArgs']] = None,
                 organization_export_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 test_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['SourceAsanaConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Github
        :param pulumi.Input[Sequence[pulumi.Input[str]]] organization_export_ids: Globally unique identifiers for the organization exports
        :param pulumi.Input[bool] test_mode: This flag is used for testing purposes for certain streams that return a lot of data. This flag is not meant to be enabled for prod.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if organization_export_ids is not None:
            pulumi.set(__self__, "organization_export_ids", organization_export_ids)
        if test_mode is not None:
            pulumi.set(__self__, "test_mode", test_mode)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceAsanaConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate to Github
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceAsanaConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="organizationExportIds")
    def organization_export_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Globally unique identifiers for the organization exports
        """
        return pulumi.get(self, "organization_export_ids")

    @organization_export_ids.setter
    def organization_export_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "organization_export_ids", value)

    @property
    @pulumi.getter(name="testMode")
    def test_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        This flag is used for testing purposes for certain streams that return a lot of data. This flag is not meant to be enabled for prod.
        """
        return pulumi.get(self, "test_mode")

    @test_mode.setter
    def test_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "test_mode", value)


@pulumi.input_type
class SourceAsanaConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_asana_oauth: Optional[pulumi.Input['SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauthArgs']] = None,
                 authenticate_with_personal_access_token: Optional[pulumi.Input['SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs']] = None):
        if authenticate_via_asana_oauth is not None:
            pulumi.set(__self__, "authenticate_via_asana_oauth", authenticate_via_asana_oauth)
        if authenticate_with_personal_access_token is not None:
            pulumi.set(__self__, "authenticate_with_personal_access_token", authenticate_with_personal_access_token)

    @property
    @pulumi.getter(name="authenticateViaAsanaOauth")
    def authenticate_via_asana_oauth(self) -> Optional[pulumi.Input['SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauthArgs']]:
        return pulumi.get(self, "authenticate_via_asana_oauth")

    @authenticate_via_asana_oauth.setter
    def authenticate_via_asana_oauth(self, value: Optional[pulumi.Input['SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauthArgs']]):
        pulumi.set(self, "authenticate_via_asana_oauth", value)

    @property
    @pulumi.getter(name="authenticateWithPersonalAccessToken")
    def authenticate_with_personal_access_token(self) -> Optional[pulumi.Input['SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs']]:
        return pulumi.get(self, "authenticate_with_personal_access_token")

    @authenticate_with_personal_access_token.setter
    def authenticate_with_personal_access_token(self, value: Optional[pulumi.Input['SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs']]):
        pulumi.set(self, "authenticate_with_personal_access_token", value)


@pulumi.input_type
class SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: Asana Personal Access Token (generate yours <a href="https://app.asana.com/0/developer-console">here</a>).
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        Asana Personal Access Token (generate yours <a href="https://app.asana.com/0/developer-console">here</a>).
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class SourceAuth0ConfigurationArgs:
    def __init__(__self__, *,
                 base_url: pulumi.Input[str],
                 credentials: pulumi.Input['SourceAuth0ConfigurationCredentialsArgs'],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] base_url: The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Default: "2023-08-05T00:43:59.244Z"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "credentials", credentials)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> pulumi.Input[str]:
        """
        The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceAuth0ConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceAuth0ConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Default: "2023-08-05T00:43:59.244Z"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceAuth0ConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth2_access_token: Optional[pulumi.Input['SourceAuth0ConfigurationCredentialsOAuth2AccessTokenArgs']] = None,
                 o_auth2_confidential_application: Optional[pulumi.Input['SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplicationArgs']] = None):
        if o_auth2_access_token is not None:
            pulumi.set(__self__, "o_auth2_access_token", o_auth2_access_token)
        if o_auth2_confidential_application is not None:
            pulumi.set(__self__, "o_auth2_confidential_application", o_auth2_confidential_application)

    @property
    @pulumi.getter(name="oAuth2AccessToken")
    def o_auth2_access_token(self) -> Optional[pulumi.Input['SourceAuth0ConfigurationCredentialsOAuth2AccessTokenArgs']]:
        return pulumi.get(self, "o_auth2_access_token")

    @o_auth2_access_token.setter
    def o_auth2_access_token(self, value: Optional[pulumi.Input['SourceAuth0ConfigurationCredentialsOAuth2AccessTokenArgs']]):
        pulumi.set(self, "o_auth2_access_token", value)

    @property
    @pulumi.getter(name="oAuth2ConfidentialApplication")
    def o_auth2_confidential_application(self) -> Optional[pulumi.Input['SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplicationArgs']]:
        return pulumi.get(self, "o_auth2_confidential_application")

    @o_auth2_confidential_application.setter
    def o_auth2_confidential_application(self, value: Optional[pulumi.Input['SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplicationArgs']]):
        pulumi.set(self, "o_auth2_confidential_application", value)


@pulumi.input_type
class SourceAuth0ConfigurationCredentialsOAuth2AccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Also called <a href="https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-testing">API Access Token </a> The access token used to call the Auth0 Management API Token. It's a JWT that contains specific grant permissions knowns as scopes.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Also called <a href="https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-testing">API Access Token </a> The access token used to call the Auth0 Management API Token. It's a JWT that contains specific grant permissions knowns as scopes.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplicationArgs:
    def __init__(__self__, *,
                 audience: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] audience: The audience for the token, which is your API. You can find this in the Identifier field on your  <a href="https://manage.auth0.com/#/apis">API's settings tab</a>
        :param pulumi.Input[str] client_id: Your application's Client ID. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        :param pulumi.Input[str] client_secret: Your application's Client Secret. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter
    def audience(self) -> pulumi.Input[str]:
        """
        The audience for the token, which is your API. You can find this in the Identifier field on your  <a href="https://manage.auth0.com/#/apis">API's settings tab</a>
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: pulumi.Input[str]):
        pulumi.set(self, "audience", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Your application's Client ID. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Your application's Client Secret. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceAwsCloudtrailConfigurationArgs:
    def __init__(__self__, *,
                 aws_key_id: pulumi.Input[str],
                 aws_region_name: pulumi.Input[str],
                 aws_secret_key: pulumi.Input[str],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_key_id: AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] aws_region_name: The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name.
        :param pulumi.Input[str] aws_secret_key: AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] start_date: The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD. Default: "1970-01-01"
        """
        pulumi.set(__self__, "aws_key_id", aws_key_id)
        pulumi.set(__self__, "aws_region_name", aws_region_name)
        pulumi.set(__self__, "aws_secret_key", aws_secret_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="awsKeyId")
    def aws_key_id(self) -> pulumi.Input[str]:
        """
        AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "aws_key_id")

    @aws_key_id.setter
    def aws_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_key_id", value)

    @property
    @pulumi.getter(name="awsRegionName")
    def aws_region_name(self) -> pulumi.Input[str]:
        """
        The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name.
        """
        return pulumi.get(self, "aws_region_name")

    @aws_region_name.setter
    def aws_region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_region_name", value)

    @property
    @pulumi.getter(name="awsSecretKey")
    def aws_secret_key(self) -> pulumi.Input[str]:
        """
        AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "aws_secret_key")

    @aws_secret_key.setter
    def aws_secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "aws_secret_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD. Default: "1970-01-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationArgs:
    def __init__(__self__, *,
                 azure_blob_storage_account_name: pulumi.Input[str],
                 azure_blob_storage_container_name: pulumi.Input[str],
                 credentials: pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsArgs'],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceAzureBlobStorageConfigurationStreamArgs']]],
                 azure_blob_storage_endpoint: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] azure_blob_storage_account_name: The account's name of the Azure Blob Storage.
        :param pulumi.Input[str] azure_blob_storage_container_name: The name of the Azure blob storage container.
        :param pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsArgs'] credentials: Credentials for connecting to the Azure Blob Storage
        :param pulumi.Input[Sequence[pulumi.Input['SourceAzureBlobStorageConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] azure_blob_storage_endpoint: This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "azure_blob_storage_account_name", azure_blob_storage_account_name)
        pulumi.set(__self__, "azure_blob_storage_container_name", azure_blob_storage_container_name)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "streams", streams)
        if azure_blob_storage_endpoint is not None:
            pulumi.set(__self__, "azure_blob_storage_endpoint", azure_blob_storage_endpoint)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="azureBlobStorageAccountName")
    def azure_blob_storage_account_name(self) -> pulumi.Input[str]:
        """
        The account's name of the Azure Blob Storage.
        """
        return pulumi.get(self, "azure_blob_storage_account_name")

    @azure_blob_storage_account_name.setter
    def azure_blob_storage_account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_account_name", value)

    @property
    @pulumi.getter(name="azureBlobStorageContainerName")
    def azure_blob_storage_container_name(self) -> pulumi.Input[str]:
        """
        The name of the Azure blob storage container.
        """
        return pulumi.get(self, "azure_blob_storage_container_name")

    @azure_blob_storage_container_name.setter
    def azure_blob_storage_container_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_container_name", value)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsArgs']:
        """
        Credentials for connecting to the Azure Blob Storage
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceAzureBlobStorageConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceAzureBlobStorageConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="azureBlobStorageEndpoint")
    def azure_blob_storage_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
        """
        return pulumi.get(self, "azure_blob_storage_endpoint")

    @azure_blob_storage_endpoint.setter
    def azure_blob_storage_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_blob_storage_endpoint", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_oauth2: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2Args']] = None,
                 authenticate_via_storage_account_key: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKeyArgs']] = None):
        if authenticate_via_oauth2 is not None:
            pulumi.set(__self__, "authenticate_via_oauth2", authenticate_via_oauth2)
        if authenticate_via_storage_account_key is not None:
            pulumi.set(__self__, "authenticate_via_storage_account_key", authenticate_via_storage_account_key)

    @property
    @pulumi.getter(name="authenticateViaOauth2")
    def authenticate_via_oauth2(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2Args']]:
        return pulumi.get(self, "authenticate_via_oauth2")

    @authenticate_via_oauth2.setter
    def authenticate_via_oauth2(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2Args']]):
        pulumi.set(self, "authenticate_via_oauth2", value)

    @property
    @pulumi.getter(name="authenticateViaStorageAccountKey")
    def authenticate_via_storage_account_key(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKeyArgs']]:
        return pulumi.get(self, "authenticate_via_storage_account_key")

    @authenticate_via_storage_account_key.setter
    def authenticate_via_storage_account_key(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKeyArgs']]):
        pulumi.set(self, "authenticate_via_storage_account_key", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Client ID of your Microsoft developer application
        :param pulumi.Input[str] client_secret: Client Secret of your Microsoft developer application
        :param pulumi.Input[str] refresh_token: Refresh Token of your Microsoft developer application
        :param pulumi.Input[str] tenant_id: Tenant ID of the Microsoft Azure Application user
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token of your Microsoft developer application
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Tenant ID of the Microsoft Azure Application user
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKeyArgs:
    def __init__(__self__, *,
                 azure_blob_storage_account_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] azure_blob_storage_account_key: The Azure blob storage account key.
        """
        pulumi.set(__self__, "azure_blob_storage_account_key", azure_blob_storage_account_key)

    @property
    @pulumi.getter(name="azureBlobStorageAccountKey")
    def azure_blob_storage_account_key(self) -> pulumi.Input[str]:
        """
        The Azure blob storage account key.
        """
        return pulumi.get(self, "azure_blob_storage_account_key")

    @azure_blob_storage_account_key.setter
    def azure_blob_storage_account_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "azure_blob_storage_account_key", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 legacy_prefix: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] legacy_prefix: The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @legacy_prefix.setter
    def legacy_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legacy_prefix", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 avro_format: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatAvroFormatArgs']] = None,
                 csv_format: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatArgs']] = None,
                 document_file_type_format_experimental: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']] = None,
                 jsonl_format: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatJsonlFormatArgs']] = None,
                 parquet_format: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatParquetFormatArgs']] = None):
        """
        :param pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs'] document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatAvroFormatArgs']]:
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @document_file_type_format_experimental.setter
    def document_file_type_format_experimental(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]):
        pulumi.set(self, "document_file_type_format_experimental", value)

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatJsonlFormatArgs']]:
        return pulumi.get(self, "jsonl_format")

    @jsonl_format.setter
    def jsonl_format(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatJsonlFormatArgs']]):
        pulumi.set(self, "jsonl_format", value)

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatParquetFormatArgs']]:
        return pulumi.get(self, "parquet_format")

    @parquet_format.setter
    def parquet_format(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatParquetFormatArgs']]):
        pulumi.set(self, "parquet_format", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatAvroFormatArgs:
    def __init__(__self__, *,
                 double_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")

    @double_as_string.setter
    def double_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_as_string", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 ignore_errors_on_fields_mismatch: Optional[pulumi.Input[bool]] = None,
                 inference_type: Optional[pulumi.Input[str]] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[bool] ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param pulumi.Input[str] inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @ignore_errors_on_fields_mismatch.setter
    def ignore_errors_on_fields_mismatch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors_on_fields_mismatch", value)

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[pulumi.Input[str]]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @inference_type.setter
    def inference_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_type", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs:
    def __init__(__self__, *,
                 processing: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']] = None,
                 skip_unprocessable_files: Optional[pulumi.Input[bool]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs'] processing: Processing configuration
        :param pulumi.Input[bool] skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param pulumi.Input[str] strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @skip_unprocessable_files.setter
    def skip_unprocessable_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unprocessable_files", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs:
    def __init__(__self__, *,
                 local: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']] = None):
        """
        :param pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs'] local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input['SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]):
        pulumi.set(self, "local", value)


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatJsonlFormatArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceAzureBlobStorageConfigurationStreamFormatParquetFormatArgs:
    def __init__(__self__, *,
                 decimal_as_float: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")

    @decimal_as_float.setter
    def decimal_as_float(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decimal_as_float", value)


@pulumi.input_type
class SourceAzureTableConfigurationArgs:
    def __init__(__self__, *,
                 storage_access_key: pulumi.Input[str],
                 storage_account_name: pulumi.Input[str],
                 storage_endpoint_suffix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_access_key: Azure Table Storage Access Key. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] storage_account_name: The name of your storage account.
        :param pulumi.Input[str] storage_endpoint_suffix: Azure Table Storage service account URL suffix. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain endpoint suffix. Default: "core.windows.net"
        """
        pulumi.set(__self__, "storage_access_key", storage_access_key)
        pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_endpoint_suffix is not None:
            pulumi.set(__self__, "storage_endpoint_suffix", storage_endpoint_suffix)

    @property
    @pulumi.getter(name="storageAccessKey")
    def storage_access_key(self) -> pulumi.Input[str]:
        """
        Azure Table Storage Access Key. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "storage_access_key")

    @storage_access_key.setter
    def storage_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_access_key", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> pulumi.Input[str]:
        """
        The name of your storage account.
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account_name", value)

    @property
    @pulumi.getter(name="storageEndpointSuffix")
    def storage_endpoint_suffix(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Table Storage service account URL suffix. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain endpoint suffix. Default: "core.windows.net"
        """
        return pulumi.get(self, "storage_endpoint_suffix")

    @storage_endpoint_suffix.setter
    def storage_endpoint_suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_endpoint_suffix", value)


@pulumi.input_type
class SourceBambooHrConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 subdomain: pulumi.Input[str],
                 custom_reports_fields: Optional[pulumi.Input[str]] = None,
                 custom_reports_include_default_fields: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] api_key: Api key of bamboo hr
        :param pulumi.Input[str] subdomain: Sub Domain of bamboo hr
        :param pulumi.Input[str] custom_reports_fields: Comma-separated list of fields to include in custom reports. Default: ""
        :param pulumi.Input[bool] custom_reports_include_default_fields: If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names. Default: true
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "subdomain", subdomain)
        if custom_reports_fields is not None:
            pulumi.set(__self__, "custom_reports_fields", custom_reports_fields)
        if custom_reports_include_default_fields is not None:
            pulumi.set(__self__, "custom_reports_include_default_fields", custom_reports_include_default_fields)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Api key of bamboo hr
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[str]:
        """
        Sub Domain of bamboo hr
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "subdomain", value)

    @property
    @pulumi.getter(name="customReportsFields")
    def custom_reports_fields(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of fields to include in custom reports. Default: ""
        """
        return pulumi.get(self, "custom_reports_fields")

    @custom_reports_fields.setter
    def custom_reports_fields(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_reports_fields", value)

    @property
    @pulumi.getter(name="customReportsIncludeDefaultFields")
    def custom_reports_include_default_fields(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names. Default: true
        """
        return pulumi.get(self, "custom_reports_include_default_fields")

    @custom_reports_include_default_fields.setter
    def custom_reports_include_default_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_reports_include_default_fields", value)


@pulumi.input_type
class SourceBigqueryConfigurationArgs:
    def __init__(__self__, *,
                 credentials_json: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 dataset_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credentials_json: The contents of your Service Account Key JSON file. See the <a href="https://docs.airbyte.com/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] project_id: The GCP project ID for the project containing the target BigQuery dataset.
        :param pulumi.Input[str] dataset_id: The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
        """
        pulumi.set(__self__, "credentials_json", credentials_json)
        pulumi.set(__self__, "project_id", project_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> pulumi.Input[str]:
        """
        The contents of your Service Account Key JSON file. See the <a href="https://docs.airbyte.com/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_json", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The GCP project ID for the project containing the target BigQuery dataset.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)


@pulumi.input_type
class SourceBingAdsConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 developer_token: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 account_names: Optional[pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationAccountNameArgs']]]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 custom_reports: Optional[pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationCustomReportArgs']]]] = None,
                 lookback_window: Optional[pulumi.Input[int]] = None,
                 reports_start_date: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Microsoft Advertising developer application.
        :param pulumi.Input[str] developer_token: Developer token associated with user. See more info <a href="https://docs.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13#get-developer-token"> in the docs</a>.
        :param pulumi.Input[str] refresh_token: Refresh Token to renew the expired Access Token.
        :param pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationAccountNameArgs']]] account_names: Predicates that will be used to sync data by specific accounts.
        :param pulumi.Input[str] client_secret: The Client Secret of your Microsoft Advertising developer application. Default: ""
        :param pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationCustomReportArgs']]] custom_reports: You can add your Custom Bing Ads report by creating one.
        :param pulumi.Input[int] lookback_window: Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode without specified Reports Start Date. Default: 0
        :param pulumi.Input[str] reports_start_date: The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format. If not set, data from previous and current calendar year will be replicated.
        :param pulumi.Input[str] tenant_id: The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value. Default: "common"
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "developer_token", developer_token)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if account_names is not None:
            pulumi.set(__self__, "account_names", account_names)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if lookback_window is not None:
            pulumi.set(__self__, "lookback_window", lookback_window)
        if reports_start_date is not None:
            pulumi.set(__self__, "reports_start_date", reports_start_date)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Microsoft Advertising developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> pulumi.Input[str]:
        """
        Developer token associated with user. See more info <a href="https://docs.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13#get-developer-token"> in the docs</a>.
        """
        return pulumi.get(self, "developer_token")

    @developer_token.setter
    def developer_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "developer_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="accountNames")
    def account_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationAccountNameArgs']]]]:
        """
        Predicates that will be used to sync data by specific accounts.
        """
        return pulumi.get(self, "account_names")

    @account_names.setter
    def account_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationAccountNameArgs']]]]):
        pulumi.set(self, "account_names", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of your Microsoft Advertising developer application. Default: ""
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationCustomReportArgs']]]]:
        """
        You can add your Custom Bing Ads report by creating one.
        """
        return pulumi.get(self, "custom_reports")

    @custom_reports.setter
    def custom_reports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceBingAdsConfigurationCustomReportArgs']]]]):
        pulumi.set(self, "custom_reports", value)

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional[pulumi.Input[int]]:
        """
        Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode without specified Reports Start Date. Default: 0
        """
        return pulumi.get(self, "lookback_window")

    @lookback_window.setter
    def lookback_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window", value)

    @property
    @pulumi.getter(name="reportsStartDate")
    def reports_start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format. If not set, data from previous and current calendar year will be replicated.
        """
        return pulumi.get(self, "reports_start_date")

    @reports_start_date.setter
    def reports_start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reports_start_date", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value. Default: "common"
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class SourceBingAdsConfigurationAccountNameArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 operator: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Account Name is a string value for comparing with the specified predicate.
        :param pulumi.Input[str] operator: An Operator that will be used to filter accounts. The Contains predicate has features for matching words, matching inflectional forms of words, searching using wildcard characters, and searching using proximity. The Equals is used to return all rows where account name is equal(=) to the string that you provided. must be one of ["Contains", "Equals"]
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Account Name is a string value for comparing with the specified predicate.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        An Operator that will be used to filter accounts. The Contains predicate has features for matching words, matching inflectional forms of words, searching using wildcard characters, and searching using proximity. The Equals is used to return all rows where account name is equal(=) to the string that you provided. must be one of ["Contains", "Equals"]
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class SourceBingAdsConfigurationCustomReportArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 report_columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 reporting_object: pulumi.Input[str],
                 report_aggregation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the custom report, this name would be used as stream name
        :param pulumi.Input[Sequence[pulumi.Input[str]]] report_columns: A list of available report object columns. You can find it in description of reporting object that you want to add to custom report.
        :param pulumi.Input[str] reporting_object: The name of the the object derives from the ReportRequest object. You can find it in Bing Ads Api docs - Reporting API - Reporting Data Objects. must be one of ["AccountPerformanceReportRequest", "AdDynamicTextPerformanceReportRequest", "AdExtensionByAdReportRequest", "AdExtensionByKeywordReportRequest", "AdExtensionDetailReportRequest", "AdGroupPerformanceReportRequest", "AdPerformanceReportRequest", "AgeGenderAudienceReportRequest", "AudiencePerformanceReportRequest", "CallDetailReportRequest", "CampaignPerformanceReportRequest", "ConversionPerformanceReportRequest", "DestinationUrlPerformanceReportRequest", "DSAAutoTargetPerformanceReportRequest", "DSACategoryPerformanceReportRequest", "DSASearchQueryPerformanceReportRequest", "GeographicPerformanceReportRequest", "GoalsAndFunnelsReportRequest", "HotelDimensionPerformanceReportRequest", "HotelGroupPerformanceReportRequest", "KeywordPerformanceReportRequest", "NegativeKeywordConflictReportRequest", "ProductDimensionPerformanceReportRequest", "ProductMatchCountReportRequest", "ProductNegativeKeywordConflictReportRequest", "ProductPartitionPerformanceReportRequest", "ProductPartitionUnitPerformanceReportRequest", "ProductSearchQueryPerformanceReportRequest", "ProfessionalDemographicsAudienceReportRequest", "PublisherUsagePerformanceReportRequest", "SearchCampaignChangeHistoryReportRequest", "SearchQueryPerformanceReportRequest", "ShareOfVoiceReportRequest", "UserLocationPerformanceReportRequest"]
        :param pulumi.Input[str] report_aggregation: A list of available aggregations. Default: "[Hourly]"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "report_columns", report_columns)
        pulumi.set(__self__, "reporting_object", reporting_object)
        if report_aggregation is not None:
            pulumi.set(__self__, "report_aggregation", report_aggregation)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the custom report, this name would be used as stream name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="reportColumns")
    def report_columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of available report object columns. You can find it in description of reporting object that you want to add to custom report.
        """
        return pulumi.get(self, "report_columns")

    @report_columns.setter
    def report_columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "report_columns", value)

    @property
    @pulumi.getter(name="reportingObject")
    def reporting_object(self) -> pulumi.Input[str]:
        """
        The name of the the object derives from the ReportRequest object. You can find it in Bing Ads Api docs - Reporting API - Reporting Data Objects. must be one of ["AccountPerformanceReportRequest", "AdDynamicTextPerformanceReportRequest", "AdExtensionByAdReportRequest", "AdExtensionByKeywordReportRequest", "AdExtensionDetailReportRequest", "AdGroupPerformanceReportRequest", "AdPerformanceReportRequest", "AgeGenderAudienceReportRequest", "AudiencePerformanceReportRequest", "CallDetailReportRequest", "CampaignPerformanceReportRequest", "ConversionPerformanceReportRequest", "DestinationUrlPerformanceReportRequest", "DSAAutoTargetPerformanceReportRequest", "DSACategoryPerformanceReportRequest", "DSASearchQueryPerformanceReportRequest", "GeographicPerformanceReportRequest", "GoalsAndFunnelsReportRequest", "HotelDimensionPerformanceReportRequest", "HotelGroupPerformanceReportRequest", "KeywordPerformanceReportRequest", "NegativeKeywordConflictReportRequest", "ProductDimensionPerformanceReportRequest", "ProductMatchCountReportRequest", "ProductNegativeKeywordConflictReportRequest", "ProductPartitionPerformanceReportRequest", "ProductPartitionUnitPerformanceReportRequest", "ProductSearchQueryPerformanceReportRequest", "ProfessionalDemographicsAudienceReportRequest", "PublisherUsagePerformanceReportRequest", "SearchCampaignChangeHistoryReportRequest", "SearchQueryPerformanceReportRequest", "ShareOfVoiceReportRequest", "UserLocationPerformanceReportRequest"]
        """
        return pulumi.get(self, "reporting_object")

    @reporting_object.setter
    def reporting_object(self, value: pulumi.Input[str]):
        pulumi.set(self, "reporting_object", value)

    @property
    @pulumi.getter(name="reportAggregation")
    def report_aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        A list of available aggregations. Default: "[Hourly]"
        """
        return pulumi.get(self, "report_aggregation")

    @report_aggregation.setter
    def report_aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "report_aggregation", value)


@pulumi.input_type
class SourceBraintreeConfigurationArgs:
    def __init__(__self__, *,
                 environment: pulumi.Input[str],
                 merchant_id: pulumi.Input[str],
                 private_key: pulumi.Input[str],
                 public_key: pulumi.Input[str],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] environment: Environment specifies where the data will come from. must be one of ["Development", "Sandbox", "Qa", "Production"]
        :param pulumi.Input[str] merchant_id: The unique identifier for your entire gateway account. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this ID.
        :param pulumi.Input[str] private_key: Braintree Private Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] public_key: Braintree Public Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "merchant_id", merchant_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "public_key", public_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def environment(self) -> pulumi.Input[str]:
        """
        Environment specifies where the data will come from. must be one of ["Development", "Sandbox", "Qa", "Production"]
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="merchantId")
    def merchant_id(self) -> pulumi.Input[str]:
        """
        The unique identifier for your entire gateway account. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this ID.
        """
        return pulumi.get(self, "merchant_id")

    @merchant_id.setter
    def merchant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "merchant_id", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Braintree Private Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        Braintree Public Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceBrazeConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Braze REST API key
        :param pulumi.Input[str] start_date: Rows after this date will be synced
        :param pulumi.Input[str] url: Braze REST API endpoint
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Braze REST API key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Rows after this date will be synced
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Braze REST API endpoint
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SourceCartConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceCartConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate the data
        """
        pulumi.set(__self__, "start_date", start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate the data
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceCartConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceCartConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceCartConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 central_api_router: Optional[pulumi.Input['SourceCartConfigurationCredentialsCentralApiRouterArgs']] = None,
                 single_store_access_token: Optional[pulumi.Input['SourceCartConfigurationCredentialsSingleStoreAccessTokenArgs']] = None):
        if central_api_router is not None:
            pulumi.set(__self__, "central_api_router", central_api_router)
        if single_store_access_token is not None:
            pulumi.set(__self__, "single_store_access_token", single_store_access_token)

    @property
    @pulumi.getter(name="centralApiRouter")
    def central_api_router(self) -> Optional[pulumi.Input['SourceCartConfigurationCredentialsCentralApiRouterArgs']]:
        return pulumi.get(self, "central_api_router")

    @central_api_router.setter
    def central_api_router(self, value: Optional[pulumi.Input['SourceCartConfigurationCredentialsCentralApiRouterArgs']]):
        pulumi.set(self, "central_api_router", value)

    @property
    @pulumi.getter(name="singleStoreAccessToken")
    def single_store_access_token(self) -> Optional[pulumi.Input['SourceCartConfigurationCredentialsSingleStoreAccessTokenArgs']]:
        return pulumi.get(self, "single_store_access_token")

    @single_store_access_token.setter
    def single_store_access_token(self, value: Optional[pulumi.Input['SourceCartConfigurationCredentialsSingleStoreAccessTokenArgs']]):
        pulumi.set(self, "single_store_access_token", value)


@pulumi.input_type
class SourceCartConfigurationCredentialsCentralApiRouterArgs:
    def __init__(__self__, *,
                 site_id: pulumi.Input[str],
                 user_name: pulumi.Input[str],
                 user_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] site_id: You can determine a site provisioning site Id by hitting https://site.com/store/sitemonitor.aspx and reading the response param PSID
        :param pulumi.Input[str] user_name: Enter your application's User Name
        :param pulumi.Input[str] user_secret: Enter your application's User Secret
        """
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "user_secret", user_secret)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> pulumi.Input[str]:
        """
        You can determine a site provisioning site Id by hitting https://site.com/store/sitemonitor.aspx and reading the response param PSID
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        Enter your application's User Name
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter(name="userSecret")
    def user_secret(self) -> pulumi.Input[str]:
        """
        Enter your application's User Secret
        """
        return pulumi.get(self, "user_secret")

    @user_secret.setter
    def user_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_secret", value)


@pulumi.input_type
class SourceCartConfigurationCredentialsSingleStoreAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 store_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] store_name: The name of Cart.com Online Store. All API URLs start with https://[mystorename.com]/api/v1/, where [mystorename.com] is the domain name of your store.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "store_name", store_name)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> pulumi.Input[str]:
        """
        The name of Cart.com Online Store. All API URLs start with https://[mystorename.com]/api/v1/, where [mystorename.com] is the domain name of your store.
        """
        return pulumi.get(self, "store_name")

    @store_name.setter
    def store_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "store_name", value)


@pulumi.input_type
class SourceChargebeeConfigurationArgs:
    def __init__(__self__, *,
                 site: pulumi.Input[str],
                 site_api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 product_catalog: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] site: The site prefix for your Chargebee instance.
        :param pulumi.Input[str] site_api_key: Chargebee API Key. See the <a href="https://docs.airbyte.com/integrations/sources/chargebee">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
        :param pulumi.Input[str] product_catalog: Product Catalog version of your Chargebee site. Instructions on how to find your version you may find <a href="https://apidocs.chargebee.com/docs/api?prod_cat_ver=2">here</a> under `API Version` section. If left blank, the product catalog version will be set to 2.0. must be one of ["1.0", "2.0"]; Default: "2.0"
        """
        pulumi.set(__self__, "site", site)
        pulumi.set(__self__, "site_api_key", site_api_key)
        pulumi.set(__self__, "start_date", start_date)
        if product_catalog is not None:
            pulumi.set(__self__, "product_catalog", product_catalog)

    @property
    @pulumi.getter
    def site(self) -> pulumi.Input[str]:
        """
        The site prefix for your Chargebee instance.
        """
        return pulumi.get(self, "site")

    @site.setter
    def site(self, value: pulumi.Input[str]):
        pulumi.set(self, "site", value)

    @property
    @pulumi.getter(name="siteApiKey")
    def site_api_key(self) -> pulumi.Input[str]:
        """
        Chargebee API Key. See the <a href="https://docs.airbyte.com/integrations/sources/chargebee">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "site_api_key")

    @site_api_key.setter
    def site_api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "site_api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="productCatalog")
    def product_catalog(self) -> Optional[pulumi.Input[str]]:
        """
        Product Catalog version of your Chargebee site. Instructions on how to find your version you may find <a href="https://apidocs.chargebee.com/docs/api?prod_cat_ver=2">here</a> under `API Version` section. If left blank, the product catalog version will be set to 2.0. must be one of ["1.0", "2.0"]; Default: "2.0"
        """
        return pulumi.get(self, "product_catalog")

    @product_catalog.setter
    def product_catalog(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "product_catalog", value)


@pulumi.input_type
class SourceChartmogulConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Your Chartmogul API key. See <a href="https://help.chartmogul.com/hc/en-us/articles/4407796325906-Creating-and-Managing-API-keys#creating-an-api-key"> the docs </a> for info on how to obtain this.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your Chartmogul API key. See <a href="https://help.chartmogul.com/hc/en-us/articles/4407796325906-Creating-and-Managing-API-keys#creating-an-api-key"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceClickhouseConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 tunnel_method: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: The name of the database.
        :param pulumi.Input[str] host: The host endpoint of the Clickhouse cluster.
        :param pulumi.Input[str] username: The username which is used to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        :param pulumi.Input[str] password: The password associated with this username.
        :param pulumi.Input[int] port: The port of the database. Default: 8123
        :param pulumi.Input['SourceClickhouseConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host endpoint of the Clickhouse cluster.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the database. Default: 8123
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class SourceClickhouseConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['SourceClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class SourceClickhouseConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceClickhouseConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceClickhouseConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceClickupApiConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 folder_id: Optional[pulumi.Input[str]] = None,
                 include_closed_tasks: Optional[pulumi.Input[bool]] = None,
                 list_id: Optional[pulumi.Input[str]] = None,
                 space_id: Optional[pulumi.Input[str]] = None,
                 team_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Every ClickUp API call required authentication. This field is your personal API token. See <a href="https://clickup.com/api/developer-portal/authentication/#personal-token">here</a>.
        :param pulumi.Input[str] folder_id: The ID of your folder in your space. Retrieve it from the `/space/{space_id}/folder` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetFolders/">here</a>.
        :param pulumi.Input[bool] include_closed_tasks: Include or exclude closed tasks. By default, they are excluded. See <a https://clickup.com/api/clickupreference/operation/GetTasks/#!in=query&path=include_closed&t=request">here</a>. Default: false
        :param pulumi.Input[str] list_id: The ID of your list in your folder. Retrieve it from the `/folder/{folder_id}/list` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetLists/">here</a>.
        :param pulumi.Input[str] space_id: The ID of your space in your workspace. Retrieve it from the `/team/{team_id}/space` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetSpaces/">here</a>.
        :param pulumi.Input[str] team_id: The ID of your team in ClickUp. Retrieve it from the `/team` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetAuthorizedTeams/">here</a>.
        """
        pulumi.set(__self__, "api_token", api_token)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if include_closed_tasks is not None:
            pulumi.set(__self__, "include_closed_tasks", include_closed_tasks)
        if list_id is not None:
            pulumi.set(__self__, "list_id", list_id)
        if space_id is not None:
            pulumi.set(__self__, "space_id", space_id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Every ClickUp API call required authentication. This field is your personal API token. See <a href="https://clickup.com/api/developer-portal/authentication/#personal-token">here</a>.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your folder in your space. Retrieve it from the `/space/{space_id}/folder` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetFolders/">here</a>.
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="includeClosedTasks")
    def include_closed_tasks(self) -> Optional[pulumi.Input[bool]]:
        """
        Include or exclude closed tasks. By default, they are excluded. See <a https://clickup.com/api/clickupreference/operation/GetTasks/#!in=query&path=include_closed&t=request">here</a>. Default: false
        """
        return pulumi.get(self, "include_closed_tasks")

    @include_closed_tasks.setter
    def include_closed_tasks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_closed_tasks", value)

    @property
    @pulumi.getter(name="listId")
    def list_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your list in your folder. Retrieve it from the `/folder/{folder_id}/list` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetLists/">here</a>.
        """
        return pulumi.get(self, "list_id")

    @list_id.setter
    def list_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_id", value)

    @property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your space in your workspace. Retrieve it from the `/team/{team_id}/space` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetSpaces/">here</a>.
        """
        return pulumi.get(self, "space_id")

    @space_id.setter
    def space_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "space_id", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of your team in ClickUp. Retrieve it from the `/team` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetAuthorizedTeams/">here</a>.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)


@pulumi.input_type
class SourceClockifyConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 workspace_id: pulumi.Input[str],
                 api_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: You can get your api access_key <a href="https://app.clockify.me/user/settings">here</a> This API is Case Sensitive.
        :param pulumi.Input[str] workspace_id: WorkSpace Id
        :param pulumi.Input[str] api_url: The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify. Default: "https://api.clockify.me"
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "workspace_id", workspace_id)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        You can get your api access_key <a href="https://app.clockify.me/user/settings">here</a> This API is Case Sensitive.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[str]:
        """
        WorkSpace Id
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace_id", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify. Default: "https://api.clockify.me"
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)


@pulumi.input_type
class SourceCloseComConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Close.com API key (usually starts with 'api_'; find yours <a href="https://app.close.com/settings/api/">here</a>).
        :param pulumi.Input[str] start_date: The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD. Default: "2021-01-01"
        """
        pulumi.set(__self__, "api_key", api_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Close.com API key (usually starts with 'api_'; find yours <a href="https://app.close.com/settings/api/">here</a>).
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD. Default: "2021-01-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceCodaConfigurationArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_token: Bearer token
        """
        pulumi.set(__self__, "auth_token", auth_token)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[str]:
        """
        Bearer token
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_token", value)


@pulumi.input_type
class SourceCoinApiConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 period: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 symbol_id: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] api_key: API Key
        :param pulumi.Input[str] period: The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
        :param pulumi.Input[str] start_date: The start date in ISO 8601 format.
        :param pulumi.Input[str] symbol_id: The symbol ID to use. See the documentation for a list.
               https://docs.coinapi.io/#list-all-symbols-get
        :param pulumi.Input[str] end_date: The end date in ISO 8601 format. If not supplied, data will be returned
               from the start date to the current time, or when the count of result
               elements reaches its limit.
        :param pulumi.Input[str] environment: The environment to use. Either sandbox or production.
               
               must be one of ["sandbox", "production"]; Default: "sandbox"
        :param pulumi.Input[int] limit: The maximum number of elements to return. If not supplied, the default
               is 100. For numbers larger than 100, each 100 items is counted as one
               request for pricing purposes. Maximum value is 100000.
               
               Default: 100
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "symbol_id", symbol_id)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The start date in ISO 8601 format.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="symbolId")
    def symbol_id(self) -> pulumi.Input[str]:
        """
        The symbol ID to use. See the documentation for a list.
        https://docs.coinapi.io/#list-all-symbols-get
        """
        return pulumi.get(self, "symbol_id")

    @symbol_id.setter
    def symbol_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "symbol_id", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The end date in ISO 8601 format. If not supplied, data will be returned
        from the start date to the current time, or when the count of result
        elements reaches its limit.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The environment to use. Either sandbox or production.

        must be one of ["sandbox", "production"]; Default: "sandbox"
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of elements to return. If not supplied, the default
        is 100. For numbers larger than 100, each 100 items is counted as one
        request for pricing purposes. Maximum value is 100000.

        Default: 100
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)


@pulumi.input_type
class SourceCoinmarketcapConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 data_type: pulumi.Input[str],
                 symbols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] api_key: Your API Key. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Authentication">here</a>. The token is case sensitive.
        :param pulumi.Input[str] data_type: /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Endpoint-Overview">here</a>. must be one of ["latest", "historical"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] symbols: Cryptocurrency symbols. (only used for quotes stream)
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "data_type", data_type)
        if symbols is not None:
            pulumi.set(__self__, "symbols", symbols)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API Key. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Authentication">here</a>. The token is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> pulumi.Input[str]:
        """
        /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Endpoint-Overview">here</a>. must be one of ["latest", "historical"]
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def symbols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Cryptocurrency symbols. (only used for quotes stream)
        """
        return pulumi.get(self, "symbols")

    @symbols.setter
    def symbols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "symbols", value)


@pulumi.input_type
class SourceConfigcatConfigurationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Basic auth password. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        :param pulumi.Input[str] username: Basic auth user name. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Basic auth password. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Basic auth user name. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SourceConfluenceConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 domain_name: pulumi.Input[str],
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: Please follow the Jira confluence for generating an API token: <a href="https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/">generating an API token</a>.
        :param pulumi.Input[str] domain_name: Your Confluence domain name
        :param pulumi.Input[str] email: Your Confluence login email
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Please follow the Jira confluence for generating an API token: <a href="https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/">generating an API token</a>.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        Your Confluence domain name
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        Your Confluence login email
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class SourceConvexConfigurationArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 deployment_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_key: API access key used to retrieve data from Convex.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "deployment_url", deployment_url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        API access key used to retrieve data from Convex.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="deploymentUrl")
    def deployment_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "deployment_url")

    @deployment_url.setter
    def deployment_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment_url", value)


@pulumi.input_type
class SourceDatascopeConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key
        :param pulumi.Input[str] start_date: Start date for the data to be replicated
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start date for the data to be replicated
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceDelightedConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 since: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: A Delighted API key.
        :param pulumi.Input[str] since: The date from which you'd like to replicate the data
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "since", since)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        A Delighted API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def since(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate the data
        """
        return pulumi.get(self, "since")

    @since.setter
    def since(self, value: pulumi.Input[str]):
        pulumi.set(self, "since", value)


@pulumi.input_type
class SourceDixaConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] api_token: Dixa API token
        :param pulumi.Input[str] start_date: The connector pulls records updated from this date onwards.
        :param pulumi.Input[int] batch_size: Number of days to batch into one request. Max 31. Default: 31
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "start_date", start_date)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Dixa API token
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The connector pulls records updated from this date onwards.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days to batch into one request. Max 31. Default: 31
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)


@pulumi.input_type
class SourceDockerhubConfigurationArgs:
    def __init__(__self__, *,
                 docker_username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] docker_username: Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
        """
        pulumi.set(__self__, "docker_username", docker_username)

    @property
    @pulumi.getter(name="dockerUsername")
    def docker_username(self) -> pulumi.Input[str]:
        """
        Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
        """
        return pulumi.get(self, "docker_username")

    @docker_username.setter
    def docker_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "docker_username", value)


@pulumi.input_type
class SourceDremioConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 base_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: API Key that is generated when you authenticate to Dremio API
        :param pulumi.Input[str] base_url: URL of your Dremio instance. Default: "https://app.dremio.cloud"
        """
        pulumi.set(__self__, "api_key", api_key)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key that is generated when you authenticate to Dremio API
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        URL of your Dremio instance. Default: "https://app.dremio.cloud"
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)


@pulumi.input_type
class SourceDynamodbConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsArgs']] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 ignore_missing_read_permissions_tables: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 reserved_attribute_names: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceDynamodbConfigurationCredentialsArgs'] credentials: Credentials for the service
        :param pulumi.Input[str] endpoint: the URL of the Dynamodb database. Default: ""
        :param pulumi.Input[bool] ignore_missing_read_permissions_tables: Ignore tables with missing scan/read permissions. Default: false
        :param pulumi.Input[str] region: The region of the Dynamodb database. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        :param pulumi.Input[str] reserved_attribute_names: Comma separated reserved attribute names present in your tables
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if ignore_missing_read_permissions_tables is not None:
            pulumi.set(__self__, "ignore_missing_read_permissions_tables", ignore_missing_read_permissions_tables)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if reserved_attribute_names is not None:
            pulumi.set(__self__, "reserved_attribute_names", reserved_attribute_names)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsArgs']]:
        """
        Credentials for the service
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        the URL of the Dynamodb database. Default: ""
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="ignoreMissingReadPermissionsTables")
    def ignore_missing_read_permissions_tables(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore tables with missing scan/read permissions. Default: false
        """
        return pulumi.get(self, "ignore_missing_read_permissions_tables")

    @ignore_missing_read_permissions_tables.setter
    def ignore_missing_read_permissions_tables(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_missing_read_permissions_tables", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the Dynamodb database. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="reservedAttributeNames")
    def reserved_attribute_names(self) -> Optional[pulumi.Input[str]]:
        """
        Comma separated reserved attribute names present in your tables
        """
        return pulumi.get(self, "reserved_attribute_names")

    @reserved_attribute_names.setter
    def reserved_attribute_names(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reserved_attribute_names", value)


@pulumi.input_type
class SourceDynamodbConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_access_keys: Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeysArgs']] = None,
                 role_based_authentication: Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsRoleBasedAuthenticationArgs']] = None):
        if authenticate_via_access_keys is not None:
            pulumi.set(__self__, "authenticate_via_access_keys", authenticate_via_access_keys)
        if role_based_authentication is not None:
            pulumi.set(__self__, "role_based_authentication", role_based_authentication)

    @property
    @pulumi.getter(name="authenticateViaAccessKeys")
    def authenticate_via_access_keys(self) -> Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeysArgs']]:
        return pulumi.get(self, "authenticate_via_access_keys")

    @authenticate_via_access_keys.setter
    def authenticate_via_access_keys(self, value: Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeysArgs']]):
        pulumi.set(self, "authenticate_via_access_keys", value)

    @property
    @pulumi.getter(name="roleBasedAuthentication")
    def role_based_authentication(self) -> Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsRoleBasedAuthenticationArgs']]:
        return pulumi.get(self, "role_based_authentication")

    @role_based_authentication.setter
    def role_based_authentication(self, value: Optional[pulumi.Input['SourceDynamodbConfigurationCredentialsRoleBasedAuthenticationArgs']]):
        pulumi.set(self, "role_based_authentication", value)


@pulumi.input_type
class SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeysArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[str],
                 secret_access_key: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_id: The access key id to access Dynamodb. Airbyte requires read permissions to the database
        :param pulumi.Input[str] secret_access_key: The corresponding secret to the access key id.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[str]:
        """
        The access key id to access Dynamodb. Airbyte requires read permissions to the database
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[str]:
        """
        The corresponding secret to the access key id.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceDynamodbConfigurationCredentialsRoleBasedAuthenticationArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceEmailoctopusConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: EmailOctopus API Key. See the <a href="https://help.emailoctopus.com/article/165-how-to-create-and-delete-api-keys">docs</a> for information on how to generate this key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        EmailOctopus API Key. See the <a href="https://help.emailoctopus.com/article/165-how-to-create-and-delete-api-keys">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceExchangeRatesConfigurationArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 base: Optional[pulumi.Input[str]] = None,
                 ignore_weekends: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] access_key: Your API Key. See <a href="https://apilayer.com/marketplace/exchangerates_data-api">here</a>. The key is case sensitive.
        :param pulumi.Input[str] start_date: Start getting data from that date.
        :param pulumi.Input[str] base: ISO reference currency. See <a href="https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html">here</a>. Free plan doesn't support Source Currency Switching, default base currency is EUR
        :param pulumi.Input[bool] ignore_weekends: Ignore weekends? (Exchanges don't run on weekends). Default: true
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "start_date", start_date)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if ignore_weekends is not None:
            pulumi.set(__self__, "ignore_weekends", ignore_weekends)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        Your API Key. See <a href="https://apilayer.com/marketplace/exchangerates_data-api">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start getting data from that date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def base(self) -> Optional[pulumi.Input[str]]:
        """
        ISO reference currency. See <a href="https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html">here</a>. Free plan doesn't support Source Currency Switching, default base currency is EUR
        """
        return pulumi.get(self, "base")

    @base.setter
    def base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base", value)

    @property
    @pulumi.getter(name="ignoreWeekends")
    def ignore_weekends(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore weekends? (Exchanges don't run on weekends). Default: true
        """
        return pulumi.get(self, "ignore_weekends")

    @ignore_weekends.setter
    def ignore_weekends(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_weekends", value)


@pulumi.input_type
class SourceFacebookMarketingConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 account_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 action_breakdowns_allow_empty: Optional[pulumi.Input[bool]] = None,
                 ad_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 adset_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 campaign_statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 custom_insights: Optional[pulumi.Input[Sequence[pulumi.Input['SourceFacebookMarketingConfigurationCustomInsightArgs']]]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 fetch_thumbnail_images: Optional[pulumi.Input[bool]] = None,
                 insights_job_timeout: Optional[pulumi.Input[int]] = None,
                 insights_lookback_window: Optional[pulumi.Input[int]] = None,
                 page_size: Optional[pulumi.Input[int]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The value of the generated access token. From your Apps Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] account_ids: The Facebook Ad account ID(s) to pull data from. The Ad account ID number is in the account dropdown menu or in your browser's address bar of your <a href="https://adsmanager.facebook.com/adsmanager/">Meta Ads Manager</a>. See the <a href="https://www.facebook.com/business/help/1492627900875762">docs</a> for more information.
        :param pulumi.Input[bool] action_breakdowns_allow_empty: Allows action_breakdowns to be an empty list. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ad_statuses: Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] adset_statuses: Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] campaign_statuses: Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        :param pulumi.Input[str] client_id: The Client Id for your OAuth app
        :param pulumi.Input[str] client_secret: The Client Secret for your OAuth app
        :param pulumi.Input[Sequence[pulumi.Input['SourceFacebookMarketingConfigurationCustomInsightArgs']]] custom_insights: A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        :param pulumi.Input[str] end_date: The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        :param pulumi.Input[bool] fetch_thumbnail_images: Set to active if you want to fetch the thumbnail_url and store the result in thumbnail_data_url for each Ad Creative. Default: false
        :param pulumi.Input[int] insights_job_timeout: Insights Job Timeout establishes the maximum amount of time (in minutes) of waiting for the report job to complete. When timeout is reached the job is considered failed and we are trying to request smaller amount of data by breaking the job to few smaller ones. If you definitely know that 60 minutes is not enough for your report to be processed then you can decrease the timeout value, so we start breaking job to smaller parts faster. Default: 60
        :param pulumi.Input[int] insights_lookback_window: The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here. Default: 28
        :param pulumi.Input[int] page_size: Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases. Default: 100
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. If not set then all data will be replicated for usual streams and only last 2 years for insight streams.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "account_ids", account_ids)
        if action_breakdowns_allow_empty is not None:
            pulumi.set(__self__, "action_breakdowns_allow_empty", action_breakdowns_allow_empty)
        if ad_statuses is not None:
            pulumi.set(__self__, "ad_statuses", ad_statuses)
        if adset_statuses is not None:
            pulumi.set(__self__, "adset_statuses", adset_statuses)
        if campaign_statuses is not None:
            pulumi.set(__self__, "campaign_statuses", campaign_statuses)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_insights is not None:
            pulumi.set(__self__, "custom_insights", custom_insights)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if fetch_thumbnail_images is not None:
            pulumi.set(__self__, "fetch_thumbnail_images", fetch_thumbnail_images)
        if insights_job_timeout is not None:
            pulumi.set(__self__, "insights_job_timeout", insights_job_timeout)
        if insights_lookback_window is not None:
            pulumi.set(__self__, "insights_lookback_window", insights_lookback_window)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The value of the generated access token. From your Apps Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The Facebook Ad account ID(s) to pull data from. The Ad account ID number is in the account dropdown menu or in your browser's address bar of your <a href="https://adsmanager.facebook.com/adsmanager/">Meta Ads Manager</a>. See the <a href="https://www.facebook.com/business/help/1492627900875762">docs</a> for more information.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "account_ids", value)

    @property
    @pulumi.getter(name="actionBreakdownsAllowEmpty")
    def action_breakdowns_allow_empty(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows action_breakdowns to be an empty list. Default: true
        """
        return pulumi.get(self, "action_breakdowns_allow_empty")

    @action_breakdowns_allow_empty.setter
    def action_breakdowns_allow_empty(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "action_breakdowns_allow_empty", value)

    @property
    @pulumi.getter(name="adStatuses")
    def ad_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        """
        return pulumi.get(self, "ad_statuses")

    @ad_statuses.setter
    def ad_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ad_statuses", value)

    @property
    @pulumi.getter(name="adsetStatuses")
    def adset_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        """
        return pulumi.get(self, "adset_statuses")

    @adset_statuses.setter
    def adset_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "adset_statuses", value)

    @property
    @pulumi.getter(name="campaignStatuses")
    def campaign_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        """
        return pulumi.get(self, "campaign_statuses")

    @campaign_statuses.setter
    def campaign_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "campaign_statuses", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Id for your OAuth app
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for your OAuth app
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customInsights")
    def custom_insights(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceFacebookMarketingConfigurationCustomInsightArgs']]]]:
        """
        A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        """
        return pulumi.get(self, "custom_insights")

    @custom_insights.setter
    def custom_insights(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceFacebookMarketingConfigurationCustomInsightArgs']]]]):
        pulumi.set(self, "custom_insights", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="fetchThumbnailImages")
    def fetch_thumbnail_images(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to active if you want to fetch the thumbnail_url and store the result in thumbnail_data_url for each Ad Creative. Default: false
        """
        return pulumi.get(self, "fetch_thumbnail_images")

    @fetch_thumbnail_images.setter
    def fetch_thumbnail_images(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_thumbnail_images", value)

    @property
    @pulumi.getter(name="insightsJobTimeout")
    def insights_job_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Insights Job Timeout establishes the maximum amount of time (in minutes) of waiting for the report job to complete. When timeout is reached the job is considered failed and we are trying to request smaller amount of data by breaking the job to few smaller ones. If you definitely know that 60 minutes is not enough for your report to be processed then you can decrease the timeout value, so we start breaking job to smaller parts faster. Default: 60
        """
        return pulumi.get(self, "insights_job_timeout")

    @insights_job_timeout.setter
    def insights_job_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insights_job_timeout", value)

    @property
    @pulumi.getter(name="insightsLookbackWindow")
    def insights_lookback_window(self) -> Optional[pulumi.Input[int]]:
        """
        The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here. Default: 28
        """
        return pulumi.get(self, "insights_lookback_window")

    @insights_lookback_window.setter
    def insights_lookback_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insights_lookback_window", value)

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[pulumi.Input[int]]:
        """
        Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases. Default: 100
        """
        return pulumi.get(self, "page_size")

    @page_size.setter
    def page_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. If not set then all data will be replicated for usual streams and only last 2 years for insight streams.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceFacebookMarketingConfigurationCustomInsightArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 action_breakdowns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 action_report_time: Optional[pulumi.Input[str]] = None,
                 breakdowns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insights_job_timeout: Optional[pulumi.Input[int]] = None,
                 insights_lookback_window: Optional[pulumi.Input[int]] = None,
                 level: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 time_increment: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name value of insight
        :param pulumi.Input[Sequence[pulumi.Input[str]]] action_breakdowns: A list of chosen action_breakdowns for action_breakdowns
        :param pulumi.Input[str] action_report_time: Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd. must be one of ["conversion", "impression", "mixed"]; Default: "mixed"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] breakdowns: A list of chosen breakdowns for breakdowns
        :param pulumi.Input[str] end_date: The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fields: A list of chosen fields for fields parameter
        :param pulumi.Input[int] insights_job_timeout: The insights job timeout. Default: 60
        :param pulumi.Input[int] insights_lookback_window: The attribution window. Default: 28
        :param pulumi.Input[str] level: Chosen level for API. must be one of ["ad", "adset", "campaign", "account"]; Default: "ad"
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
        :param pulumi.Input[int] time_increment: Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). Default: 1
        """
        pulumi.set(__self__, "name", name)
        if action_breakdowns is not None:
            pulumi.set(__self__, "action_breakdowns", action_breakdowns)
        if action_report_time is not None:
            pulumi.set(__self__, "action_report_time", action_report_time)
        if breakdowns is not None:
            pulumi.set(__self__, "breakdowns", breakdowns)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if insights_job_timeout is not None:
            pulumi.set(__self__, "insights_job_timeout", insights_job_timeout)
        if insights_lookback_window is not None:
            pulumi.set(__self__, "insights_lookback_window", insights_lookback_window)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if time_increment is not None:
            pulumi.set(__self__, "time_increment", time_increment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name value of insight
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="actionBreakdowns")
    def action_breakdowns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of chosen action_breakdowns for action_breakdowns
        """
        return pulumi.get(self, "action_breakdowns")

    @action_breakdowns.setter
    def action_breakdowns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "action_breakdowns", value)

    @property
    @pulumi.getter(name="actionReportTime")
    def action_report_time(self) -> Optional[pulumi.Input[str]]:
        """
        Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd. must be one of ["conversion", "impression", "mixed"]; Default: "mixed"
        """
        return pulumi.get(self, "action_report_time")

    @action_report_time.setter
    def action_report_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_report_time", value)

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of chosen breakdowns for breakdowns
        """
        return pulumi.get(self, "breakdowns")

    @breakdowns.setter
    def breakdowns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "breakdowns", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of chosen fields for fields parameter
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="insightsJobTimeout")
    def insights_job_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The insights job timeout. Default: 60
        """
        return pulumi.get(self, "insights_job_timeout")

    @insights_job_timeout.setter
    def insights_job_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insights_job_timeout", value)

    @property
    @pulumi.getter(name="insightsLookbackWindow")
    def insights_lookback_window(self) -> Optional[pulumi.Input[int]]:
        """
        The attribution window. Default: 28
        """
        return pulumi.get(self, "insights_lookback_window")

    @insights_lookback_window.setter
    def insights_lookback_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "insights_lookback_window", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        Chosen level for API. must be one of ["ad", "adset", "campaign", "account"]; Default: "ad"
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="timeIncrement")
    def time_increment(self) -> Optional[pulumi.Input[int]]:
        """
        Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). Default: 1
        """
        return pulumi.get(self, "time_increment")

    @time_increment.setter
    def time_increment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_increment", value)


@pulumi.input_type
class SourceFakerConfigurationArgs:
    def __init__(__self__, *,
                 always_updated: Optional[pulumi.Input[bool]] = None,
                 count: Optional[pulumi.Input[int]] = None,
                 parallelism: Optional[pulumi.Input[int]] = None,
                 records_per_slice: Optional[pulumi.Input[int]] = None,
                 seed: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] always_updated: Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted. Default: true
        :param pulumi.Input[int] count: How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream. Default: 1000
        :param pulumi.Input[int] parallelism: How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source. Default: 4
        :param pulumi.Input[int] records_per_slice: How many fake records will be in each page (stream slice), before a state message is emitted?. Default: 1000
        :param pulumi.Input[int] seed: Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random). Default: -1
        """
        if always_updated is not None:
            pulumi.set(__self__, "always_updated", always_updated)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if records_per_slice is not None:
            pulumi.set(__self__, "records_per_slice", records_per_slice)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)

    @property
    @pulumi.getter(name="alwaysUpdated")
    def always_updated(self) -> Optional[pulumi.Input[bool]]:
        """
        Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted. Default: true
        """
        return pulumi.get(self, "always_updated")

    @always_updated.setter
    def always_updated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_updated", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream. Default: 1000
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source. Default: 4
        """
        return pulumi.get(self, "parallelism")

    @parallelism.setter
    def parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "parallelism", value)

    @property
    @pulumi.getter(name="recordsPerSlice")
    def records_per_slice(self) -> Optional[pulumi.Input[int]]:
        """
        How many fake records will be in each page (stream slice), before a state message is emitted?. Default: 1000
        """
        return pulumi.get(self, "records_per_slice")

    @records_per_slice.setter
    def records_per_slice(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "records_per_slice", value)

    @property
    @pulumi.getter
    def seed(self) -> Optional[pulumi.Input[int]]:
        """
        Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random). Default: -1
        """
        return pulumi.get(self, "seed")

    @seed.setter
    def seed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seed", value)


@pulumi.input_type
class SourceFaunaConfigurationArgs:
    def __init__(__self__, *,
                 secret: pulumi.Input[str],
                 collection: Optional[pulumi.Input['SourceFaunaConfigurationCollectionArgs']] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] secret: Fauna secret, used when authenticating with the database.
        :param pulumi.Input['SourceFaunaConfigurationCollectionArgs'] collection: Settings for the Fauna Collection.
        :param pulumi.Input[str] domain: Domain of Fauna to query. Defaults db.fauna.com. See <a href=https://docs.fauna.com/fauna/current/learn/understanding/region_groups#how-to-use-region-groups>the docs</a>. Default: "db.fauna.com"
        :param pulumi.Input[int] port: Endpoint port. Default: 443
        :param pulumi.Input[str] scheme: URL scheme. Default: "https"
        """
        pulumi.set(__self__, "secret", secret)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        Fauna secret, used when authenticating with the database.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input['SourceFaunaConfigurationCollectionArgs']]:
        """
        Settings for the Fauna Collection.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input['SourceFaunaConfigurationCollectionArgs']]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain of Fauna to query. Defaults db.fauna.com. See <a href=https://docs.fauna.com/fauna/current/learn/understanding/region_groups#how-to-use-region-groups>the docs</a>. Default: "db.fauna.com"
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Endpoint port. Default: 443
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        URL scheme. Default: "https"
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)


@pulumi.input_type
class SourceFaunaConfigurationCollectionArgs:
    def __init__(__self__, *,
                 deletions: pulumi.Input['SourceFaunaConfigurationCollectionDeletionsArgs'],
                 page_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['SourceFaunaConfigurationCollectionDeletionsArgs'] deletions: <b>This only applies to incremental syncs.</b> <br>
               Enabling deletion mode informs your destination of deleted documents.<br>
               Disabled - Leave this feature disabled, and ignore deleted documents.<br>
               Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.
        :param pulumi.Input[int] page_size: The page size used when reading documents from the database. The larger the page size, the faster the connector processes documents. However, if a page is too large, the connector may fail. <br>
               Choose your page size based on how large the documents are. <br>
               See <a href="https://docs.fauna.com/fauna/current/learn/understanding/types#page">the docs</a>.
               Default: 64
        """
        pulumi.set(__self__, "deletions", deletions)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)

    @property
    @pulumi.getter
    def deletions(self) -> pulumi.Input['SourceFaunaConfigurationCollectionDeletionsArgs']:
        """
        <b>This only applies to incremental syncs.</b> <br>
        Enabling deletion mode informs your destination of deleted documents.<br>
        Disabled - Leave this feature disabled, and ignore deleted documents.<br>
        Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.
        """
        return pulumi.get(self, "deletions")

    @deletions.setter
    def deletions(self, value: pulumi.Input['SourceFaunaConfigurationCollectionDeletionsArgs']):
        pulumi.set(self, "deletions", value)

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[pulumi.Input[int]]:
        """
        The page size used when reading documents from the database. The larger the page size, the faster the connector processes documents. However, if a page is too large, the connector may fail. <br>
        Choose your page size based on how large the documents are. <br>
        See <a href="https://docs.fauna.com/fauna/current/learn/understanding/types#page">the docs</a>.
        Default: 64
        """
        return pulumi.get(self, "page_size")

    @page_size.setter
    def page_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size", value)


@pulumi.input_type
class SourceFaunaConfigurationCollectionDeletionsArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['SourceFaunaConfigurationCollectionDeletionsDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['SourceFaunaConfigurationCollectionDeletionsEnabledArgs']] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['SourceFaunaConfigurationCollectionDeletionsDisabledArgs']]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['SourceFaunaConfigurationCollectionDeletionsDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['SourceFaunaConfigurationCollectionDeletionsEnabledArgs']]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['SourceFaunaConfigurationCollectionDeletionsEnabledArgs']]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SourceFaunaConfigurationCollectionDeletionsDisabledArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceFaunaConfigurationCollectionDeletionsEnabledArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] column: Name of the "deleted at" column. Default: "deleted_at"
        """
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the "deleted at" column. Default: "deleted_at"
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)


@pulumi.input_type
class SourceFileConfigurationArgs:
    def __init__(__self__, *,
                 dataset_name: pulumi.Input[str],
                 provider: pulumi.Input['SourceFileConfigurationProviderArgs'],
                 url: pulumi.Input[str],
                 format: Optional[pulumi.Input[str]] = None,
                 reader_options: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_name: The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
        :param pulumi.Input['SourceFileConfigurationProviderArgs'] provider: The storage Provider or Location of the file(s) which should be replicated.
        :param pulumi.Input[str] url: The URL path to access the file which should be replicated.
        :param pulumi.Input[str] format: The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs). must be one of ["csv", "json", "jsonl", "excel", "excel_binary", "fwf", "feather", "parquet", "yaml"]; Default: "csv"
        :param pulumi.Input[str] reader_options: This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
        """
        pulumi.set(__self__, "dataset_name", dataset_name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if reader_options is not None:
            pulumi.set(__self__, "reader_options", reader_options)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> pulumi.Input[str]:
        """
        The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
        """
        return pulumi.get(self, "dataset_name")

    @dataset_name.setter
    def dataset_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_name", value)

    @property
    @pulumi.getter
    def provider(self) -> pulumi.Input['SourceFileConfigurationProviderArgs']:
        """
        The storage Provider or Location of the file(s) which should be replicated.
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: pulumi.Input['SourceFileConfigurationProviderArgs']):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The URL path to access the file which should be replicated.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs). must be one of ["csv", "json", "jsonl", "excel", "excel_binary", "fwf", "feather", "parquet", "yaml"]; Default: "csv"
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="readerOptions")
    def reader_options(self) -> Optional[pulumi.Input[str]]:
        """
        This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
        """
        return pulumi.get(self, "reader_options")

    @reader_options.setter
    def reader_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reader_options", value)


@pulumi.input_type
class SourceFileConfigurationProviderArgs:
    def __init__(__self__, *,
                 az_blob_azure_blob_storage: Optional[pulumi.Input['SourceFileConfigurationProviderAzBlobAzureBlobStorageArgs']] = None,
                 gcs_google_cloud_storage: Optional[pulumi.Input['SourceFileConfigurationProviderGcsGoogleCloudStorageArgs']] = None,
                 https_public_web: Optional[pulumi.Input['SourceFileConfigurationProviderHttpsPublicWebArgs']] = None,
                 s3_amazon_web_services: Optional[pulumi.Input['SourceFileConfigurationProviderS3AmazonWebServicesArgs']] = None,
                 scp_secure_copy_protocol: Optional[pulumi.Input['SourceFileConfigurationProviderScpSecureCopyProtocolArgs']] = None,
                 sftp_secure_file_transfer_protocol: Optional[pulumi.Input['SourceFileConfigurationProviderSftpSecureFileTransferProtocolArgs']] = None,
                 ssh_secure_shell: Optional[pulumi.Input['SourceFileConfigurationProviderSshSecureShellArgs']] = None):
        if az_blob_azure_blob_storage is not None:
            pulumi.set(__self__, "az_blob_azure_blob_storage", az_blob_azure_blob_storage)
        if gcs_google_cloud_storage is not None:
            pulumi.set(__self__, "gcs_google_cloud_storage", gcs_google_cloud_storage)
        if https_public_web is not None:
            pulumi.set(__self__, "https_public_web", https_public_web)
        if s3_amazon_web_services is not None:
            pulumi.set(__self__, "s3_amazon_web_services", s3_amazon_web_services)
        if scp_secure_copy_protocol is not None:
            pulumi.set(__self__, "scp_secure_copy_protocol", scp_secure_copy_protocol)
        if sftp_secure_file_transfer_protocol is not None:
            pulumi.set(__self__, "sftp_secure_file_transfer_protocol", sftp_secure_file_transfer_protocol)
        if ssh_secure_shell is not None:
            pulumi.set(__self__, "ssh_secure_shell", ssh_secure_shell)

    @property
    @pulumi.getter(name="azBlobAzureBlobStorage")
    def az_blob_azure_blob_storage(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderAzBlobAzureBlobStorageArgs']]:
        return pulumi.get(self, "az_blob_azure_blob_storage")

    @az_blob_azure_blob_storage.setter
    def az_blob_azure_blob_storage(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderAzBlobAzureBlobStorageArgs']]):
        pulumi.set(self, "az_blob_azure_blob_storage", value)

    @property
    @pulumi.getter(name="gcsGoogleCloudStorage")
    def gcs_google_cloud_storage(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderGcsGoogleCloudStorageArgs']]:
        return pulumi.get(self, "gcs_google_cloud_storage")

    @gcs_google_cloud_storage.setter
    def gcs_google_cloud_storage(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderGcsGoogleCloudStorageArgs']]):
        pulumi.set(self, "gcs_google_cloud_storage", value)

    @property
    @pulumi.getter(name="httpsPublicWeb")
    def https_public_web(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderHttpsPublicWebArgs']]:
        return pulumi.get(self, "https_public_web")

    @https_public_web.setter
    def https_public_web(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderHttpsPublicWebArgs']]):
        pulumi.set(self, "https_public_web", value)

    @property
    @pulumi.getter(name="s3AmazonWebServices")
    def s3_amazon_web_services(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderS3AmazonWebServicesArgs']]:
        return pulumi.get(self, "s3_amazon_web_services")

    @s3_amazon_web_services.setter
    def s3_amazon_web_services(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderS3AmazonWebServicesArgs']]):
        pulumi.set(self, "s3_amazon_web_services", value)

    @property
    @pulumi.getter(name="scpSecureCopyProtocol")
    def scp_secure_copy_protocol(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderScpSecureCopyProtocolArgs']]:
        return pulumi.get(self, "scp_secure_copy_protocol")

    @scp_secure_copy_protocol.setter
    def scp_secure_copy_protocol(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderScpSecureCopyProtocolArgs']]):
        pulumi.set(self, "scp_secure_copy_protocol", value)

    @property
    @pulumi.getter(name="sftpSecureFileTransferProtocol")
    def sftp_secure_file_transfer_protocol(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderSftpSecureFileTransferProtocolArgs']]:
        return pulumi.get(self, "sftp_secure_file_transfer_protocol")

    @sftp_secure_file_transfer_protocol.setter
    def sftp_secure_file_transfer_protocol(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderSftpSecureFileTransferProtocolArgs']]):
        pulumi.set(self, "sftp_secure_file_transfer_protocol", value)

    @property
    @pulumi.getter(name="sshSecureShell")
    def ssh_secure_shell(self) -> Optional[pulumi.Input['SourceFileConfigurationProviderSshSecureShellArgs']]:
        return pulumi.get(self, "ssh_secure_shell")

    @ssh_secure_shell.setter
    def ssh_secure_shell(self, value: Optional[pulumi.Input['SourceFileConfigurationProviderSshSecureShellArgs']]):
        pulumi.set(self, "ssh_secure_shell", value)


@pulumi.input_type
class SourceFileConfigurationProviderAzBlobAzureBlobStorageArgs:
    def __init__(__self__, *,
                 storage_account: pulumi.Input[str],
                 sas_token: Optional[pulumi.Input[str]] = None,
                 shared_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_account: The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
        :param pulumi.Input[str] sas_token: To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
        :param pulumi.Input[str] shared_key: To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
        """
        pulumi.set(__self__, "storage_account", storage_account)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if shared_key is not None:
            pulumi.set(__self__, "shared_key", shared_key)

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> pulumi.Input[str]:
        """
        The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
        """
        return pulumi.get(self, "storage_account")

    @storage_account.setter
    def storage_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_account", value)

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[pulumi.Input[str]]:
        """
        To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sas_token", value)

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[pulumi.Input[str]]:
        """
        To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "shared_key")

    @shared_key.setter
    def shared_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_key", value)


@pulumi.input_type
class SourceFileConfigurationProviderGcsGoogleCloudStorageArgs:
    def __init__(__self__, *,
                 service_account_json: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_account_json: In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
        """
        if service_account_json is not None:
            pulumi.set(__self__, "service_account_json", service_account_json)

    @property
    @pulumi.getter(name="serviceAccountJson")
    def service_account_json(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "service_account_json")

    @service_account_json.setter
    def service_account_json(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_json", value)


@pulumi.input_type
class SourceFileConfigurationProviderHttpsPublicWebArgs:
    def __init__(__self__, *,
                 user_agent: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] user_agent: Add User-Agent to request. Default: false
        """
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Add User-Agent to request. Default: false
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_agent", value)


@pulumi.input_type
class SourceFileConfigurationProviderS3AmazonWebServicesArgs:
    def __init__(__self__, *,
                 aws_access_key_id: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_access_key_id: In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param pulumi.Input[str] aws_secret_access_key: In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key", value)


@pulumi.input_type
class SourceFileConfigurationProviderScpSecureCopyProtocolArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 user: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port: Default: "22"
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Default: "22"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class SourceFileConfigurationProviderSftpSecureFileTransferProtocolArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 user: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port: Default: "22"
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Default: "22"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class SourceFileConfigurationProviderSshSecureShellArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 user: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] port: Default: "22"
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Default: "22"
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class SourceFireboltConfigurationArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 database: pulumi.Input[str],
                 engine: pulumi.Input[str],
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account: Firebolt account to login.
        :param pulumi.Input[str] client_id: Firebolt service account ID.
        :param pulumi.Input[str] client_secret: Firebolt secret, corresponding to the service account ID.
        :param pulumi.Input[str] database: The database to connect to.
        :param pulumi.Input[str] engine: Engine name to connect to.
        :param pulumi.Input[str] host: The host name of your Firebolt database.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "engine", engine)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def account(self) -> pulumi.Input[str]:
        """
        Firebolt account to login.
        """
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[str]):
        pulumi.set(self, "account", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Firebolt service account ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Firebolt secret, corresponding to the service account ID.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The database to connect to.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def engine(self) -> pulumi.Input[str]:
        """
        Engine name to connect to.
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: pulumi.Input[str]):
        pulumi.set(self, "engine", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The host name of your Firebolt database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


@pulumi.input_type
class SourceFreshcallerConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 domain: pulumi.Input[str],
                 requests_per_minute: Optional[pulumi.Input[int]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 sync_lag_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] api_key: Freshcaller API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshcaller">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] domain: Used to construct Base URL for the Freshcaller APIs
        :param pulumi.Input[int] requests_per_minute: The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        :param pulumi.Input[str] start_date: UTC date and time. Any data created after this date will be replicated.
        :param pulumi.Input[int] sync_lag_minutes: Lag in minutes for each sync, i.e., at time T, data for the time range [prev_sync_time, T-30] will be fetched
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "domain", domain)
        if requests_per_minute is not None:
            pulumi.set(__self__, "requests_per_minute", requests_per_minute)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if sync_lag_minutes is not None:
            pulumi.set(__self__, "sync_lag_minutes", sync_lag_minutes)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Freshcaller API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshcaller">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Used to construct Base URL for the Freshcaller APIs
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        """
        return pulumi.get(self, "requests_per_minute")

    @requests_per_minute.setter
    def requests_per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requests_per_minute", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time. Any data created after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="syncLagMinutes")
    def sync_lag_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Lag in minutes for each sync, i.e., at time T, data for the time range [prev_sync_time, T-30] will be fetched
        """
        return pulumi.get(self, "sync_lag_minutes")

    @sync_lag_minutes.setter
    def sync_lag_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sync_lag_minutes", value)


@pulumi.input_type
class SourceFreshdeskConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 domain: pulumi.Input[str],
                 lookback_window_in_days: Optional[pulumi.Input[int]] = None,
                 requests_per_minute: Optional[pulumi.Input[int]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Freshdesk API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshdesk">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] domain: Freshdesk domain
        :param pulumi.Input[int] lookback_window_in_days: Number of days for lookback window for the stream Satisfaction Ratings. Default: 14
        :param pulumi.Input[int] requests_per_minute: The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        :param pulumi.Input[str] start_date: UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "domain", domain)
        if lookback_window_in_days is not None:
            pulumi.set(__self__, "lookback_window_in_days", lookback_window_in_days)
        if requests_per_minute is not None:
            pulumi.set(__self__, "requests_per_minute", requests_per_minute)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Freshdesk API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshdesk">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        Freshdesk domain
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="lookbackWindowInDays")
    def lookback_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days for lookback window for the stream Satisfaction Ratings. Default: 14
        """
        return pulumi.get(self, "lookback_window_in_days")

    @lookback_window_in_days.setter
    def lookback_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window_in_days", value)

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        """
        return pulumi.get(self, "requests_per_minute")

    @requests_per_minute.setter
    def requests_per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requests_per_minute", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceFreshsalesConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 domain_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Freshsales API Key. See <a href="https://crmsupport.freshworks.com/support/solutions/articles/50000002503-how-to-find-my-api-key-">here</a>. The key is case sensitive.
        :param pulumi.Input[str] domain_name: The Name of your Freshsales domain
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "domain_name", domain_name)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Freshsales API Key. See <a href="https://crmsupport.freshworks.com/support/solutions/articles/50000002503-how-to-find-my-api-key-">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        The Name of your Freshsales domain
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)


@pulumi.input_type
class SourceGainsightPxConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceGcsConfigurationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 service_account: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceGcsConfigurationStreamArgs']]],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of the GCS bucket where the file(s) exist.
        :param pulumi.Input[str] service_account: Enter your Google Cloud <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">service account key</a> in JSON format
        :param pulumi.Input[Sequence[pulumi.Input['SourceGcsConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href=https://docs.airbyte.com/cloud/core-concepts#stream>stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "streams", streams)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of the GCS bucket where the file(s) exist.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[str]:
        """
        Enter your Google Cloud <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">service account key</a> in JSON format
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceGcsConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href=https://docs.airbyte.com/cloud/core-concepts#stream>stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceGcsConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGcsConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceGcsConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 legacy_prefix: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceGcsConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] legacy_prefix: The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceGcsConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceGcsConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @legacy_prefix.setter
    def legacy_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legacy_prefix", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceGcsConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 csv_format: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatArgs']] = None):
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)


@pulumi.input_type
class SourceGcsConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 ignore_errors_on_fields_mismatch: Optional[pulumi.Input[bool]] = None,
                 inference_type: Optional[pulumi.Input[str]] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[bool] ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param pulumi.Input[str] inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @ignore_errors_on_fields_mismatch.setter
    def ignore_errors_on_fields_mismatch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors_on_fields_mismatch", value)

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[pulumi.Input[str]]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @inference_type.setter
    def inference_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_type", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceGetlagoConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 api_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Your API Key. See <a href="https://doc.getlago.com/docs/api/intro">here</a>.
        :param pulumi.Input[str] api_url: Your Lago API URL. Default: "https://api.getlago.com/api/v1"
        """
        pulumi.set(__self__, "api_key", api_key)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API Key. See <a href="https://doc.getlago.com/docs/api/intro">here</a>.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        Your Lago API URL. Default: "https://api.getlago.com/api/v1"
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)


@pulumi.input_type
class SourceGithubConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceGithubConfigurationCredentialsArgs'],
                 repositories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 api_url: Optional[pulumi.Input[str]] = None,
                 branch: Optional[pulumi.Input[str]] = None,
                 branches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repository: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceGithubConfigurationCredentialsArgs'] credentials: Choose how to authenticate to GitHub
        :param pulumi.Input[Sequence[pulumi.Input[str]]] repositories: List of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/a* for matching multiple repositories by pattern.
        :param pulumi.Input[str] api_url: Please enter your basic URL from self-hosted GitHub instance or leave it empty to use GitHub. Default: "https://api.github.com/"
        :param pulumi.Input[str] branch: (DEPRCATED) Space-delimited list of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] branches: List of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        :param pulumi.Input[str] repository: (DEPRCATED) Space-delimited list of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/airbyte airbytehq/another-repo` for multiple repositories.
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. If the date is not set, all data will be replicated.  For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the <a href="https://docs.airbyte.com/integrations/sources/github">docs</a> for more info
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "repositories", repositories)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceGithubConfigurationCredentialsArgs']:
        """
        Choose how to authenticate to GitHub
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceGithubConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def repositories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/a* for matching multiple repositories by pattern.
        """
        return pulumi.get(self, "repositories")

    @repositories.setter
    def repositories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "repositories", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        Please enter your basic URL from self-hosted GitHub instance or leave it empty to use GitHub. Default: "https://api.github.com/"
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        (DEPRCATED) Space-delimited list of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "branches", value)

    @property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[str]]:
        """
        (DEPRCATED) Space-delimited list of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/airbyte airbytehq/another-repo` for multiple repositories.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. If the date is not set, all data will be replicated.  For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the <a href="https://docs.airbyte.com/integrations/sources/github">docs</a> for more info
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGithubConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth: Optional[pulumi.Input['SourceGithubConfigurationCredentialsOAuthArgs']] = None,
                 personal_access_token: Optional[pulumi.Input['SourceGithubConfigurationCredentialsPersonalAccessTokenArgs']] = None):
        if o_auth is not None:
            pulumi.set(__self__, "o_auth", o_auth)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="oAuth")
    def o_auth(self) -> Optional[pulumi.Input['SourceGithubConfigurationCredentialsOAuthArgs']]:
        return pulumi.get(self, "o_auth")

    @o_auth.setter
    def o_auth(self, value: Optional[pulumi.Input['SourceGithubConfigurationCredentialsOAuthArgs']]):
        pulumi.set(self, "o_auth", value)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional[pulumi.Input['SourceGithubConfigurationCredentialsPersonalAccessTokenArgs']]:
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: Optional[pulumi.Input['SourceGithubConfigurationCredentialsPersonalAccessTokenArgs']]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class SourceGithubConfigurationCredentialsOAuthArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: OAuth access token
        :param pulumi.Input[str] client_id: OAuth Client Id
        :param pulumi.Input[str] client_secret: OAuth Client secret
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        OAuth access token
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client Id
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        OAuth Client secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceGithubConfigurationCredentialsPersonalAccessTokenArgs:
    def __init__(__self__, *,
                 personal_access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] personal_access_token: Log into GitHub and then generate a <a href="https://github.com/settings/tokens">personal access token</a>. To load balance your API quota consumption across multiple API tokens, input multiple tokens separated with ","
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> pulumi.Input[str]:
        """
        Log into GitHub and then generate a <a href="https://github.com/settings/tokens">personal access token</a>. To load balance your API quota consumption across multiple API tokens, input multiple tokens separated with ","
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "personal_access_token", value)


@pulumi.input_type
class SourceGitlabConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceGitlabConfigurationCredentialsArgs'],
                 api_url: Optional[pulumi.Input[str]] = None,
                 groups: Optional[pulumi.Input[str]] = None,
                 groups_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 projects: Optional[pulumi.Input[str]] = None,
                 projects_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_url: Please enter your basic URL from GitLab instance. Default: "gitlab.com"
        :param pulumi.Input[str] groups: [DEPRECATED] Space-delimited list of groups. e.g. airbyte.io.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups_lists: List of groups. e.g. airbyte.io.
        :param pulumi.Input[str] projects: [DEPRECATED] Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] projects_lists: Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. Optional. If not set, all data will be replicated. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if groups_lists is not None:
            pulumi.set(__self__, "groups_lists", groups_lists)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if projects_lists is not None:
            pulumi.set(__self__, "projects_lists", projects_lists)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceGitlabConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceGitlabConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        Please enter your basic URL from GitLab instance. Default: "gitlab.com"
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[str]]:
        """
        [DEPRECATED] Space-delimited list of groups. e.g. airbyte.io.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="groupsLists")
    def groups_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of groups. e.g. airbyte.io.
        """
        return pulumi.get(self, "groups_lists")

    @groups_lists.setter
    def groups_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups_lists", value)

    @property
    @pulumi.getter
    def projects(self) -> Optional[pulumi.Input[str]]:
        """
        [DEPRECATED] Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        """
        return pulumi.get(self, "projects")

    @projects.setter
    def projects(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "projects", value)

    @property
    @pulumi.getter(name="projectsLists")
    def projects_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        """
        return pulumi.get(self, "projects_lists")

    @projects_lists.setter
    def projects_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "projects_lists", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. Optional. If not set, all data will be replicated. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGitlabConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth20: Optional[pulumi.Input['SourceGitlabConfigurationCredentialsOAuth20Args']] = None,
                 private_token: Optional[pulumi.Input['SourceGitlabConfigurationCredentialsPrivateTokenArgs']] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if private_token is not None:
            pulumi.set(__self__, "private_token", private_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceGitlabConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceGitlabConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)

    @property
    @pulumi.getter(name="privateToken")
    def private_token(self) -> Optional[pulumi.Input['SourceGitlabConfigurationCredentialsPrivateTokenArgs']]:
        return pulumi.get(self, "private_token")

    @private_token.setter
    def private_token(self, value: Optional[pulumi.Input['SourceGitlabConfigurationCredentialsPrivateTokenArgs']]):
        pulumi.set(self, "private_token", value)


@pulumi.input_type
class SourceGitlabConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 token_expiry_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The API ID of the Gitlab developer application.
        :param pulumi.Input[str] client_secret: The API Secret the Gitlab developer application.
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access_token.
        :param pulumi.Input[str] token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The API ID of the Gitlab developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The API Secret the Gitlab developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> pulumi.Input[str]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")

    @token_expiry_date.setter
    def token_expiry_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_expiry_date", value)


@pulumi.input_type
class SourceGitlabConfigurationCredentialsPrivateTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Log into your Gitlab account and then generate a personal Access Token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Log into your Gitlab account and then generate a personal Access Token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceGlassfrogConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API key provided by Glassfrog
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API key provided by Glassfrog
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceGnewsConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 query: pulumi.Input[str],
                 country: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 ins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 language: Optional[pulumi.Input[str]] = None,
                 nullables: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sortby: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 top_headlines_query: Optional[pulumi.Input[str]] = None,
                 top_headlines_topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: API Key
        :param pulumi.Input[str] query: This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
                 quotation marks are used to search for articles with the exact same keyword sequence. 
                 For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
               - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
                 search. By default the space character acts as an AND operator, it is possible to replace the space character 
                 by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
               - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
                 It is important to note that this operator has a higher precedence than the AND operator. For example the 
                 query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
                 the keyword Microsoft
               - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
                 specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
                 For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
                 iPhone
        :param pulumi.Input[str] country: This parameter allows you to specify the country where the news articles returned by the API were published, the contents of the articles are not necessarily related to the specified country. You have to set as value the 2 letters code of the country you want to filter. must be one of ["au", "br", "ca", "cn", "eg", "fr", "de", "gr", "hk", "in", "ie", "il", "it", "jp", "nl", "no", "pk", "pe", "ph", "pt", "ro", "ru", "sg", "es", "se", "ch", "tw", "ua", "gb", "us"]
        :param pulumi.Input[str] end_date: This parameter allows you to filter the articles that have a publication date smaller than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ins: This parameter allows you to choose in which attributes the keywords are searched. The attributes that can be set are title, description and content. It is possible to combine several attributes.
        :param pulumi.Input[str] language: must be one of ["ar", "zh", "nl", "en", "fr", "de", "el", "he", "hi", "it", "ja", "ml", "mr", "no", "pt", "ro", "ru", "es", "sv", "ta", "te", "uk"]
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nullables: This parameter allows you to specify the attributes that you allow to return null values. The attributes that  can be set are title, description and content. It is possible to combine several attributes
        :param pulumi.Input[str] sortby: This parameter allows you to choose with which type of sorting the articles should be returned. Two values  are possible:
                 - publishedAt = sort by publication date, the articles with the most recent publication date are returned first
                 - relevance = sort by best match to keywords, the articles with the best match are returned first
               must be one of ["publishedAt", "relevance"]
        :param pulumi.Input[str] start_date: This parameter allows you to filter the articles that have a publication date greater than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        :param pulumi.Input[str] top_headlines_query: This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
                 quotation marks are used to search for articles with the exact same keyword sequence. 
                 For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
               - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
                 search. By default the space character acts as an AND operator, it is possible to replace the space character 
                 by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
               - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
                 It is important to note that this operator has a higher precedence than the AND operator. For example the 
                 query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
                 the keyword Microsoft
               - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
                 specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
                 For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
                 iPhone
        :param pulumi.Input[str] top_headlines_topic: This parameter allows you to change the category for the request. must be one of ["breaking-news", "world", "nation", "business", "technology", "entertainment", "sports", "science", "health"]
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query", query)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if nullables is not None:
            pulumi.set(__self__, "nullables", nullables)
        if sortby is not None:
            pulumi.set(__self__, "sortby", sortby)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if top_headlines_query is not None:
            pulumi.set(__self__, "top_headlines_query", top_headlines_query)
        if top_headlines_topic is not None:
            pulumi.set(__self__, "top_headlines_topic", top_headlines_topic)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
          quotation marks are used to search for articles with the exact same keyword sequence. 
          For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
        - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
          search. By default the space character acts as an AND operator, it is possible to replace the space character 
          by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
        - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
          It is important to note that this operator has a higher precedence than the AND operator. For example the 
          query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
          the keyword Microsoft
        - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
          specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
          For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
          iPhone
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter allows you to specify the country where the news articles returned by the API were published, the contents of the articles are not necessarily related to the specified country. You have to set as value the 2 letters code of the country you want to filter. must be one of ["au", "br", "ca", "cn", "eg", "fr", "de", "gr", "hk", "in", "ie", "il", "it", "jp", "nl", "no", "pk", "pe", "ph", "pt", "ro", "ru", "sg", "es", "se", "ch", "tw", "ua", "gb", "us"]
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter allows you to filter the articles that have a publication date smaller than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def ins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        This parameter allows you to choose in which attributes the keywords are searched. The attributes that can be set are title, description and content. It is possible to combine several attributes.
        """
        return pulumi.get(self, "ins")

    @ins.setter
    def ins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ins", value)

    @property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["ar", "zh", "nl", "en", "fr", "de", "el", "he", "hi", "it", "ja", "ml", "mr", "no", "pt", "ro", "ru", "es", "sv", "ta", "te", "uk"]
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language", value)

    @property
    @pulumi.getter
    def nullables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        This parameter allows you to specify the attributes that you allow to return null values. The attributes that  can be set are title, description and content. It is possible to combine several attributes
        """
        return pulumi.get(self, "nullables")

    @nullables.setter
    def nullables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nullables", value)

    @property
    @pulumi.getter
    def sortby(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter allows you to choose with which type of sorting the articles should be returned. Two values  are possible:
          - publishedAt = sort by publication date, the articles with the most recent publication date are returned first
          - relevance = sort by best match to keywords, the articles with the best match are returned first
        must be one of ["publishedAt", "relevance"]
        """
        return pulumi.get(self, "sortby")

    @sortby.setter
    def sortby(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sortby", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter allows you to filter the articles that have a publication date greater than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="topHeadlinesQuery")
    def top_headlines_query(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
          quotation marks are used to search for articles with the exact same keyword sequence. 
          For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
        - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
          search. By default the space character acts as an AND operator, it is possible to replace the space character 
          by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
        - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
          It is important to note that this operator has a higher precedence than the AND operator. For example the 
          query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
          the keyword Microsoft
        - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
          specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
          For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
          iPhone
        """
        return pulumi.get(self, "top_headlines_query")

    @top_headlines_query.setter
    def top_headlines_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "top_headlines_query", value)

    @property
    @pulumi.getter(name="topHeadlinesTopic")
    def top_headlines_topic(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter allows you to change the category for the request. must be one of ["breaking-news", "world", "nation", "business", "technology", "entertainment", "sports", "science", "health"]
        """
        return pulumi.get(self, "top_headlines_topic")

    @top_headlines_topic.setter
    def top_headlines_topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "top_headlines_topic", value)


@pulumi.input_type
class SourceGoogleAdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceGoogleAdsConfigurationCredentialsArgs'],
                 conversion_window_days: Optional[pulumi.Input[int]] = None,
                 custom_queries_arrays: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAdsConfigurationCustomQueriesArrayArgs']]]] = None,
                 customer_id: Optional[pulumi.Input[str]] = None,
                 customer_status_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] conversion_window_days: A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see <a href="https://support.google.com/google-ads/answer/3123169?hl=en">Google's documentation</a>. Default: 14
        :param pulumi.Input[str] customer_id: Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] customer_status_filters: A list of customer statuses to filter on. For detailed info about what each status mean refer to Google Ads <a href="https://developers.google.com/google-ads/api/reference/rpc/v15/CustomerStatusEnum.CustomerStatus">documentation</a>.
        :param pulumi.Input[str] end_date: UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated. (Default value of today is used if not set)
        :param pulumi.Input[str] start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. (Default value of two years ago is used if not set)
        """
        pulumi.set(__self__, "credentials", credentials)
        if conversion_window_days is not None:
            pulumi.set(__self__, "conversion_window_days", conversion_window_days)
        if custom_queries_arrays is not None:
            pulumi.set(__self__, "custom_queries_arrays", custom_queries_arrays)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)
        if customer_status_filters is not None:
            pulumi.set(__self__, "customer_status_filters", customer_status_filters)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceGoogleAdsConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceGoogleAdsConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="conversionWindowDays")
    def conversion_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see <a href="https://support.google.com/google-ads/answer/3123169?hl=en">Google's documentation</a>. Default: 14
        """
        return pulumi.get(self, "conversion_window_days")

    @conversion_window_days.setter
    def conversion_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "conversion_window_days", value)

    @property
    @pulumi.getter(name="customQueriesArrays")
    def custom_queries_arrays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAdsConfigurationCustomQueriesArrayArgs']]]]:
        return pulumi.get(self, "custom_queries_arrays")

    @custom_queries_arrays.setter
    def custom_queries_arrays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAdsConfigurationCustomQueriesArrayArgs']]]]):
        pulumi.set(self, "custom_queries_arrays", value)

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "customer_id")

    @customer_id.setter
    def customer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_id", value)

    @property
    @pulumi.getter(name="customerStatusFilters")
    def customer_status_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of customer statuses to filter on. For detailed info about what each status mean refer to Google Ads <a href="https://developers.google.com/google-ads/api/reference/rpc/v15/CustomerStatusEnum.CustomerStatus">documentation</a>.
        """
        return pulumi.get(self, "customer_status_filters")

    @customer_status_filters.setter
    def customer_status_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "customer_status_filters", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated. (Default value of today is used if not set)
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. (Default value of two years ago is used if not set)
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGoogleAdsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 developer_token: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param pulumi.Input[str] client_secret: The Client Secret of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param pulumi.Input[str] developer_token: The Developer Token granted by Google to use their APIs. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param pulumi.Input[str] refresh_token: The token used to obtain a new Access Token. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param pulumi.Input[str] access_token: The Access Token for making authenticated requests. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "developer_token", developer_token)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> pulumi.Input[str]:
        """
        The Developer Token granted by Google to use their APIs. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "developer_token")

    @developer_token.setter
    def developer_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "developer_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token used to obtain a new Access Token. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        The Access Token for making authenticated requests. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceGoogleAdsConfigurationCustomQueriesArrayArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: A custom defined GAQL query for building the report. Avoid including the segments.date field; wherever possible, Airbyte will automatically include it for incremental syncs. For more information, refer to <a href="https://developers.google.com/google-ads/api/fields/v11/overview_query_builder">Google's documentation</a>.
        :param pulumi.Input[str] table_name: The table name in your destination database for the chosen query.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        A custom defined GAQL query for building the report. Avoid including the segments.date field; wherever possible, Airbyte will automatically include it for incremental syncs. For more information, refer to <a href="https://developers.google.com/google-ads/api/fields/v11/overview_query_builder">Google's documentation</a>.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The table name in your destination database for the chosen query.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationArgs:
    def __init__(__self__, *,
                 property_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 convert_conversions_event: Optional[pulumi.Input[bool]] = None,
                 credentials: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs']] = None,
                 custom_reports_arrays: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs']]]] = None,
                 date_ranges_start_date: Optional[pulumi.Input[str]] = None,
                 keep_empty_rows: Optional[pulumi.Input[bool]] = None,
                 window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_ids: A list of your Property IDs. The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id#what_is_my_property_id'>Google Analytics documentation</a> to locate your property ID.
        :param pulumi.Input[bool] convert_conversions_event: Enables conversion of `conversions:*` event metrics from integers to floats. This is beneficial for preventing data rounding when the API returns float values for any `conversions:*` fields. Default: false
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs'] credentials: Credentials for the service
        :param pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs']]] custom_reports_arrays: You can add your Custom Analytics report by creating one.
        :param pulumi.Input[str] date_ranges_start_date: The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
        :param pulumi.Input[bool] keep_empty_rows: If false, each row with all metrics equal to 0 will not be returned. If true, these rows will be returned if they are not separately removed by a filter. More information is available in <a href="https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties/runReport#request-body">the documentation</a>. Default: false
        :param pulumi.Input[int] window_in_days: The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api">the documentation</a>. Default: 1
        """
        pulumi.set(__self__, "property_ids", property_ids)
        if convert_conversions_event is not None:
            pulumi.set(__self__, "convert_conversions_event", convert_conversions_event)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_reports_arrays is not None:
            pulumi.set(__self__, "custom_reports_arrays", custom_reports_arrays)
        if date_ranges_start_date is not None:
            pulumi.set(__self__, "date_ranges_start_date", date_ranges_start_date)
        if keep_empty_rows is not None:
            pulumi.set(__self__, "keep_empty_rows", keep_empty_rows)
        if window_in_days is not None:
            pulumi.set(__self__, "window_in_days", window_in_days)

    @property
    @pulumi.getter(name="propertyIds")
    def property_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of your Property IDs. The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id#what_is_my_property_id'>Google Analytics documentation</a> to locate your property ID.
        """
        return pulumi.get(self, "property_ids")

    @property_ids.setter
    def property_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "property_ids", value)

    @property
    @pulumi.getter(name="convertConversionsEvent")
    def convert_conversions_event(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables conversion of `conversions:*` event metrics from integers to floats. This is beneficial for preventing data rounding when the API returns float values for any `conversions:*` fields. Default: false
        """
        return pulumi.get(self, "convert_conversions_event")

    @convert_conversions_event.setter
    def convert_conversions_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "convert_conversions_event", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs']]:
        """
        Credentials for the service
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="customReportsArrays")
    def custom_reports_arrays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs']]]]:
        """
        You can add your Custom Analytics report by creating one.
        """
        return pulumi.get(self, "custom_reports_arrays")

    @custom_reports_arrays.setter
    def custom_reports_arrays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs']]]]):
        pulumi.set(self, "custom_reports_arrays", value)

    @property
    @pulumi.getter(name="dateRangesStartDate")
    def date_ranges_start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
        """
        return pulumi.get(self, "date_ranges_start_date")

    @date_ranges_start_date.setter
    def date_ranges_start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_ranges_start_date", value)

    @property
    @pulumi.getter(name="keepEmptyRows")
    def keep_empty_rows(self) -> Optional[pulumi.Input[bool]]:
        """
        If false, each row with all metrics equal to 0 will not be returned. If true, these rows will be returned if they are not separately removed by a filter. More information is available in <a href="https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties/runReport#request-body">the documentation</a>. Default: false
        """
        return pulumi.get(self, "keep_empty_rows")

    @keep_empty_rows.setter
    def keep_empty_rows(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_empty_rows", value)

    @property
    @pulumi.getter(name="windowInDays")
    def window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api">the documentation</a>. Default: 1
        """
        return pulumi.get(self, "window_in_days")

    @window_in_days.setter
    def window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_in_days", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_google_oauth: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauthArgs']] = None,
                 service_account_key_authentication: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthenticationArgs']] = None):
        if authenticate_via_google_oauth is not None:
            pulumi.set(__self__, "authenticate_via_google_oauth", authenticate_via_google_oauth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaGoogleOauth")
    def authenticate_via_google_oauth(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauthArgs']]:
        return pulumi.get(self, "authenticate_via_google_oauth")

    @authenticate_via_google_oauth.setter
    def authenticate_via_google_oauth(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauthArgs']]):
        pulumi.set(self, "authenticate_via_google_oauth", value)

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]:
        return pulumi.get(self, "service_account_key_authentication")

    @service_account_key_authentication.setter
    def service_account_key_authentication(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]):
        pulumi.set(self, "service_account_key_authentication", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Google Analytics developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Google Analytics developer application.
        :param pulumi.Input[str] refresh_token: The token for obtaining a new access token.
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Google Analytics developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Google Analytics developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token for obtaining a new access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthenticationArgs:
    def __init__(__self__, *,
                 credentials_json: pulumi.Input[str]):
        """
        :param pulumi.Input[str] credentials_json: The JSON key linked to the service account used for authorization. For steps on obtaining this key, refer to <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api/#setup-guide">the setup guide</a>.
        """
        pulumi.set(__self__, "credentials_json", credentials_json)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> pulumi.Input[str]:
        """
        The JSON key linked to the service account used for authorization. For steps on obtaining this key, refer to <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api/#setup-guide">the setup guide</a>.
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_json", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 metrics: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 cohort_spec: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs']] = None,
                 dimension_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs']] = None,
                 metric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: A list of dimensions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metrics: A list of metrics.
        :param pulumi.Input[str] name: The name of the custom report, this name would be used as stream name.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs'] cohort_spec: Cohort reports creates a time series of user retention for the cohort.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs'] dimension_filter: Dimensions filter
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs'] metric_filter: Metrics filter
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "name", name)
        if cohort_spec is not None:
            pulumi.set(__self__, "cohort_spec", cohort_spec)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if metric_filter is not None:
            pulumi.set(__self__, "metric_filter", metric_filter)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of dimensions.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of metrics.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the custom report, this name would be used as stream name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="cohortSpec")
    def cohort_spec(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs']]:
        """
        Cohort reports creates a time series of user retention for the cohort.
        """
        return pulumi.get(self, "cohort_spec")

    @cohort_spec.setter
    def cohort_spec(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs']]):
        pulumi.set(self, "cohort_spec", value)

    @property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs']]:
        """
        Dimensions filter
        """
        return pulumi.get(self, "dimension_filter")

    @dimension_filter.setter
    def dimension_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs']]):
        pulumi.set(self, "dimension_filter", value)

    @property
    @pulumi.getter(name="metricFilter")
    def metric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs']]:
        """
        Metrics filter
        """
        return pulumi.get(self, "metric_filter")

    @metric_filter.setter
    def metric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs']]):
        pulumi.set(self, "metric_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabledArgs']] = None,
                 enabled: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledArgs']] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabledArgs']]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledArgs']]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledArgs']]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabledArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledArgs:
    def __init__(__self__, *,
                 cohort_report_settings: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs']] = None,
                 cohorts: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortArgs']]]] = None,
                 cohorts_range: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRangeArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs'] cohort_report_settings: Optional settings for a cohort report.
        """
        if cohort_report_settings is not None:
            pulumi.set(__self__, "cohort_report_settings", cohort_report_settings)
        if cohorts is not None:
            pulumi.set(__self__, "cohorts", cohorts)
        if cohorts_range is not None:
            pulumi.set(__self__, "cohorts_range", cohorts_range)

    @property
    @pulumi.getter(name="cohortReportSettings")
    def cohort_report_settings(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs']]:
        """
        Optional settings for a cohort report.
        """
        return pulumi.get(self, "cohort_report_settings")

    @cohort_report_settings.setter
    def cohort_report_settings(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs']]):
        pulumi.set(self, "cohort_report_settings", value)

    @property
    @pulumi.getter
    def cohorts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortArgs']]]]:
        return pulumi.get(self, "cohorts")

    @cohorts.setter
    def cohorts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortArgs']]]]):
        pulumi.set(self, "cohorts", value)

    @property
    @pulumi.getter(name="cohortsRange")
    def cohorts_range(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRangeArgs']]:
        return pulumi.get(self, "cohorts_range")

    @cohorts_range.setter
    def cohorts_range(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRangeArgs']]):
        pulumi.set(self, "cohorts_range", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortArgs:
    def __init__(__self__, *,
                 date_range: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRangeArgs'],
                 dimension: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dimension: Dimension used by the cohort. Required and only supports `firstSessionDate`. must be one of ["firstSessionDate"]
        :param pulumi.Input[str] name: Assigns a name to this cohort. If not set, cohorts are named by their zero based index cohort_0, cohort_1, etc.
        """
        pulumi.set(__self__, "date_range", date_range)
        pulumi.set(__self__, "dimension", dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRangeArgs']:
        return pulumi.get(self, "date_range")

    @date_range.setter
    def date_range(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRangeArgs']):
        pulumi.set(self, "date_range", value)

    @property
    @pulumi.getter
    def dimension(self) -> pulumi.Input[str]:
        """
        Dimension used by the cohort. Required and only supports `firstSessionDate`. must be one of ["firstSessionDate"]
        """
        return pulumi.get(self, "dimension")

    @dimension.setter
    def dimension(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Assigns a name to this cohort. If not set, cohorts are named by their zero based index cohort_0, cohort_1, etc.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRangeArgs:
    def __init__(__self__, *,
                 end_date: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs:
    def __init__(__self__, *,
                 accumulate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] accumulate: If true, accumulates the result from first touch day to the end day
        """
        if accumulate is not None:
            pulumi.set(__self__, "accumulate", accumulate)

    @property
    @pulumi.getter
    def accumulate(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, accumulates the result from first touch day to the end day
        """
        return pulumi.get(self, "accumulate")

    @accumulate.setter
    def accumulate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accumulate", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRangeArgs:
    def __init__(__self__, *,
                 end_offset: pulumi.Input[int],
                 granularity: pulumi.Input[str],
                 start_offset: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] end_offset: Specifies the end date of the extended reporting date range for a cohort report.
        :param pulumi.Input[str] granularity: The granularity used to interpret the startOffset and endOffset for the extended reporting date range for a cohort report. must be one of ["GRANULARITY_UNSPECIFIED", "DAILY", "WEEKLY", "MONTHLY"]
        :param pulumi.Input[int] start_offset: Specifies the start date of the extended reporting date range for a cohort report.
        """
        pulumi.set(__self__, "end_offset", end_offset)
        pulumi.set(__self__, "granularity", granularity)
        if start_offset is not None:
            pulumi.set(__self__, "start_offset", start_offset)

    @property
    @pulumi.getter(name="endOffset")
    def end_offset(self) -> pulumi.Input[int]:
        """
        Specifies the end date of the extended reporting date range for a cohort report.
        """
        return pulumi.get(self, "end_offset")

    @end_offset.setter
    def end_offset(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_offset", value)

    @property
    @pulumi.getter
    def granularity(self) -> pulumi.Input[str]:
        """
        The granularity used to interpret the startOffset and endOffset for the extended reporting date range for a cohort report. must be one of ["GRANULARITY_UNSPECIFIED", "DAILY", "WEEKLY", "MONTHLY"]
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input[str]):
        pulumi.set(self, "granularity", value)

    @property
    @pulumi.getter(name="startOffset")
    def start_offset(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the start date of the extended reporting date range for a cohort report.
        """
        return pulumi.get(self, "start_offset")

    @start_offset.setter
    def start_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_offset", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs:
    def __init__(__self__, *,
                 and_group: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs']] = None,
                 filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs']] = None,
                 not_expression: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs']] = None,
                 or_group: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs'] and_group: The FilterExpressions in andGroup have an AND relationship.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs'] filter: A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all dimensions.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs'] not_expression: The FilterExpression is NOT of notExpression.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs'] or_group: The FilterExpressions in orGroup have an OR relationship.
        """
        if and_group is not None:
            pulumi.set(__self__, "and_group", and_group)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if not_expression is not None:
            pulumi.set(__self__, "not_expression", not_expression)
        if or_group is not None:
            pulumi.set(__self__, "or_group", or_group)

    @property
    @pulumi.getter(name="andGroup")
    def and_group(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs']]:
        """
        The FilterExpressions in andGroup have an AND relationship.
        """
        return pulumi.get(self, "and_group")

    @and_group.setter
    def and_group(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs']]):
        pulumi.set(self, "and_group", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs']]:
        """
        A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all dimensions.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs']]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="notExpression")
    def not_expression(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs']]:
        """
        The FilterExpression is NOT of notExpression.
        """
        return pulumi.get(self, "not_expression")

    @not_expression.setter
    def not_expression(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs']]):
        pulumi.set(self, "not_expression", value)

    @property
    @pulumi.getter(name="orGroup")
    def or_group(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs']]:
        """
        The FilterExpressions in orGroup have an OR relationship.
        """
        return pulumi.get(self, "or_group")

    @or_group.setter
    def or_group(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs']]):
        pulumi.set(self, "or_group", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionArgs']]]):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionArgs']]]:
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionArgs']]]):
        pulumi.set(self, "expressions", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionArgs']] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionArgs']]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionArgs']]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionArgs']]]):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionArgs']]]:
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionArgs']]]):
        pulumi.set(self, "expressions", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs:
    def __init__(__self__, *,
                 and_group: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs']] = None,
                 filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs']] = None,
                 not_expression: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs']] = None,
                 or_group: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs'] and_group: The FilterExpressions in andGroup have an AND relationship.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs'] filter: A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all metrics.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs'] not_expression: The FilterExpression is NOT of notExpression.
        :param pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs'] or_group: The FilterExpressions in orGroup have an OR relationship.
        """
        if and_group is not None:
            pulumi.set(__self__, "and_group", and_group)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if not_expression is not None:
            pulumi.set(__self__, "not_expression", not_expression)
        if or_group is not None:
            pulumi.set(__self__, "or_group", or_group)

    @property
    @pulumi.getter(name="andGroup")
    def and_group(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs']]:
        """
        The FilterExpressions in andGroup have an AND relationship.
        """
        return pulumi.get(self, "and_group")

    @and_group.setter
    def and_group(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs']]):
        pulumi.set(self, "and_group", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs']]:
        """
        A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all metrics.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs']]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="notExpression")
    def not_expression(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs']]:
        """
        The FilterExpression is NOT of notExpression.
        """
        return pulumi.get(self, "not_expression")

    @not_expression.setter
    def not_expression(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs']]):
        pulumi.set(self, "not_expression", value)

    @property
    @pulumi.getter(name="orGroup")
    def or_group(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs']]:
        """
        The FilterExpressions in orGroup have an OR relationship.
        """
        return pulumi.get(self, "or_group")

    @or_group.setter
    def or_group(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs']]):
        pulumi.set(self, "or_group", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionArgs']]]):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionArgs']]]:
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionArgs']]]):
        pulumi.set(self, "expressions", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionArgs']] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionArgs']]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionArgs']]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs:
    def __init__(__self__, *,
                 expressions: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionArgs']]]):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionArgs']]]:
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: pulumi.Input[Sequence[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionArgs']]]):
        pulumi.set(self, "expressions", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 filter: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterArgs']):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterArgs']:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterArgs']):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterArgs:
    def __init__(__self__, *,
                 between_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterArgs']] = None,
                 in_list_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilterArgs']] = None,
                 numeric_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterArgs']] = None,
                 string_filter: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilterArgs']] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterArgs']]:
        return pulumi.get(self, "between_filter")

    @between_filter.setter
    def between_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterArgs']]):
        pulumi.set(self, "between_filter", value)

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilterArgs']]:
        return pulumi.get(self, "in_list_filter")

    @in_list_filter.setter
    def in_list_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilterArgs']]):
        pulumi.set(self, "in_list_filter", value)

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterArgs']]:
        return pulumi.get(self, "numeric_filter")

    @numeric_filter.setter
    def numeric_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterArgs']]):
        pulumi.set(self, "numeric_filter", value)

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilterArgs']]:
        return pulumi.get(self, "string_filter")

    @string_filter.setter
    def string_filter(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilterArgs']]):
        pulumi.set(self, "string_filter", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterArgs:
    def __init__(__self__, *,
                 from_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueArgs'],
                 to_value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueArgs']:
        return pulumi.get(self, "from_value")

    @from_value.setter
    def from_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueArgs']):
        pulumi.set(self, "from_value", value)

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueArgs']:
        return pulumi.get(self, "to_value")

    @to_value.setter
    def to_value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueArgs']):
        pulumi.set(self, "to_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilterArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 case_sensitive: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterArgs:
    def __init__(__self__, *,
                 operations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "operations", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueArgs']):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueArgs:
    def __init__(__self__, *,
                 double_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs']] = None,
                 int64_value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs']] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs']]:
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs']]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs']]:
        return pulumi.get(self, "int64_value")

    @int64_value.setter
    def int64_value(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs']]):
        pulumi.set(self, "int64_value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[float]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64ValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilterArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 match_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "match_types")

    @match_types.setter
    def match_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "match_types", value)


@pulumi.input_type
class SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 view_id: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs']] = None,
                 custom_reports: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] start_date: The date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        :param pulumi.Input[str] view_id: The ID for the Google Analytics View you want to fetch data from. This can be found from the <a href="https://ga-dev-tools.appspot.com/account-explorer/">Google Analytics Account Explorer</a>.
        :param pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs'] credentials: Credentials for the service
        :param pulumi.Input[str] custom_reports: A JSON array describing the custom reports you want to sync from Google Analytics. See <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4#data-processing-latency">the docs</a> for more information about the exact format you can use to fill out this field.
        :param pulumi.Input[str] end_date: The date in the format YYYY-MM-DD. Any data after this date will not be replicated.
        :param pulumi.Input[int] window_in_days: The time increment used by the connector when requesting data from the Google Analytics API. More information is available in the <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4/#sampling-in-reports">the docs</a>. The bigger this value is, the faster the sync will be, but the more likely that sampling will be applied to your data, potentially causing inaccuracies in the returned results. We recommend setting this to 1 unless you have a hard requirement to make the sync faster at the expense of accuracy. The minimum allowed value for this field is 1, and the maximum is 364. . Default: 1
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "view_id", view_id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if window_in_days is not None:
            pulumi.set(__self__, "window_in_days", window_in_days)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> pulumi.Input[str]:
        """
        The ID for the Google Analytics View you want to fetch data from. This can be found from the <a href="https://ga-dev-tools.appspot.com/account-explorer/">Google Analytics Account Explorer</a>.
        """
        return pulumi.get(self, "view_id")

    @view_id.setter
    def view_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_id", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs']]:
        """
        Credentials for the service
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON array describing the custom reports you want to sync from Google Analytics. See <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4#data-processing-latency">the docs</a> for more information about the exact format you can use to fill out this field.
        """
        return pulumi.get(self, "custom_reports")

    @custom_reports.setter
    def custom_reports(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_reports", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date in the format YYYY-MM-DD. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="windowInDays")
    def window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The time increment used by the connector when requesting data from the Google Analytics API. More information is available in the <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4/#sampling-in-reports">the docs</a>. The bigger this value is, the faster the sync will be, but the more likely that sampling will be applied to your data, potentially causing inaccuracies in the returned results. We recommend setting this to 1 unless you have a hard requirement to make the sync faster at the expense of accuracy. The minimum allowed value for this field is 1, and the maximum is 364. . Default: 1
        """
        return pulumi.get(self, "window_in_days")

    @window_in_days.setter
    def window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_in_days", value)


@pulumi.input_type
class SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 service_account_key_authentication: Optional[pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthenticationArgs']] = None):
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional[pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]:
        return pulumi.get(self, "service_account_key_authentication")

    @service_account_key_authentication.setter
    def service_account_key_authentication(self, value: Optional[pulumi.Input['SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]):
        pulumi.set(self, "service_account_key_authentication", value)


@pulumi.input_type
class SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthenticationArgs:
    def __init__(__self__, *,
                 credentials_json: pulumi.Input[str]):
        """
        :param pulumi.Input[str] credentials_json: The JSON key of the service account to use for authorization
        """
        pulumi.set(__self__, "credentials_json", credentials_json)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> pulumi.Input[str]:
        """
        The JSON key of the service account to use for authorization
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_json", value)


@pulumi.input_type
class SourceGoogleDirectoryConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsArgs'] credentials: Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports <a href="https://developers.google.com/identity/protocols/oauth2#webserver" target="_blank">Web server application</a> and <a href="https://developers.google.com/identity/protocols/oauth2#serviceaccount" target="_blank">Service accounts</a> scenarios.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsArgs']]:
        """
        Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports <a href="https://developers.google.com/identity/protocols/oauth2#webserver" target="_blank">Web server application</a> and <a href="https://developers.google.com/identity/protocols/oauth2#serviceaccount" target="_blank">Service accounts</a> scenarios.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceGoogleDirectoryConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 service_account_key: Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs']] = None,
                 sign_in_via_google_o_auth: Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs'] service_account_key: For these scenario user should obtain service account's credentials from the Google API Console and provide delegated email.
        :param pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs'] sign_in_via_google_o_auth: For these scenario user only needs to give permission to read Google Directory data.
        """
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if sign_in_via_google_o_auth is not None:
            pulumi.set(__self__, "sign_in_via_google_o_auth", sign_in_via_google_o_auth)

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs']]:
        """
        For these scenario user should obtain service account's credentials from the Google API Console and provide delegated email.
        """
        return pulumi.get(self, "service_account_key")

    @service_account_key.setter
    def service_account_key(self, value: Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs']]):
        pulumi.set(self, "service_account_key", value)

    @property
    @pulumi.getter(name="signInViaGoogleOAuth")
    def sign_in_via_google_o_auth(self) -> Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs']]:
        """
        For these scenario user only needs to give permission to read Google Directory data.
        """
        return pulumi.get(self, "sign_in_via_google_o_auth")

    @sign_in_via_google_o_auth.setter
    def sign_in_via_google_o_auth(self, value: Optional[pulumi.Input['SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs']]):
        pulumi.set(self, "sign_in_via_google_o_auth", value)


@pulumi.input_type
class SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs:
    def __init__(__self__, *,
                 credentials_json: pulumi.Input[str],
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] credentials_json: The contents of the JSON service account key. See the <a href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation">docs</a> for more information on how to generate this key.
        :param pulumi.Input[str] email: The email of the user, which has permissions to access the Google Workspace Admin APIs.
        """
        pulumi.set(__self__, "credentials_json", credentials_json)
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> pulumi.Input[str]:
        """
        The contents of the JSON service account key. See the <a href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation">docs</a> for more information on how to generate this key.
        """
        return pulumi.get(self, "credentials_json")

    @credentials_json.setter
    def credentials_json(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_json", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user, which has permissions to access the Google Workspace Admin APIs.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of the developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of the developer application.
        :param pulumi.Input[str] refresh_token: The Token for obtaining a new access token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of the developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of the developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The Token for obtaining a new access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceGoogleDriveConfigurationCredentialsArgs'],
                 folder_url: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceGoogleDriveConfigurationStreamArgs']]],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceGoogleDriveConfigurationCredentialsArgs'] credentials: Credentials for connecting to the Google Drive API
        :param pulumi.Input[str] folder_url: URL for the folder you want to sync. Using individual streams and glob patterns, it's possible to only sync a subset of all files located in the folder.
        :param pulumi.Input[Sequence[pulumi.Input['SourceGoogleDriveConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "folder_url", folder_url)
        pulumi.set(__self__, "streams", streams)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceGoogleDriveConfigurationCredentialsArgs']:
        """
        Credentials for connecting to the Google Drive API
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceGoogleDriveConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="folderUrl")
    def folder_url(self) -> pulumi.Input[str]:
        """
        URL for the folder you want to sync. Using individual streams and glob patterns, it's possible to only sync a subset of all files located in the folder.
        """
        return pulumi.get(self, "folder_url")

    @folder_url.setter
    def folder_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "folder_url", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceGoogleDriveConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceGoogleDriveConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_google_o_auth: Optional[pulumi.Input['SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuthArgs']] = None,
                 service_account_key_authentication: Optional[pulumi.Input['SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthenticationArgs']] = None):
        if authenticate_via_google_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_google_o_auth", authenticate_via_google_o_auth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaGoogleOAuth")
    def authenticate_via_google_o_auth(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuthArgs']]:
        return pulumi.get(self, "authenticate_via_google_o_auth")

    @authenticate_via_google_o_auth.setter
    def authenticate_via_google_o_auth(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuthArgs']]):
        pulumi.set(self, "authenticate_via_google_o_auth", value)

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]:
        return pulumi.get(self, "service_account_key_authentication")

    @service_account_key_authentication.setter
    def service_account_key_authentication(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]):
        pulumi.set(self, "service_account_key_authentication", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Client ID for the Google Drive API
        :param pulumi.Input[str] client_secret: Client Secret for the Google Drive API
        :param pulumi.Input[str] refresh_token: Refresh Token for the Google Drive API
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID for the Google Drive API
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Client Secret for the Google Drive API
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token for the Google Drive API
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthenticationArgs:
    def __init__(__self__, *,
                 service_account_info: pulumi.Input[str]):
        """
        :param pulumi.Input[str] service_account_info: The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        pulumi.set(__self__, "service_account_info", service_account_info)

    @property
    @pulumi.getter(name="serviceAccountInfo")
    def service_account_info(self) -> pulumi.Input[str]:
        """
        The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        return pulumi.get(self, "service_account_info")

    @service_account_info.setter
    def service_account_info(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_info", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceGoogleDriveConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceGoogleDriveConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceGoogleDriveConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceGoogleDriveConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 avro_format: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatAvroFormatArgs']] = None,
                 csv_format: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatArgs']] = None,
                 document_file_type_format_experimental: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']] = None,
                 jsonl_format: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatJsonlFormatArgs']] = None,
                 parquet_format: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatParquetFormatArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs'] document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatAvroFormatArgs']]:
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @document_file_type_format_experimental.setter
    def document_file_type_format_experimental(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]):
        pulumi.set(self, "document_file_type_format_experimental", value)

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatJsonlFormatArgs']]:
        return pulumi.get(self, "jsonl_format")

    @jsonl_format.setter
    def jsonl_format(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatJsonlFormatArgs']]):
        pulumi.set(self, "jsonl_format", value)

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatParquetFormatArgs']]:
        return pulumi.get(self, "parquet_format")

    @parquet_format.setter
    def parquet_format(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatParquetFormatArgs']]):
        pulumi.set(self, "parquet_format", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatAvroFormatArgs:
    def __init__(__self__, *,
                 double_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")

    @double_as_string.setter
    def double_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_as_string", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs:
    def __init__(__self__, *,
                 processing: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']] = None,
                 skip_unprocessable_files: Optional[pulumi.Input[bool]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs'] processing: Processing configuration
        :param pulumi.Input[bool] skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param pulumi.Input[str] strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @skip_unprocessable_files.setter
    def skip_unprocessable_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unprocessable_files", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs:
    def __init__(__self__, *,
                 local: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']] = None):
        """
        :param pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs'] local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input['SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]):
        pulumi.set(self, "local", value)


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatJsonlFormatArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceGoogleDriveConfigurationStreamFormatParquetFormatArgs:
    def __init__(__self__, *,
                 decimal_as_float: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")

    @decimal_as_float.setter
    def decimal_as_float(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decimal_as_float", value)


@pulumi.input_type
class SourceGooglePagespeedInsightsConfigurationArgs:
    def __init__(__self__, *,
                 categories: pulumi.Input[Sequence[pulumi.Input[str]]],
                 strategies: pulumi.Input[Sequence[pulumi.Input[str]]],
                 urls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 api_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] categories: Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] strategies: The analyses strategy to use. Either "desktop" or "mobile".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] urls: The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
        :param pulumi.Input[str] api_key: Google PageSpeed API Key. See <a href="https://developers.google.com/speed/docs/insights/v5/get-started#APIKey">here</a>. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "strategies", strategies)
        pulumi.set(__self__, "urls", urls)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter
    def categories(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def strategies(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The analyses strategy to use. Either "desktop" or "mobile".
        """
        return pulumi.get(self, "strategies")

    @strategies.setter
    def strategies(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "strategies", value)

    @property
    @pulumi.getter
    def urls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "urls", value)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Google PageSpeed API Key. See <a href="https://developers.google.com/speed/docs/insights/v5/get-started#APIKey">here</a>. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceGoogleSearchConsoleConfigurationArgs:
    def __init__(__self__, *,
                 authorization: pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationArgs'],
                 site_urls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 custom_reports: Optional[pulumi.Input[str]] = None,
                 custom_reports_arrays: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs']]]] = None,
                 data_state: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] site_urls: The URLs of the website property attached to your GSC account. Learn more about properties <a href="https://support.google.com/webmasters/answer/34592?hl=en">here</a>.
        :param pulumi.Input[str] custom_reports: (DEPRCATED) A JSON array describing the custom reports you want to sync from Google Search Console. See our <a href='https://docs.airbyte.com/integrations/sources/google-search-console'>documentation</a> for more information on formulating custom reports.
        :param pulumi.Input[Sequence[pulumi.Input['SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs']]] custom_reports_arrays: You can add your Custom Analytics report by creating one.
        :param pulumi.Input[str] data_state: If set to 'final', the returned data will include only finalized, stable data. If set to 'all', fresh data will be included. When using Incremental sync mode, we do not recommend setting this parameter to 'all' as it may cause data loss. More information can be found in our <a href='https://docs.airbyte.com/integrations/source/google-search-console'>full documentation</a>. must be one of ["final", "all"]; Default: "final"
        :param pulumi.Input[str] end_date: UTC date in the format YYYY-MM-DD. Any data created after this date will not be replicated. Must be greater or equal to the start date field. Leaving this field blank will replicate all data from the start date onward.
        :param pulumi.Input[str] start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. Default: "2021-01-01"
        """
        pulumi.set(__self__, "authorization", authorization)
        pulumi.set(__self__, "site_urls", site_urls)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if custom_reports_arrays is not None:
            pulumi.set(__self__, "custom_reports_arrays", custom_reports_arrays)
        if data_state is not None:
            pulumi.set(__self__, "data_state", data_state)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def authorization(self) -> pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationArgs']:
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationArgs']):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The URLs of the website property attached to your GSC account. Learn more about properties <a href="https://support.google.com/webmasters/answer/34592?hl=en">here</a>.
        """
        return pulumi.get(self, "site_urls")

    @site_urls.setter
    def site_urls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "site_urls", value)

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[pulumi.Input[str]]:
        """
        (DEPRCATED) A JSON array describing the custom reports you want to sync from Google Search Console. See our <a href='https://docs.airbyte.com/integrations/sources/google-search-console'>documentation</a> for more information on formulating custom reports.
        """
        return pulumi.get(self, "custom_reports")

    @custom_reports.setter
    def custom_reports(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_reports", value)

    @property
    @pulumi.getter(name="customReportsArrays")
    def custom_reports_arrays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs']]]]:
        """
        You can add your Custom Analytics report by creating one.
        """
        return pulumi.get(self, "custom_reports_arrays")

    @custom_reports_arrays.setter
    def custom_reports_arrays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs']]]]):
        pulumi.set(self, "custom_reports_arrays", value)

    @property
    @pulumi.getter(name="dataState")
    def data_state(self) -> Optional[pulumi.Input[str]]:
        """
        If set to 'final', the returned data will include only finalized, stable data. If set to 'all', fresh data will be included. When using Incremental sync mode, we do not recommend setting this parameter to 'all' as it may cause data loss. More information can be found in our <a href='https://docs.airbyte.com/integrations/source/google-search-console'>full documentation</a>. must be one of ["final", "all"]; Default: "final"
        """
        return pulumi.get(self, "data_state")

    @data_state.setter
    def data_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_state", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date in the format YYYY-MM-DD. Any data created after this date will not be replicated. Must be greater or equal to the start date field. Leaving this field blank will replicate all data from the start date onward.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. Default: "2021-01-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceGoogleSearchConsoleConfigurationAuthorizationArgs:
    def __init__(__self__, *,
                 o_auth: Optional[pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationOAuthArgs']] = None,
                 service_account_key_authentication: Optional[pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthenticationArgs']] = None):
        if o_auth is not None:
            pulumi.set(__self__, "o_auth", o_auth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="oAuth")
    def o_auth(self) -> Optional[pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationOAuthArgs']]:
        return pulumi.get(self, "o_auth")

    @o_auth.setter
    def o_auth(self, value: Optional[pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationOAuthArgs']]):
        pulumi.set(self, "o_auth", value)

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional[pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthenticationArgs']]:
        return pulumi.get(self, "service_account_key_authentication")

    @service_account_key_authentication.setter
    def service_account_key_authentication(self, value: Optional[pulumi.Input['SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthenticationArgs']]):
        pulumi.set(self, "service_account_key_authentication", value)


@pulumi.input_type
class SourceGoogleSearchConsoleConfigurationAuthorizationOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The client ID of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        :param pulumi.Input[str] client_secret: The client secret of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        :param pulumi.Input[str] refresh_token: The token for obtaining a new access token. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        :param pulumi.Input[str] access_token: Access token for making authenticated requests. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token for obtaining a new access token. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Access token for making authenticated requests. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthenticationArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 service_account_info: pulumi.Input[str]):
        """
        :param pulumi.Input[str] email: The email of the user which has permissions to access the Google Workspace Admin APIs.
        :param pulumi.Input[str] service_account_info: The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">here</a>.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "service_account_info", service_account_info)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The email of the user which has permissions to access the Google Workspace Admin APIs.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="serviceAccountInfo")
    def service_account_info(self) -> pulumi.Input[str]:
        """
        The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">here</a>.
        """
        return pulumi.get(self, "service_account_info")

    @service_account_info.setter
    def service_account_info(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_info", value)


@pulumi.input_type
class SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: A list of available dimensions. Please note, that for technical reasons `date` is the default dimension which will be included in your query whether you specify it or not. Primary key will consist of your custom dimensions and the default dimension along with `site_url` and `search_type`.
        :param pulumi.Input[str] name: The name of the custom report, this name would be used as stream name
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of available dimensions. Please note, that for technical reasons `date` is the default dimension which will be included in your query whether you specify it or not. Primary key will consist of your custom dimensions and the default dimension along with `site_url` and `search_type`.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the custom report, this name would be used as stream name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SourceGoogleSheetsConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceGoogleSheetsConfigurationCredentialsArgs'],
                 spreadsheet_id: pulumi.Input[str],
                 batch_size: Optional[pulumi.Input[int]] = None,
                 names_conversion: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['SourceGoogleSheetsConfigurationCredentialsArgs'] credentials: Credentials for connecting to the Google Sheets API
        :param pulumi.Input[str] spreadsheet_id: Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
        :param pulumi.Input[int] batch_size: Default value is 200. An integer representing row batch size for each sent request to Google Sheets API. Row batch size means how many rows are processed from the google sheet, for example default value 200 would process rows 1-201, then 201-401 and so on. Based on <a href='https://developers.google.com/sheets/api/limits'>Google Sheets API limits documentation</a>, it is possible to send up to 300 requests per minute, but each individual request has to be processed under 180 seconds, otherwise the request returns a timeout error. In regards to this information, consider network speed and number of columns of the google sheet when deciding a batch_size value. Default value should cover most of the cases, but if a google sheet has over 100,000 records or more, consider increasing batch_size value. Default: 200
        :param pulumi.Input[bool] names_conversion: Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based. Default: false
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "spreadsheet_id", spreadsheet_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if names_conversion is not None:
            pulumi.set(__self__, "names_conversion", names_conversion)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceGoogleSheetsConfigurationCredentialsArgs']:
        """
        Credentials for connecting to the Google Sheets API
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceGoogleSheetsConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="spreadsheetId")
    def spreadsheet_id(self) -> pulumi.Input[str]:
        """
        Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
        """
        return pulumi.get(self, "spreadsheet_id")

    @spreadsheet_id.setter
    def spreadsheet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "spreadsheet_id", value)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Default value is 200. An integer representing row batch size for each sent request to Google Sheets API. Row batch size means how many rows are processed from the google sheet, for example default value 200 would process rows 1-201, then 201-401 and so on. Based on <a href='https://developers.google.com/sheets/api/limits'>Google Sheets API limits documentation</a>, it is possible to send up to 300 requests per minute, but each individual request has to be processed under 180 seconds, otherwise the request returns a timeout error. In regards to this information, consider network speed and number of columns of the google sheet when deciding a batch_size value. Default value should cover most of the cases, but if a google sheet has over 100,000 records or more, consider increasing batch_size value. Default: 200
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="namesConversion")
    def names_conversion(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based. Default: false
        """
        return pulumi.get(self, "names_conversion")

    @names_conversion.setter
    def names_conversion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "names_conversion", value)


@pulumi.input_type
class SourceGoogleSheetsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_google_o_auth: Optional[pulumi.Input['SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuthArgs']] = None,
                 service_account_key_authentication: Optional[pulumi.Input['SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthenticationArgs']] = None):
        if authenticate_via_google_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_google_o_auth", authenticate_via_google_o_auth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaGoogleOAuth")
    def authenticate_via_google_o_auth(self) -> Optional[pulumi.Input['SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuthArgs']]:
        return pulumi.get(self, "authenticate_via_google_o_auth")

    @authenticate_via_google_o_auth.setter
    def authenticate_via_google_o_auth(self, value: Optional[pulumi.Input['SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuthArgs']]):
        pulumi.set(self, "authenticate_via_google_o_auth", value)

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional[pulumi.Input['SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]:
        return pulumi.get(self, "service_account_key_authentication")

    @service_account_key_authentication.setter
    def service_account_key_authentication(self, value: Optional[pulumi.Input['SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthenticationArgs']]):
        pulumi.set(self, "service_account_key_authentication", value)


@pulumi.input_type
class SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Enter your Google application's Client ID. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        :param pulumi.Input[str] client_secret: Enter your Google application's Client Secret. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        :param pulumi.Input[str] refresh_token: Enter your Google application's refresh token. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Enter your Google application's Client ID. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Enter your Google application's Client Secret. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Enter your Google application's refresh token. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthenticationArgs:
    def __init__(__self__, *,
                 service_account_info: pulumi.Input[str]):
        """
        :param pulumi.Input[str] service_account_info: The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        pulumi.set(__self__, "service_account_info", service_account_info)

    @property
    @pulumi.getter(name="serviceAccountInfo")
    def service_account_info(self) -> pulumi.Input[str]:
        """
        The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        return pulumi.get(self, "service_account_info")

    @service_account_info.setter
    def service_account_info(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account_info", value)


@pulumi.input_type
class SourceGoogleWebfontsConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 alt: Optional[pulumi.Input[str]] = None,
                 pretty_print: Optional[pulumi.Input[str]] = None,
                 sort: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
        :param pulumi.Input[str] alt: Optional, Available params- json, media, proto
        :param pulumi.Input[str] pretty_print: Optional, boolean type
        :param pulumi.Input[str] sort: Optional, to find how to sort
        """
        pulumi.set(__self__, "api_key", api_key)
        if alt is not None:
            pulumi.set(__self__, "alt", alt)
        if pretty_print is not None:
            pulumi.set(__self__, "pretty_print", pretty_print)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def alt(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, Available params- json, media, proto
        """
        return pulumi.get(self, "alt")

    @alt.setter
    def alt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alt", value)

    @property
    @pulumi.getter(name="prettyPrint")
    def pretty_print(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, boolean type
        """
        return pulumi.get(self, "pretty_print")

    @pretty_print.setter
    def pretty_print(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pretty_print", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, to find how to sort
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class SourceGreenhouseConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Greenhouse API Key. See the <a href="https://docs.airbyte.com/integrations/sources/greenhouse">docs</a> for more information on how to generate this key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Greenhouse API Key. See the <a href="https://docs.airbyte.com/integrations/sources/greenhouse">docs</a> for more information on how to generate this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceGridlyConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 grid_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] grid_id: ID of a grid, or can be ID of a branch
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "grid_id", grid_id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="gridId")
    def grid_id(self) -> pulumi.Input[str]:
        """
        ID of a grid, or can be ID of a branch
        """
        return pulumi.get(self, "grid_id")

    @grid_id.setter
    def grid_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "grid_id", value)


@pulumi.input_type
class SourceHarvestConfigurationArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 replication_start_date: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceHarvestConfigurationCredentialsArgs']] = None,
                 replication_end_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_id: Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
        :param pulumi.Input[str] replication_start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input['SourceHarvestConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Harvest.
        :param pulumi.Input[str] replication_end_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "replication_start_date", replication_start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if replication_end_date is not None:
            pulumi.set(__self__, "replication_end_date", replication_end_date)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="replicationStartDate")
    def replication_start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "replication_start_date")

    @replication_start_date.setter
    def replication_start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "replication_start_date", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceHarvestConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate to Harvest.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceHarvestConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="replicationEndDate")
    def replication_end_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "replication_end_date")

    @replication_end_date.setter
    def replication_end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_end_date", value)


@pulumi.input_type
class SourceHarvestConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_harvest_o_auth: Optional[pulumi.Input['SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuthArgs']] = None,
                 authenticate_with_personal_access_token: Optional[pulumi.Input['SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs']] = None):
        if authenticate_via_harvest_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_harvest_o_auth", authenticate_via_harvest_o_auth)
        if authenticate_with_personal_access_token is not None:
            pulumi.set(__self__, "authenticate_with_personal_access_token", authenticate_with_personal_access_token)

    @property
    @pulumi.getter(name="authenticateViaHarvestOAuth")
    def authenticate_via_harvest_o_auth(self) -> Optional[pulumi.Input['SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuthArgs']]:
        return pulumi.get(self, "authenticate_via_harvest_o_auth")

    @authenticate_via_harvest_o_auth.setter
    def authenticate_via_harvest_o_auth(self, value: Optional[pulumi.Input['SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuthArgs']]):
        pulumi.set(self, "authenticate_via_harvest_o_auth", value)

    @property
    @pulumi.getter(name="authenticateWithPersonalAccessToken")
    def authenticate_with_personal_access_token(self) -> Optional[pulumi.Input['SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs']]:
        return pulumi.get(self, "authenticate_with_personal_access_token")

    @authenticate_with_personal_access_token.setter
    def authenticate_with_personal_access_token(self, value: Optional[pulumi.Input['SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs']]):
        pulumi.set(self, "authenticate_with_personal_access_token", value)


@pulumi.input_type
class SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Harvest developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Harvest developer application.
        :param pulumi.Input[str] refresh_token: Refresh Token to renew the expired Access Token.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Harvest developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Harvest developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Log into Harvest and then create new <a href="https://id.getharvest.com/developers"> personal access token</a>.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_token", api_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Log into Harvest and then create new <a href="https://id.getharvest.com/developers"> personal access token</a>.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceHubplannerConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceHubspotConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceHubspotConfigurationCredentialsArgs'],
                 enable_experimental_streams: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceHubspotConfigurationCredentialsArgs'] credentials: Choose how to authenticate to HubSpot.
        :param pulumi.Input[bool] enable_experimental_streams: If enabled then experimental streams become available for sync. Default: false
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If not set, "2006-06-01T00:00:00Z" (Hubspot creation date) will be used as start date. It's recommended to provide relevant to your data start date value to optimize synchronization.
        """
        pulumi.set(__self__, "credentials", credentials)
        if enable_experimental_streams is not None:
            pulumi.set(__self__, "enable_experimental_streams", enable_experimental_streams)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceHubspotConfigurationCredentialsArgs']:
        """
        Choose how to authenticate to HubSpot.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceHubspotConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="enableExperimentalStreams")
    def enable_experimental_streams(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled then experimental streams become available for sync. Default: false
        """
        return pulumi.get(self, "enable_experimental_streams")

    @enable_experimental_streams.setter
    def enable_experimental_streams(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_experimental_streams", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If not set, "2006-06-01T00:00:00Z" (Hubspot creation date) will be used as start date. It's recommended to provide relevant to your data start date value to optimize synchronization.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceHubspotConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth: Optional[pulumi.Input['SourceHubspotConfigurationCredentialsOAuthArgs']] = None,
                 private_app: Optional[pulumi.Input['SourceHubspotConfigurationCredentialsPrivateAppArgs']] = None):
        if o_auth is not None:
            pulumi.set(__self__, "o_auth", o_auth)
        if private_app is not None:
            pulumi.set(__self__, "private_app", private_app)

    @property
    @pulumi.getter(name="oAuth")
    def o_auth(self) -> Optional[pulumi.Input['SourceHubspotConfigurationCredentialsOAuthArgs']]:
        return pulumi.get(self, "o_auth")

    @o_auth.setter
    def o_auth(self, value: Optional[pulumi.Input['SourceHubspotConfigurationCredentialsOAuthArgs']]):
        pulumi.set(self, "o_auth", value)

    @property
    @pulumi.getter(name="privateApp")
    def private_app(self) -> Optional[pulumi.Input['SourceHubspotConfigurationCredentialsPrivateAppArgs']]:
        return pulumi.get(self, "private_app")

    @private_app.setter
    def private_app(self, value: Optional[pulumi.Input['SourceHubspotConfigurationCredentialsPrivateAppArgs']]):
        pulumi.set(self, "private_app", value)


@pulumi.input_type
class SourceHubspotConfigurationCredentialsOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this ID.
        :param pulumi.Input[str] client_secret: The client secret for your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this secret.
        :param pulumi.Input[str] refresh_token: Refresh token to renew an expired access token. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this ID.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret for your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh token to renew an expired access token. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceHubspotConfigurationCredentialsPrivateAppArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: HubSpot Access token. See the <a href="https://developers.hubspot.com/docs/api/private-apps">Hubspot docs</a> if you need help finding this token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        HubSpot Access token. See the <a href="https://developers.hubspot.com/docs/api/private-apps">Hubspot docs</a> if you need help finding this token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceInsightlyConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
        :param pulumi.Input[str] token: Your Insightly API token.
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Your Insightly API token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class SourceInstagramConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The value of the access token generated with <b>instagram_basic, instagram_manage_insights, pages_show_list, pages_read_engagement, Instagram Public Content Access</b> permissions. See the <a href="https://docs.airbyte.com/integrations/sources/instagram/#step-1-set-up-instagram">docs</a> for more information
        :param pulumi.Input[str] client_id: The Client ID for your Oauth application
        :param pulumi.Input[str] client_secret: The Client Secret for your Oauth application
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The value of the access token generated with <b>instagram_basic, instagram_manage_insights, pages_show_list, pages_read_engagement, Instagram Public Content Access</b> permissions. See the <a href="https://docs.airbyte.com/integrations/sources/instagram/#step-1-set-up-instagram">docs</a> for more information
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID for your Oauth application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret for your Oauth application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceInstatusConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Instatus REST API key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Instatus REST API key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceIntercomConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Access token for making authenticated requests. See the <a href="https://developers.intercom.com/building-apps/docs/authentication-types#how-to-get-your-access-token">Intercom docs</a> for more information.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[str] client_id: Client Id for your Intercom application.
        :param pulumi.Input[str] client_secret: Client Secret for your Intercom application.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "start_date", start_date)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access token for making authenticated requests. See the <a href="https://developers.intercom.com/building-apps/docs/authentication-types#how-to-get-your-access-token">Intercom docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client Id for your Intercom application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Client Secret for your Intercom application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceIp2whoisConfigurationArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Your API Key. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        :param pulumi.Input[str] domain: Domain name. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your API Key. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Domain name. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)


@pulumi.input_type
class SourceIterableConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Iterable API Key. See the <a href=\\"https://docs.airbyte.com/integrations/sources/iterable\\">docs</a>  for more information on how to obtain this key.
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z.  All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Iterable API Key. See the <a href=\\"https://docs.airbyte.com/integrations/sources/iterable\\">docs</a>  for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z.  All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceJiraConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 domain: pulumi.Input[str],
                 email: pulumi.Input[str],
                 enable_experimental_streams: Optional[pulumi.Input[bool]] = None,
                 expand_issue_changelog: Optional[pulumi.Input[bool]] = None,
                 expand_issue_transition: Optional[pulumi.Input[bool]] = None,
                 issues_stream_expand_withs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 lookback_window_minutes: Optional[pulumi.Input[int]] = None,
                 projects: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 render_fields: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Jira API Token. See the <a href="https://docs.airbyte.com/integrations/sources/jira">docs</a> for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
        :param pulumi.Input[str] domain: The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
        :param pulumi.Input[str] email: The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
        :param pulumi.Input[bool] enable_experimental_streams: Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info. Default: false
        :param pulumi.Input[bool] expand_issue_changelog: (DEPRECATED) Expand the changelog when replicating issues. Default: false
        :param pulumi.Input[bool] expand_issue_transition: (DEPRECATED) Expand the transitions when replicating issues. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] issues_stream_expand_withs: Select fields to Expand the `Issues` stream when replicating with:
        :param pulumi.Input[int] lookback_window_minutes: When set to N, the connector will always refresh resources created within the past N minutes. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input[str]]] projects: List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
        :param pulumi.Input[bool] render_fields: (DEPRECATED) Render issue fields in HTML format in addition to Jira JSON-like format. Default: false
        :param pulumi.Input[str] start_date: The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the <a href="https://docs.airbyte.com/integrations/sources/jira/">documentation</a>.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "email", email)
        if enable_experimental_streams is not None:
            pulumi.set(__self__, "enable_experimental_streams", enable_experimental_streams)
        if expand_issue_changelog is not None:
            pulumi.set(__self__, "expand_issue_changelog", expand_issue_changelog)
        if expand_issue_transition is not None:
            pulumi.set(__self__, "expand_issue_transition", expand_issue_transition)
        if issues_stream_expand_withs is not None:
            pulumi.set(__self__, "issues_stream_expand_withs", issues_stream_expand_withs)
        if lookback_window_minutes is not None:
            pulumi.set(__self__, "lookback_window_minutes", lookback_window_minutes)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if render_fields is not None:
            pulumi.set(__self__, "render_fields", render_fields)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Jira API Token. See the <a href="https://docs.airbyte.com/integrations/sources/jira">docs</a> for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="enableExperimentalStreams")
    def enable_experimental_streams(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info. Default: false
        """
        return pulumi.get(self, "enable_experimental_streams")

    @enable_experimental_streams.setter
    def enable_experimental_streams(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_experimental_streams", value)

    @property
    @pulumi.getter(name="expandIssueChangelog")
    def expand_issue_changelog(self) -> Optional[pulumi.Input[bool]]:
        """
        (DEPRECATED) Expand the changelog when replicating issues. Default: false
        """
        return pulumi.get(self, "expand_issue_changelog")

    @expand_issue_changelog.setter
    def expand_issue_changelog(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expand_issue_changelog", value)

    @property
    @pulumi.getter(name="expandIssueTransition")
    def expand_issue_transition(self) -> Optional[pulumi.Input[bool]]:
        """
        (DEPRECATED) Expand the transitions when replicating issues. Default: false
        """
        return pulumi.get(self, "expand_issue_transition")

    @expand_issue_transition.setter
    def expand_issue_transition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expand_issue_transition", value)

    @property
    @pulumi.getter(name="issuesStreamExpandWiths")
    def issues_stream_expand_withs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Select fields to Expand the `Issues` stream when replicating with:
        """
        return pulumi.get(self, "issues_stream_expand_withs")

    @issues_stream_expand_withs.setter
    def issues_stream_expand_withs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "issues_stream_expand_withs", value)

    @property
    @pulumi.getter(name="lookbackWindowMinutes")
    def lookback_window_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        When set to N, the connector will always refresh resources created within the past N minutes. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        """
        return pulumi.get(self, "lookback_window_minutes")

    @lookback_window_minutes.setter
    def lookback_window_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window_minutes", value)

    @property
    @pulumi.getter
    def projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
        """
        return pulumi.get(self, "projects")

    @projects.setter
    def projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "projects", value)

    @property
    @pulumi.getter(name="renderFields")
    def render_fields(self) -> Optional[pulumi.Input[bool]]:
        """
        (DEPRECATED) Render issue fields in HTML format in addition to Jira JSON-like format. Default: false
        """
        return pulumi.get(self, "render_fields")

    @render_fields.setter
    def render_fields(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "render_fields", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the <a href="https://docs.airbyte.com/integrations/sources/jira/">documentation</a>.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceK6CloudConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: Your API Token. See <a href="https://k6.io/docs/cloud/integrations/token/">here</a>. The key is case sensitive.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Your API Token. See <a href="https://k6.io/docs/cloud/integrations/token/">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)


@pulumi.input_type
class SourceKlarnaConfigurationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 region: pulumi.Input[str],
                 username: pulumi.Input[str],
                 playground: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] password: A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
        :param pulumi.Input[str] region: Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'. must be one of ["eu", "us", "oc"]
        :param pulumi.Input[str] username: Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
        :param pulumi.Input[bool] playground: Propertie defining if connector is used against playground or production environment. Default: false
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "username", username)
        if playground is not None:
            pulumi.set(__self__, "playground", playground)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'. must be one of ["eu", "us", "oc"]
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def playground(self) -> Optional[pulumi.Input[bool]]:
        """
        Propertie defining if connector is used against playground or production environment. Default: false
        """
        return pulumi.get(self, "playground")

    @playground.setter
    def playground(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "playground", value)


@pulumi.input_type
class SourceKlaviyoConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Klaviyo API Key. See our <a href="https://docs.airbyte.com/integrations/sources/klaviyo">docs</a> if you need help finding this key.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This field is optional - if not provided, all data will be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Klaviyo API Key. See our <a href="https://docs.airbyte.com/integrations/sources/klaviyo">docs</a> if you need help finding this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This field is optional - if not provided, all data will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceKyveConfigurationArgs:
    def __init__(__self__, *,
                 pool_ids: pulumi.Input[str],
                 start_ids: pulumi.Input[str],
                 max_pages: Optional[pulumi.Input[int]] = None,
                 page_size: Optional[pulumi.Input[int]] = None,
                 url_base: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pool_ids: The IDs of the KYVE storage pool you want to archive. (Comma separated)
        :param pulumi.Input[str] start_ids: The start-id defines, from which bundle id the pipeline should start to extract the data. (Comma separated)
        :param pulumi.Input[int] max_pages: The maximum amount of pages to go trough. Set to 'null' for all pages.
        :param pulumi.Input[int] page_size: The pagesize for pagination, smaller numbers are used in integration tests. Default: 100
        :param pulumi.Input[str] url_base: URL to the KYVE Chain API. Default: "https://api.kyve.network"
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "start_ids", start_ids)
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if url_base is not None:
            pulumi.set(__self__, "url_base", url_base)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> pulumi.Input[str]:
        """
        The IDs of the KYVE storage pool you want to archive. (Comma separated)
        """
        return pulumi.get(self, "pool_ids")

    @pool_ids.setter
    def pool_ids(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool_ids", value)

    @property
    @pulumi.getter(name="startIds")
    def start_ids(self) -> pulumi.Input[str]:
        """
        The start-id defines, from which bundle id the pipeline should start to extract the data. (Comma separated)
        """
        return pulumi.get(self, "start_ids")

    @start_ids.setter
    def start_ids(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_ids", value)

    @property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of pages to go trough. Set to 'null' for all pages.
        """
        return pulumi.get(self, "max_pages")

    @max_pages.setter
    def max_pages(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pages", value)

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[pulumi.Input[int]]:
        """
        The pagesize for pagination, smaller numbers are used in integration tests. Default: 100
        """
        return pulumi.get(self, "page_size")

    @page_size.setter
    def page_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "page_size", value)

    @property
    @pulumi.getter(name="urlBase")
    def url_base(self) -> Optional[pulumi.Input[str]]:
        """
        URL to the KYVE Chain API. Default: "https://api.kyve.network"
        """
        return pulumi.get(self, "url_base")

    @url_base.setter
    def url_base(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_base", value)


@pulumi.input_type
class SourceLaunchdarklyConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Your Access token. See <a href="https://apidocs.launchdarkly.com/#section/Overview/Authentication">here</a>.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Your Access token. See <a href="https://apidocs.launchdarkly.com/#section/Overview/Authentication">here</a>.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceLemlistConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Lemlist API key,
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Lemlist API key,
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceLeverHiringConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsArgs']] = None,
                 environment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
        :param pulumi.Input['SourceLeverHiringConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Lever Hiring.
        :param pulumi.Input[str] environment: The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use. must be one of ["Production", "Sandbox"]; Default: "Sandbox"
        """
        pulumi.set(__self__, "start_date", start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate to Lever Hiring.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use. must be one of ["Production", "Sandbox"]; Default: "Sandbox"
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)


@pulumi.input_type
class SourceLeverHiringConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_lever_api_key: Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKeyArgs']] = None,
                 authenticate_via_lever_o_auth: Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuthArgs']] = None):
        if authenticate_via_lever_api_key is not None:
            pulumi.set(__self__, "authenticate_via_lever_api_key", authenticate_via_lever_api_key)
        if authenticate_via_lever_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_lever_o_auth", authenticate_via_lever_o_auth)

    @property
    @pulumi.getter(name="authenticateViaLeverApiKey")
    def authenticate_via_lever_api_key(self) -> Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKeyArgs']]:
        return pulumi.get(self, "authenticate_via_lever_api_key")

    @authenticate_via_lever_api_key.setter
    def authenticate_via_lever_api_key(self, value: Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKeyArgs']]):
        pulumi.set(self, "authenticate_via_lever_api_key", value)

    @property
    @pulumi.getter(name="authenticateViaLeverOAuth")
    def authenticate_via_lever_o_auth(self) -> Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuthArgs']]:
        return pulumi.get(self, "authenticate_via_lever_o_auth")

    @authenticate_via_lever_o_auth.setter
    def authenticate_via_lever_o_auth(self, value: Optional[pulumi.Input['SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuthArgs']]):
        pulumi.set(self, "authenticate_via_lever_o_auth", value)


@pulumi.input_type
class SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKeyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: The Api Key of your Lever Hiring account.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The Api Key of your Lever Hiring account.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuthArgs:
    def __init__(__self__, *,
                 refresh_token: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] refresh_token: The token for obtaining new access token.
        :param pulumi.Input[str] client_id: The Client ID of your Lever Hiring developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Lever Hiring developer application.
        """
        pulumi.set(__self__, "refresh_token", refresh_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token for obtaining new access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of your Lever Hiring developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of your Lever Hiring developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceLinkedinAdsConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 account_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 ad_analytics_reports: Optional[pulumi.Input[Sequence[pulumi.Input['SourceLinkedinAdsConfigurationAdAnalyticsReportArgs']]]] = None,
                 credentials: Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input[str] start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] account_ids: Specify the account IDs to pull data from, separated by a space. Leave this field empty if you want to pull the data from all accounts accessible by the authenticated user. See the <a href="https://www.linkedin.com/help/linkedin/answer/a424270/find-linkedin-ads-account-details?lang=en">LinkedIn docs</a> to locate these IDs.
        """
        pulumi.set(__self__, "start_date", start_date)
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if ad_analytics_reports is not None:
            pulumi.set(__self__, "ad_analytics_reports", ad_analytics_reports)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Specify the account IDs to pull data from, separated by a space. Leave this field empty if you want to pull the data from all accounts accessible by the authenticated user. See the <a href="https://www.linkedin.com/help/linkedin/answer/a424270/find-linkedin-ads-account-details?lang=en">LinkedIn docs</a> to locate these IDs.
        """
        return pulumi.get(self, "account_ids")

    @account_ids.setter
    def account_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "account_ids", value)

    @property
    @pulumi.getter(name="adAnalyticsReports")
    def ad_analytics_reports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceLinkedinAdsConfigurationAdAnalyticsReportArgs']]]]:
        return pulumi.get(self, "ad_analytics_reports")

    @ad_analytics_reports.setter
    def ad_analytics_reports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceLinkedinAdsConfigurationAdAnalyticsReportArgs']]]]):
        pulumi.set(self, "ad_analytics_reports", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceLinkedinAdsConfigurationAdAnalyticsReportArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 pivot_by: pulumi.Input[str],
                 time_granularity: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name for the custom report.
        :param pulumi.Input[str] pivot_by: Choose a category to pivot your analytics report around. This selection will organize your data based on the chosen attribute, allowing you to analyze trends and performance from different perspectives. must be one of ["COMPANY", "ACCOUNT", "SHARE", "CAMPAIGN", "CREATIVE", "CAMPAIGN_GROUP", "CONVERSION", "CONVERSATION_NODE", "CONVERSATION_NODE_OPTION_INDEX", "SERVING_LOCATION", "CARD_INDEX", "MEMBER_COMPANY_SIZE", "MEMBER_INDUSTRY", "MEMBER_SENIORITY", "MEMBER_JOB_TITLE", "MEMBER_JOB_FUNCTION", "MEMBER_COUNTRY_V2", "MEMBER_REGION_V2", "MEMBER_COMPANY", "PLACEMENT_NAME", "IMPRESSION_DEVICE_TYPE"]
        :param pulumi.Input[str] time_granularity: Choose how to group the data in your report by time. The options are:<br>- 'ALL': A single result summarizing the entire time range.<br>- 'DAILY': Group results by each day.<br>- 'MONTHLY': Group results by each month.<br>- 'YEARLY': Group results by each year.<br>Selecting a time grouping helps you analyze trends and patterns over different time periods. must be one of ["ALL", "DAILY", "MONTHLY", "YEARLY"]
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pivot_by", pivot_by)
        pulumi.set(__self__, "time_granularity", time_granularity)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the custom report.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pivotBy")
    def pivot_by(self) -> pulumi.Input[str]:
        """
        Choose a category to pivot your analytics report around. This selection will organize your data based on the chosen attribute, allowing you to analyze trends and performance from different perspectives. must be one of ["COMPANY", "ACCOUNT", "SHARE", "CAMPAIGN", "CREATIVE", "CAMPAIGN_GROUP", "CONVERSION", "CONVERSATION_NODE", "CONVERSATION_NODE_OPTION_INDEX", "SERVING_LOCATION", "CARD_INDEX", "MEMBER_COMPANY_SIZE", "MEMBER_INDUSTRY", "MEMBER_SENIORITY", "MEMBER_JOB_TITLE", "MEMBER_JOB_FUNCTION", "MEMBER_COUNTRY_V2", "MEMBER_REGION_V2", "MEMBER_COMPANY", "PLACEMENT_NAME", "IMPRESSION_DEVICE_TYPE"]
        """
        return pulumi.get(self, "pivot_by")

    @pivot_by.setter
    def pivot_by(self, value: pulumi.Input[str]):
        pulumi.set(self, "pivot_by", value)

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> pulumi.Input[str]:
        """
        Choose how to group the data in your report by time. The options are:<br>- 'ALL': A single result summarizing the entire time range.<br>- 'DAILY': Group results by each day.<br>- 'MONTHLY': Group results by each month.<br>- 'YEARLY': Group results by each year.<br>Selecting a time grouping helps you analyze trends and patterns over different time periods. must be one of ["ALL", "DAILY", "MONTHLY", "YEARLY"]
        """
        return pulumi.get(self, "time_granularity")

    @time_granularity.setter
    def time_granularity(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_granularity", value)


@pulumi.input_type
class SourceLinkedinAdsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsAccessTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsOAuth20Args']] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsAccessTokenArgs']]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceLinkedinAdsConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceLinkedinAdsConfigurationCredentialsAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: The access token generated for your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The access token generated for your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceLinkedinAdsConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The client ID of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        :param pulumi.Input[str] client_secret: The client secret of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access token. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The key to refresh the expired access token. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceLinkedinPagesConfigurationArgs:
    def __init__(__self__, *,
                 org_id: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input[str] org_id: Specify the Organization ID
        """
        pulumi.set(__self__, "org_id", org_id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> pulumi.Input[str]:
        """
        Specify the Organization ID
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceLinkedinPagesConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsAccessTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsOAuth20Args']] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsAccessTokenArgs']]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceLinkedinPagesConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceLinkedinPagesConfigurationCredentialsAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceLinkedinPagesConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The client ID of the LinkedIn developer application.
        :param pulumi.Input[str] client_secret: The client secret of the LinkedIn developer application.
        :param pulumi.Input[str] refresh_token: The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID of the LinkedIn developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret of the LinkedIn developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceLinnworksConfigurationArgs:
    def __init__(__self__, *,
                 application_id: pulumi.Input[str],
                 application_secret: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] application_id: Linnworks Application ID
        :param pulumi.Input[str] application_secret: Linnworks Application Secret
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "application_secret", application_secret)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> pulumi.Input[str]:
        """
        Linnworks Application ID
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="applicationSecret")
    def application_secret(self) -> pulumi.Input[str]:
        """
        Linnworks Application Secret
        """
        return pulumi.get(self, "application_secret")

    @application_secret.setter
    def application_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "application_secret", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class SourceLokaliseConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Lokalise API Key with read-access. Available at Profile settings > API tokens. See <a href="https://docs.lokalise.com/en/articles/1929556-api-tokens">here</a>.
        :param pulumi.Input[str] project_id: Lokalise project ID. Available at Project Settings > General.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Lokalise API Key with read-access. Available at Profile settings > API tokens. See <a href="https://docs.lokalise.com/en/articles/1929556-api-tokens">here</a>.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Lokalise project ID. Available at Project Settings > General.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


@pulumi.input_type
class SourceMailchimpConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsArgs']] = None,
                 data_center: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_center: Technical fields used to identify datacenter to send request to
        :param pulumi.Input[str] start_date: The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if data_center is not None:
            pulumi.set(__self__, "data_center", data_center)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> Optional[pulumi.Input[str]]:
        """
        Technical fields used to identify datacenter to send request to
        """
        return pulumi.get(self, "data_center")

    @data_center.setter
    def data_center(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_center", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMailchimpConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsApiKeyArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsOAuth20Args']] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsApiKeyArgs']]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceMailchimpConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceMailchimpConfigurationCredentialsApiKeyArgs:
    def __init__(__self__, *,
                 apikey: pulumi.Input[str]):
        """
        :param pulumi.Input[str] apikey: Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
        """
        pulumi.set(__self__, "apikey", apikey)

    @property
    @pulumi.getter
    def apikey(self) -> pulumi.Input[str]:
        """
        Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "apikey")

    @apikey.setter
    def apikey(self, value: pulumi.Input[str]):
        pulumi.set(self, "apikey", value)


@pulumi.input_type
class SourceMailchimpConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: An access token generated using the above client ID and secret.
        :param pulumi.Input[str] client_id: The Client ID of your OAuth application.
        :param pulumi.Input[str] client_secret: The Client Secret of your OAuth application.
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        An access token generated using the above client ID and secret.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceMailgunConfigurationArgs:
    def __init__(__self__, *,
                 private_key: pulumi.Input[str],
                 domain_region: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_key: Primary account API key to access your Mailgun data.
        :param pulumi.Input[str] domain_region: Domain region code. 'EU' or 'US' are possible values. The default is 'US'. Default: "US"
        :param pulumi.Input[str] start_date: UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
        """
        pulumi.set(__self__, "private_key", private_key)
        if domain_region is not None:
            pulumi.set(__self__, "domain_region", domain_region)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        Primary account API key to access your Mailgun data.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="domainRegion")
    def domain_region(self) -> Optional[pulumi.Input[str]]:
        """
        Domain region code. 'EU' or 'US' are possible values. The default is 'US'. Default: "US"
        """
        return pulumi.get(self, "domain_region")

    @domain_region.setter
    def domain_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_region", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMailjetSmsConfigurationArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[int]] = None,
                 start_date: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] token: Your access token. See <a href="https://dev.mailjet.com/sms/reference/overview/authentication">here</a>.
        :param pulumi.Input[int] end_date: Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
        :param pulumi.Input[int] start_date: Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
        """
        pulumi.set(__self__, "token", token)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Your access token. See <a href="https://dev.mailjet.com/sms/reference/overview/authentication">here</a>.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[int]]:
        """
        Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[int]]:
        """
        Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMarketoConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 domain_url: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        :param pulumi.Input[str] client_secret: The Client Secret of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        :param pulumi.Input[str] domain_url: Your Marketo Base URL. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "domain_url", domain_url)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="domainUrl")
    def domain_url(self) -> pulumi.Input[str]:
        """
        Your Marketo Base URL. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "domain_url")

    @domain_url.setter
    def domain_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_url", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMetabaseConfigurationArgs:
    def __init__(__self__, *,
                 instance_api_url: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 session_token: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_api_url: URL to your metabase instance API
        :param pulumi.Input[str] session_token: To generate your session token, you need to run the following command: ``` curl -X POST \\
                 -H "Content-Type: application/json" \\
                 -d '{"username": "person@metabase.com", "password": "fakepassword"}' \\
                 http://localhost:3000/api/session
               ``` Then copy the value of the `id` field returned by a successful call to that API.
               Note that by default, sessions are good for 14 days and needs to be regenerated.
        """
        pulumi.set(__self__, "instance_api_url", instance_api_url)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="instanceApiUrl")
    def instance_api_url(self) -> pulumi.Input[str]:
        """
        URL to your metabase instance API
        """
        return pulumi.get(self, "instance_api_url")

    @instance_api_url.setter
    def instance_api_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_api_url", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[str]]:
        """
        To generate your session token, you need to run the following command: ``` curl -X POST \\
          -H "Content-Type: application/json" \\
          -d '{"username": "person@metabase.com", "password": "fakepassword"}' \\
          http://localhost:3000/api/session
        ``` Then copy the value of the `id` field returned by a successful call to that API.
        Note that by default, sessions are good for 14 days and needs to be regenerated.
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_token", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsArgs'],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamArgs']]],
                 drive_name: Optional[pulumi.Input[str]] = None,
                 folder_path: Optional[pulumi.Input[str]] = None,
                 search_scope: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsArgs'] credentials: Credentials for connecting to the One Drive API
        :param pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] drive_name: Name of the Microsoft OneDrive drive where the file(s) exist. Default: "OneDrive"
        :param pulumi.Input[str] folder_path: Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        :param pulumi.Input[str] search_scope: Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "streams", streams)
        if drive_name is not None:
            pulumi.set(__self__, "drive_name", drive_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if search_scope is not None:
            pulumi.set(__self__, "search_scope", search_scope)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsArgs']:
        """
        Credentials for connecting to the One Drive API
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="driveName")
    def drive_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Microsoft OneDrive drive where the file(s) exist. Default: "OneDrive"
        """
        return pulumi.get(self, "drive_name")

    @drive_name.setter
    def drive_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drive_name", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter(name="searchScope")
    def search_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        """
        return pulumi.get(self, "search_scope")

    @search_scope.setter
    def search_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_scope", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_microsoft_o_auth: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs']] = None,
                 service_key_authentication: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs']] = None):
        """
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs'] authenticate_via_microsoft_o_auth: OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
               This class uses pydantic for data validation and settings management.
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs'] service_key_authentication: ServiceCredentials class for service key authentication.
               This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        if authenticate_via_microsoft_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_microsoft_o_auth", authenticate_via_microsoft_o_auth)
        if service_key_authentication is not None:
            pulumi.set(__self__, "service_key_authentication", service_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaMicrosoftOAuth")
    def authenticate_via_microsoft_o_auth(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs']]:
        """
        OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
        This class uses pydantic for data validation and settings management.
        """
        return pulumi.get(self, "authenticate_via_microsoft_o_auth")

    @authenticate_via_microsoft_o_auth.setter
    def authenticate_via_microsoft_o_auth(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs']]):
        pulumi.set(self, "authenticate_via_microsoft_o_auth", value)

    @property
    @pulumi.getter(name="serviceKeyAuthentication")
    def service_key_authentication(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs']]:
        """
        ServiceCredentials class for service key authentication.
        This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        return pulumi.get(self, "service_key_authentication")

    @service_key_authentication.setter
    def service_key_authentication(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs']]):
        pulumi.set(self, "service_key_authentication", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Client ID of your Microsoft developer application
        :param pulumi.Input[str] client_secret: Client Secret of your Microsoft developer application
        :param pulumi.Input[str] refresh_token: Refresh Token of your Microsoft developer application
        :param pulumi.Input[str] tenant_id: Tenant ID of the Microsoft OneDrive user
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token of your Microsoft developer application
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Tenant ID of the Microsoft OneDrive user
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 user_principal_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Client ID of your Microsoft developer application
        :param pulumi.Input[str] client_secret: Client Secret of your Microsoft developer application
        :param pulumi.Input[str] tenant_id: Tenant ID of the Microsoft OneDrive user
        :param pulumi.Input[str] user_principal_name: Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Tenant ID of the Microsoft OneDrive user
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> pulumi.Input[str]:
        """
        Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_principal_name", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 avro_format: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormatArgs']] = None,
                 csv_format: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatArgs']] = None,
                 document_file_type_format_experimental: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']] = None,
                 jsonl_format: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormatArgs']] = None,
                 parquet_format: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormatArgs']] = None):
        """
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs'] document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormatArgs']]:
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @document_file_type_format_experimental.setter
    def document_file_type_format_experimental(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]):
        pulumi.set(self, "document_file_type_format_experimental", value)

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormatArgs']]:
        return pulumi.get(self, "jsonl_format")

    @jsonl_format.setter
    def jsonl_format(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormatArgs']]):
        pulumi.set(self, "jsonl_format", value)

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormatArgs']]:
        return pulumi.get(self, "parquet_format")

    @parquet_format.setter
    def parquet_format(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormatArgs']]):
        pulumi.set(self, "parquet_format", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormatArgs:
    def __init__(__self__, *,
                 double_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")

    @double_as_string.setter
    def double_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_as_string", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs:
    def __init__(__self__, *,
                 processing: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']] = None,
                 skip_unprocessable_files: Optional[pulumi.Input[bool]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs'] processing: Processing configuration
        :param pulumi.Input[bool] skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param pulumi.Input[str] strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @skip_unprocessable_files.setter
    def skip_unprocessable_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unprocessable_files", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs:
    def __init__(__self__, *,
                 local: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']] = None):
        """
        :param pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs'] local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input['SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]):
        pulumi.set(self, "local", value)


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormatArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormatArgs:
    def __init__(__self__, *,
                 decimal_as_float: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")

    @decimal_as_float.setter
    def decimal_as_float(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decimal_as_float", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsArgs'],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamArgs']]],
                 folder_path: Optional[pulumi.Input[str]] = None,
                 search_scope: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsArgs'] credentials: Credentials for connecting to the One Drive API
        :param pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] folder_path: Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        :param pulumi.Input[str] search_scope: Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' for all SharePoint drives the user can access, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "streams", streams)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if search_scope is not None:
            pulumi.set(__self__, "search_scope", search_scope)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsArgs']:
        """
        Credentials for connecting to the One Drive API
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter(name="searchScope")
    def search_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' for all SharePoint drives the user can access, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        """
        return pulumi.get(self, "search_scope")

    @search_scope.setter
    def search_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_scope", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_microsoft_o_auth: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs']] = None,
                 service_key_authentication: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs']] = None):
        """
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs'] authenticate_via_microsoft_o_auth: OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
               This class uses pydantic for data validation and settings management.
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs'] service_key_authentication: ServiceCredentials class for service key authentication.
               This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        if authenticate_via_microsoft_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_microsoft_o_auth", authenticate_via_microsoft_o_auth)
        if service_key_authentication is not None:
            pulumi.set(__self__, "service_key_authentication", service_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaMicrosoftOAuth")
    def authenticate_via_microsoft_o_auth(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs']]:
        """
        OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
        This class uses pydantic for data validation and settings management.
        """
        return pulumi.get(self, "authenticate_via_microsoft_o_auth")

    @authenticate_via_microsoft_o_auth.setter
    def authenticate_via_microsoft_o_auth(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs']]):
        pulumi.set(self, "authenticate_via_microsoft_o_auth", value)

    @property
    @pulumi.getter(name="serviceKeyAuthentication")
    def service_key_authentication(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs']]:
        """
        ServiceCredentials class for service key authentication.
        This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        return pulumi.get(self, "service_key_authentication")

    @service_key_authentication.setter
    def service_key_authentication(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs']]):
        pulumi.set(self, "service_key_authentication", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 refresh_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Client ID of your Microsoft developer application
        :param pulumi.Input[str] client_secret: Client Secret of your Microsoft developer application
        :param pulumi.Input[str] tenant_id: Tenant ID of the Microsoft SharePoint user
        :param pulumi.Input[str] refresh_token: Refresh Token of your Microsoft developer application
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Tenant ID of the Microsoft SharePoint user
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[str]]:
        """
        Refresh Token of your Microsoft developer application
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 user_principal_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Client ID of your Microsoft developer application
        :param pulumi.Input[str] client_secret: Client Secret of your Microsoft developer application
        :param pulumi.Input[str] tenant_id: Tenant ID of the Microsoft SharePoint user
        :param pulumi.Input[str] user_principal_name: Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Tenant ID of the Microsoft SharePoint user
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> pulumi.Input[str]:
        """
        Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_principal_name", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 avro_format: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatAvroFormatArgs']] = None,
                 csv_format: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatArgs']] = None,
                 document_file_type_format_experimental: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']] = None,
                 jsonl_format: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormatArgs']] = None,
                 parquet_format: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatParquetFormatArgs']] = None):
        """
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs'] document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatAvroFormatArgs']]:
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @document_file_type_format_experimental.setter
    def document_file_type_format_experimental(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]):
        pulumi.set(self, "document_file_type_format_experimental", value)

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormatArgs']]:
        return pulumi.get(self, "jsonl_format")

    @jsonl_format.setter
    def jsonl_format(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormatArgs']]):
        pulumi.set(self, "jsonl_format", value)

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatParquetFormatArgs']]:
        return pulumi.get(self, "parquet_format")

    @parquet_format.setter
    def parquet_format(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatParquetFormatArgs']]):
        pulumi.set(self, "parquet_format", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatAvroFormatArgs:
    def __init__(__self__, *,
                 double_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")

    @double_as_string.setter
    def double_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_as_string", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 ignore_errors_on_fields_mismatch: Optional[pulumi.Input[bool]] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[bool] ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @ignore_errors_on_fields_mismatch.setter
    def ignore_errors_on_fields_mismatch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors_on_fields_mismatch", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs:
    def __init__(__self__, *,
                 processing: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']] = None,
                 skip_unprocessable_files: Optional[pulumi.Input[bool]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs'] processing: Processing configuration
        :param pulumi.Input[bool] skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param pulumi.Input[str] strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @skip_unprocessable_files.setter
    def skip_unprocessable_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unprocessable_files", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs:
    def __init__(__self__, *,
                 local: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']] = None):
        """
        :param pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs'] local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input['SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]):
        pulumi.set(self, "local", value)


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormatArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMicrosoftSharepointConfigurationStreamFormatParquetFormatArgs:
    def __init__(__self__, *,
                 decimal_as_float: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")

    @decimal_as_float.setter
    def decimal_as_float(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decimal_as_float", value)


@pulumi.input_type
class SourceMicrosoftTeamsConfigurationArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input[str] period: Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
        :param pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Microsoft
        """
        pulumi.set(__self__, "period", period)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate to Microsoft
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceMicrosoftTeamsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_microsoft: Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftArgs']] = None,
                 authenticate_via_microsoft_o_auth20: Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20Args']] = None):
        if authenticate_via_microsoft is not None:
            pulumi.set(__self__, "authenticate_via_microsoft", authenticate_via_microsoft)
        if authenticate_via_microsoft_o_auth20 is not None:
            pulumi.set(__self__, "authenticate_via_microsoft_o_auth20", authenticate_via_microsoft_o_auth20)

    @property
    @pulumi.getter(name="authenticateViaMicrosoft")
    def authenticate_via_microsoft(self) -> Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftArgs']]:
        return pulumi.get(self, "authenticate_via_microsoft")

    @authenticate_via_microsoft.setter
    def authenticate_via_microsoft(self, value: Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftArgs']]):
        pulumi.set(self, "authenticate_via_microsoft", value)

    @property
    @pulumi.getter(name="authenticateViaMicrosoftOAuth20")
    def authenticate_via_microsoft_o_auth20(self) -> Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20Args']]:
        return pulumi.get(self, "authenticate_via_microsoft_o_auth20")

    @authenticate_via_microsoft_o_auth20.setter
    def authenticate_via_microsoft_o_auth20(self, value: Optional[pulumi.Input['SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20Args']]):
        pulumi.set(self, "authenticate_via_microsoft_o_auth20", value)


@pulumi.input_type
class SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Microsoft Teams developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Microsoft Teams developer application.
        :param pulumi.Input[str] tenant_id: A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the  next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the  next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 tenant_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Microsoft Teams developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Microsoft Teams developer application.
        :param pulumi.Input[str] refresh_token: A Refresh Token to renew the expired Access Token.
        :param pulumi.Input[str] tenant_id: A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the  next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        A Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the  next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class SourceMixpanelConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceMixpanelConfigurationCredentialsArgs'],
                 attribution_window: Optional[pulumi.Input[int]] = None,
                 date_window_size: Optional[pulumi.Input[int]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 project_timezone: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 select_properties_by_default: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMixpanelConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Mixpanel
        :param pulumi.Input[int] attribution_window: A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days. (This value should be non-negative integer). Default: 5
        :param pulumi.Input[int] date_window_size: Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment. (This value should be positive integer). Default: 30
        :param pulumi.Input[str] end_date: The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
        :param pulumi.Input[str] project_timezone: Time zone in which integer date times are stored. The project timezone may be found in the project settings in the <a href="https://help.mixpanel.com/hc/en-us/articles/115004547203-Manage-Timezones-for-Projects-in-Mixpanel">Mixpanel console</a>. Default: "US/Pacific"
        :param pulumi.Input[str] region: The region of mixpanel domain instance either US or EU. must be one of ["US", "EU"]; Default: "US"
        :param pulumi.Input[bool] select_properties_by_default: Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored. Default: true
        :param pulumi.Input[str] start_date: The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
        """
        pulumi.set(__self__, "credentials", credentials)
        if attribution_window is not None:
            pulumi.set(__self__, "attribution_window", attribution_window)
        if date_window_size is not None:
            pulumi.set(__self__, "date_window_size", date_window_size)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if project_timezone is not None:
            pulumi.set(__self__, "project_timezone", project_timezone)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if select_properties_by_default is not None:
            pulumi.set(__self__, "select_properties_by_default", select_properties_by_default)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceMixpanelConfigurationCredentialsArgs']:
        """
        Choose how to authenticate to Mixpanel
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceMixpanelConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="attributionWindow")
    def attribution_window(self) -> Optional[pulumi.Input[int]]:
        """
        A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days. (This value should be non-negative integer). Default: 5
        """
        return pulumi.get(self, "attribution_window")

    @attribution_window.setter
    def attribution_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "attribution_window", value)

    @property
    @pulumi.getter(name="dateWindowSize")
    def date_window_size(self) -> Optional[pulumi.Input[int]]:
        """
        Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment. (This value should be positive integer). Default: 30
        """
        return pulumi.get(self, "date_window_size")

    @date_window_size.setter
    def date_window_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "date_window_size", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="projectTimezone")
    def project_timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone in which integer date times are stored. The project timezone may be found in the project settings in the <a href="https://help.mixpanel.com/hc/en-us/articles/115004547203-Manage-Timezones-for-Projects-in-Mixpanel">Mixpanel console</a>. Default: "US/Pacific"
        """
        return pulumi.get(self, "project_timezone")

    @project_timezone.setter
    def project_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_timezone", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of mixpanel domain instance either US or EU. must be one of ["US", "EU"]; Default: "US"
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="selectPropertiesByDefault")
    def select_properties_by_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored. Default: true
        """
        return pulumi.get(self, "select_properties_by_default")

    @select_properties_by_default.setter
    def select_properties_by_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "select_properties_by_default", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceMixpanelConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 project_secret: Optional[pulumi.Input['SourceMixpanelConfigurationCredentialsProjectSecretArgs']] = None,
                 service_account: Optional[pulumi.Input['SourceMixpanelConfigurationCredentialsServiceAccountArgs']] = None):
        if project_secret is not None:
            pulumi.set(__self__, "project_secret", project_secret)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="projectSecret")
    def project_secret(self) -> Optional[pulumi.Input['SourceMixpanelConfigurationCredentialsProjectSecretArgs']]:
        return pulumi.get(self, "project_secret")

    @project_secret.setter
    def project_secret(self, value: Optional[pulumi.Input['SourceMixpanelConfigurationCredentialsProjectSecretArgs']]):
        pulumi.set(self, "project_secret", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input['SourceMixpanelConfigurationCredentialsServiceAccountArgs']]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input['SourceMixpanelConfigurationCredentialsServiceAccountArgs']]):
        pulumi.set(self, "service_account", value)


@pulumi.input_type
class SourceMixpanelConfigurationCredentialsProjectSecretArgs:
    def __init__(__self__, *,
                 api_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_secret: Mixpanel project secret. See the <a href="https://developer.mixpanel.com/reference/project-secret#managing-a-projects-secret">docs</a> for more information on how to obtain this.
        """
        pulumi.set(__self__, "api_secret", api_secret)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[str]:
        """
        Mixpanel project secret. See the <a href="https://developer.mixpanel.com/reference/project-secret#managing-a-projects-secret">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_secret", value)


@pulumi.input_type
class SourceMixpanelConfigurationCredentialsServiceAccountArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[int],
                 secret: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[int] project_id: Your project ID number. See the <a href="https://help.mixpanel.com/hc/en-us/articles/115004490503-Project-Settings#project-id">docs</a> for more information on how to obtain this.
        :param pulumi.Input[str] secret: Mixpanel Service Account Secret. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        :param pulumi.Input[str] username: Mixpanel Service Account Username. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[int]:
        """
        Your project ID number. See the <a href="https://help.mixpanel.com/hc/en-us/articles/115004490503-Project-Settings#project-id">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        Mixpanel Service Account Secret. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Mixpanel Service Account Username. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SourceMondayConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceMondayConfigurationCredentialsArgs']] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceMondayConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceMondayConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceMondayConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['SourceMondayConfigurationCredentialsApiTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceMondayConfigurationCredentialsOAuth20Args']] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['SourceMondayConfigurationCredentialsApiTokenArgs']]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['SourceMondayConfigurationCredentialsApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceMondayConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceMondayConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceMondayConfigurationCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: API Token for making authenticated requests.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        API Token for making authenticated requests.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)


@pulumi.input_type
class SourceMondayConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 subdomain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The Client ID of your OAuth application.
        :param pulumi.Input[str] client_secret: The Client Secret of your OAuth application.
        :param pulumi.Input[str] subdomain: Slug/subdomain of the account, or the first part of the URL that comes before .monday.com. Default: ""
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[str]]:
        """
        Slug/subdomain of the account, or the first part of the URL that comes before .monday.com. Default: ""
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subdomain", value)


@pulumi.input_type
class SourceMongodbInternalPocConfigurationArgs:
    def __init__(__self__, *,
                 auth_source: Optional[pulumi.Input[str]] = None,
                 connection_string: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 replica_set: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_source: The authentication source where the user information is stored. Default: "admin"
        :param pulumi.Input[str] connection_string: The connection string of the database that you want to replicate..
        :param pulumi.Input[str] password: The password associated with this username.
        :param pulumi.Input[str] replica_set: The name of the replica set to be replicated.
        :param pulumi.Input[str] user: The username which is used to access the database.
        """
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication source where the user information is stored. Default: "admin"
        """
        return pulumi.get(self, "auth_source")

    @auth_source.setter
    def auth_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_source", value)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        """
        The connection string of the database that you want to replicate..
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the replica set to be replicated.
        """
        return pulumi.get(self, "replica_set")

    @replica_set.setter
    def replica_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class SourceMongodbV2ConfigurationArgs:
    def __init__(__self__, *,
                 database_config: pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigArgs'],
                 discover_sample_size: Optional[pulumi.Input[int]] = None,
                 initial_waiting_seconds: Optional[pulumi.Input[int]] = None,
                 invalid_cdc_cursor_position_behavior: Optional[pulumi.Input[str]] = None,
                 queue_size: Optional[pulumi.Input[int]] = None,
                 update_capture_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigArgs'] database_config: Configures the MongoDB cluster type.
        :param pulumi.Input[int] discover_sample_size: The maximum number of documents to sample when attempting to discover the unique fields for a collection. Default: 10000
        :param pulumi.Input[int] initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Default: 300
        :param pulumi.Input[str] invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param pulumi.Input[int] queue_size: The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        :param pulumi.Input[str] update_capture_mode: Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images. must be one of ["Lookup", "Post Image"]; Default: "Lookup"
        """
        pulumi.set(__self__, "database_config", database_config)
        if discover_sample_size is not None:
            pulumi.set(__self__, "discover_sample_size", discover_sample_size)
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)
        if update_capture_mode is not None:
            pulumi.set(__self__, "update_capture_mode", update_capture_mode)

    @property
    @pulumi.getter(name="databaseConfig")
    def database_config(self) -> pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigArgs']:
        """
        Configures the MongoDB cluster type.
        """
        return pulumi.get(self, "database_config")

    @database_config.setter
    def database_config(self, value: pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigArgs']):
        pulumi.set(self, "database_config", value)

    @property
    @pulumi.getter(name="discoverSampleSize")
    def discover_sample_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of documents to sample when attempting to discover the unique fields for a collection. Default: 10000
        """
        return pulumi.get(self, "discover_sample_size")

    @discover_sample_size.setter
    def discover_sample_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "discover_sample_size", value)

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Default: 300
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @initial_waiting_seconds.setter
    def initial_waiting_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_waiting_seconds", value)

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @invalid_cdc_cursor_position_behavior.setter
    def invalid_cdc_cursor_position_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_cdc_cursor_position_behavior", value)

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        return pulumi.get(self, "queue_size")

    @queue_size.setter
    def queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_size", value)

    @property
    @pulumi.getter(name="updateCaptureMode")
    def update_capture_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images. must be one of ["Lookup", "Post Image"]; Default: "Lookup"
        """
        return pulumi.get(self, "update_capture_mode")

    @update_capture_mode.setter
    def update_capture_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_capture_mode", value)


@pulumi.input_type
class SourceMongodbV2ConfigurationDatabaseConfigArgs:
    def __init__(__self__, *,
                 mongo_db_atlas_replica_set: Optional[pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs']] = None,
                 self_managed_replica_set: Optional[pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs']] = None):
        """
        :param pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs'] mongo_db_atlas_replica_set: MongoDB Atlas-hosted cluster configured as a replica set
        :param pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs'] self_managed_replica_set: MongoDB self-hosted cluster configured as a replica set
        """
        if mongo_db_atlas_replica_set is not None:
            pulumi.set(__self__, "mongo_db_atlas_replica_set", mongo_db_atlas_replica_set)
        if self_managed_replica_set is not None:
            pulumi.set(__self__, "self_managed_replica_set", self_managed_replica_set)

    @property
    @pulumi.getter(name="mongoDbAtlasReplicaSet")
    def mongo_db_atlas_replica_set(self) -> Optional[pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs']]:
        """
        MongoDB Atlas-hosted cluster configured as a replica set
        """
        return pulumi.get(self, "mongo_db_atlas_replica_set")

    @mongo_db_atlas_replica_set.setter
    def mongo_db_atlas_replica_set(self, value: Optional[pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs']]):
        pulumi.set(self, "mongo_db_atlas_replica_set", value)

    @property
    @pulumi.getter(name="selfManagedReplicaSet")
    def self_managed_replica_set(self) -> Optional[pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs']]:
        """
        MongoDB self-hosted cluster configured as a replica set
        """
        return pulumi.get(self, "self_managed_replica_set")

    @self_managed_replica_set.setter
    def self_managed_replica_set(self, value: Optional[pulumi.Input['SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs']]):
        pulumi.set(self, "self_managed_replica_set", value)


@pulumi.input_type
class SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[str],
                 database: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 auth_source: Optional[pulumi.Input[str]] = None,
                 schema_enforced: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] connection_string: The connection string of the cluster that you want to replicate.
        :param pulumi.Input[str] database: The name of the MongoDB database that contains the collection(s) to replicate.
        :param pulumi.Input[str] password: The password associated with this username.
        :param pulumi.Input[str] username: The username which is used to access the database.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] auth_source: The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details. Default: "admin"
        :param pulumi.Input[bool] schema_enforced: When enabled, syncs will validate and structure records against the stream's schema. Default: true
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if schema_enforced is not None:
            pulumi.set(__self__, "schema_enforced", schema_enforced)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[str]:
        """
        The connection string of the cluster that you want to replicate.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the MongoDB database that contains the collection(s) to replicate.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details. Default: "admin"
        """
        return pulumi.get(self, "auth_source")

    @auth_source.setter
    def auth_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_source", value)

    @property
    @pulumi.getter(name="schemaEnforced")
    def schema_enforced(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will validate and structure records against the stream's schema. Default: true
        """
        return pulumi.get(self, "schema_enforced")

    @schema_enforced.setter
    def schema_enforced(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schema_enforced", value)


@pulumi.input_type
class SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[str],
                 database: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 auth_source: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 schema_enforced: Optional[pulumi.Input[bool]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_string: The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
        :param pulumi.Input[str] database: The name of the MongoDB database that contains the collection(s) to replicate.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] auth_source: The authentication source where the user information is stored. Default: "admin"
        :param pulumi.Input[str] password: The password associated with this username.
        :param pulumi.Input[bool] schema_enforced: When enabled, syncs will validate and structure records against the stream's schema. Default: true
        :param pulumi.Input[str] username: The username which is used to access the database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if schema_enforced is not None:
            pulumi.set(__self__, "schema_enforced", schema_enforced)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[str]:
        """
        The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the MongoDB database that contains the collection(s) to replicate.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[pulumi.Input[str]]:
        """
        The authentication source where the user information is stored. Default: "admin"
        """
        return pulumi.get(self, "auth_source")

    @auth_source.setter
    def auth_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_source", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="schemaEnforced")
    def schema_enforced(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will validate and structure records against the stream's schema. Default: true
        """
        return pulumi.get(self, "schema_enforced")

    @schema_enforced.setter
    def schema_enforced(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schema_enforced", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SourceMssqlConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 port: pulumi.Input[int],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 replication_method: Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodArgs']] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_method: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: The name of the database.
        :param pulumi.Input[str] host: The hostname of the database.
        :param pulumi.Input[str] password: The password associated with the username.
        :param pulumi.Input[int] port: The port of the database.
        :param pulumi.Input[str] username: The username which is used to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input['SourceMssqlConfigurationReplicationMethodArgs'] replication_method: Configures how data is extracted from the database.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemas: The list of schemas to sync from. Defaults to user. Case sensitive.
        :param pulumi.Input['SourceMssqlConfigurationSslMethodArgs'] ssl_method: The encryption method which is used when communicating with the database.
        :param pulumi.Input['SourceMssqlConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if replication_method is not None:
            pulumi.set(__self__, "replication_method", replication_method)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if ssl_method is not None:
            pulumi.set(__self__, "ssl_method", ssl_method)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port of the database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter(name="replicationMethod")
    def replication_method(self) -> Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodArgs']]:
        """
        Configures how data is extracted from the database.
        """
        return pulumi.get(self, "replication_method")

    @replication_method.setter
    def replication_method(self, value: Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodArgs']]):
        pulumi.set(self, "replication_method", value)

    @property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of schemas to sync from. Defaults to user. Case sensitive.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemas", value)

    @property
    @pulumi.getter(name="sslMethod")
    def ssl_method(self) -> Optional[pulumi.Input['SourceMssqlConfigurationSslMethodArgs']]:
        """
        The encryption method which is used when communicating with the database.
        """
        return pulumi.get(self, "ssl_method")

    @ssl_method.setter
    def ssl_method(self, value: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodArgs']]):
        pulumi.set(self, "ssl_method", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class SourceMssqlConfigurationReplicationMethodArgs:
    def __init__(__self__, *,
                 read_changes_using_change_data_capture_cdc: Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs']] = None,
                 scan_changes_with_user_defined_cursor: Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']] = None):
        """
        :param pulumi.Input['SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs'] read_changes_using_change_data_capture_cdc: <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
        :param pulumi.Input['SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs'] scan_changes_with_user_defined_cursor: Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        if read_changes_using_change_data_capture_cdc is not None:
            pulumi.set(__self__, "read_changes_using_change_data_capture_cdc", read_changes_using_change_data_capture_cdc)
        if scan_changes_with_user_defined_cursor is not None:
            pulumi.set(__self__, "scan_changes_with_user_defined_cursor", scan_changes_with_user_defined_cursor)

    @property
    @pulumi.getter(name="readChangesUsingChangeDataCaptureCdc")
    def read_changes_using_change_data_capture_cdc(self) -> Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs']]:
        """
        <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
        """
        return pulumi.get(self, "read_changes_using_change_data_capture_cdc")

    @read_changes_using_change_data_capture_cdc.setter
    def read_changes_using_change_data_capture_cdc(self, value: Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs']]):
        pulumi.set(self, "read_changes_using_change_data_capture_cdc", value)

    @property
    @pulumi.getter(name="scanChangesWithUserDefinedCursor")
    def scan_changes_with_user_defined_cursor(self) -> Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']]:
        """
        Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        return pulumi.get(self, "scan_changes_with_user_defined_cursor")

    @scan_changes_with_user_defined_cursor.setter
    def scan_changes_with_user_defined_cursor(self, value: Optional[pulumi.Input['SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']]):
        pulumi.set(self, "scan_changes_with_user_defined_cursor", value)


@pulumi.input_type
class SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs:
    def __init__(__self__, *,
                 initial_waiting_seconds: Optional[pulumi.Input[int]] = None,
                 invalid_cdc_cursor_position_behavior: Optional[pulumi.Input[str]] = None,
                 queue_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        :param pulumi.Input[str] invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param pulumi.Input[int] queue_size: The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @initial_waiting_seconds.setter
    def initial_waiting_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_waiting_seconds", value)

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @invalid_cdc_cursor_position_behavior.setter
    def invalid_cdc_cursor_position_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_cdc_cursor_position_behavior", value)

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        return pulumi.get(self, "queue_size")

    @queue_size.setter
    def queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_size", value)


@pulumi.input_type
class SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMssqlConfigurationSslMethodArgs:
    def __init__(__self__, *,
                 encrypted_trust_server_certificate: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs']] = None,
                 encrypted_verify_certificate: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs']] = None,
                 unencrypted: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodUnencryptedArgs']] = None):
        """
        :param pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs'] encrypted_trust_server_certificate: Use the certificate provided by the server without verification. (For testing purposes only!)
        :param pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs'] encrypted_verify_certificate: Verify and use the certificate provided by the server.
        :param pulumi.Input['SourceMssqlConfigurationSslMethodUnencryptedArgs'] unencrypted: Data transfer will not be encrypted.
        """
        if encrypted_trust_server_certificate is not None:
            pulumi.set(__self__, "encrypted_trust_server_certificate", encrypted_trust_server_certificate)
        if encrypted_verify_certificate is not None:
            pulumi.set(__self__, "encrypted_verify_certificate", encrypted_verify_certificate)
        if unencrypted is not None:
            pulumi.set(__self__, "unencrypted", unencrypted)

    @property
    @pulumi.getter(name="encryptedTrustServerCertificate")
    def encrypted_trust_server_certificate(self) -> Optional[pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs']]:
        """
        Use the certificate provided by the server without verification. (For testing purposes only!)
        """
        return pulumi.get(self, "encrypted_trust_server_certificate")

    @encrypted_trust_server_certificate.setter
    def encrypted_trust_server_certificate(self, value: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs']]):
        pulumi.set(self, "encrypted_trust_server_certificate", value)

    @property
    @pulumi.getter(name="encryptedVerifyCertificate")
    def encrypted_verify_certificate(self) -> Optional[pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs']]:
        """
        Verify and use the certificate provided by the server.
        """
        return pulumi.get(self, "encrypted_verify_certificate")

    @encrypted_verify_certificate.setter
    def encrypted_verify_certificate(self, value: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs']]):
        pulumi.set(self, "encrypted_verify_certificate", value)

    @property
    @pulumi.getter
    def unencrypted(self) -> Optional[pulumi.Input['SourceMssqlConfigurationSslMethodUnencryptedArgs']]:
        """
        Data transfer will not be encrypted.
        """
        return pulumi.get(self, "unencrypted")

    @unencrypted.setter
    def unencrypted(self, value: Optional[pulumi.Input['SourceMssqlConfigurationSslMethodUnencryptedArgs']]):
        pulumi.set(self, "unencrypted", value)


@pulumi.input_type
class SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs:
    def __init__(__self__, *,
                 certificate: Optional[pulumi.Input[str]] = None,
                 host_name_in_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate: certificate of the server, or of the CA that signed the server certificate
        :param pulumi.Input[str] host_name_in_certificate: Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if host_name_in_certificate is not None:
            pulumi.set(__self__, "host_name_in_certificate", host_name_in_certificate)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        certificate of the server, or of the CA that signed the server certificate
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="hostNameInCertificate")
    def host_name_in_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        return pulumi.get(self, "host_name_in_certificate")

    @host_name_in_certificate.setter
    def host_name_in_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name_in_certificate", value)


@pulumi.input_type
class SourceMssqlConfigurationSslMethodUnencryptedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMssqlConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['SourceMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class SourceMssqlConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMssqlConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceMssqlConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceMyHoursConfigurationArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 password: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 logs_batch_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] email: Your My Hours username
        :param pulumi.Input[str] password: The password associated to the username
        :param pulumi.Input[str] start_date: Start date for collecting time logs
        :param pulumi.Input[int] logs_batch_size: Pagination size used for retrieving logs in days. Default: 30
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "start_date", start_date)
        if logs_batch_size is not None:
            pulumi.set(__self__, "logs_batch_size", logs_batch_size)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        Your My Hours username
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password associated to the username
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start date for collecting time logs
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="logsBatchSize")
    def logs_batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Pagination size used for retrieving logs in days. Default: 30
        """
        return pulumi.get(self, "logs_batch_size")

    @logs_batch_size.setter
    def logs_batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "logs_batch_size", value)


@pulumi.input_type
class SourceMysqlConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 replication_method: pulumi.Input['SourceMysqlConfigurationReplicationMethodArgs'],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 ssl_mode: Optional[pulumi.Input['SourceMysqlConfigurationSslModeArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: The database name.
        :param pulumi.Input[str] host: The host name of the database.
        :param pulumi.Input['SourceMysqlConfigurationReplicationMethodArgs'] replication_method: Configures how data is extracted from the database.
        :param pulumi.Input[str] username: The username which is used to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
        :param pulumi.Input[str] password: The password associated with the username.
        :param pulumi.Input[int] port: The port to connect to. Default: 3306
        :param pulumi.Input['SourceMysqlConfigurationSslModeArgs'] ssl_mode: SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
        :param pulumi.Input['SourceMysqlConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "replication_method", replication_method)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host name of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="replicationMethod")
    def replication_method(self) -> pulumi.Input['SourceMysqlConfigurationReplicationMethodArgs']:
        """
        Configures how data is extracted from the database.
        """
        return pulumi.get(self, "replication_method")

    @replication_method.setter
    def replication_method(self, value: pulumi.Input['SourceMysqlConfigurationReplicationMethodArgs']):
        pulumi.set(self, "replication_method", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to connect to. Default: 3306
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input['SourceMysqlConfigurationSslModeArgs']]:
        """
        SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input['SourceMysqlConfigurationSslModeArgs']]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class SourceMysqlConfigurationReplicationMethodArgs:
    def __init__(__self__, *,
                 read_changes_using_binary_log_cdc: Optional[pulumi.Input['SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs']] = None,
                 scan_changes_with_user_defined_cursor: Optional[pulumi.Input['SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']] = None):
        """
        :param pulumi.Input['SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs'] read_changes_using_binary_log_cdc: <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the MySQL <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">binary log</a>. This must be enabled on your database.
        :param pulumi.Input['SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs'] scan_changes_with_user_defined_cursor: Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        if read_changes_using_binary_log_cdc is not None:
            pulumi.set(__self__, "read_changes_using_binary_log_cdc", read_changes_using_binary_log_cdc)
        if scan_changes_with_user_defined_cursor is not None:
            pulumi.set(__self__, "scan_changes_with_user_defined_cursor", scan_changes_with_user_defined_cursor)

    @property
    @pulumi.getter(name="readChangesUsingBinaryLogCdc")
    def read_changes_using_binary_log_cdc(self) -> Optional[pulumi.Input['SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs']]:
        """
        <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the MySQL <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">binary log</a>. This must be enabled on your database.
        """
        return pulumi.get(self, "read_changes_using_binary_log_cdc")

    @read_changes_using_binary_log_cdc.setter
    def read_changes_using_binary_log_cdc(self, value: Optional[pulumi.Input['SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs']]):
        pulumi.set(self, "read_changes_using_binary_log_cdc", value)

    @property
    @pulumi.getter(name="scanChangesWithUserDefinedCursor")
    def scan_changes_with_user_defined_cursor(self) -> Optional[pulumi.Input['SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']]:
        """
        Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        return pulumi.get(self, "scan_changes_with_user_defined_cursor")

    @scan_changes_with_user_defined_cursor.setter
    def scan_changes_with_user_defined_cursor(self, value: Optional[pulumi.Input['SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']]):
        pulumi.set(self, "scan_changes_with_user_defined_cursor", value)


@pulumi.input_type
class SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs:
    def __init__(__self__, *,
                 initial_waiting_seconds: Optional[pulumi.Input[int]] = None,
                 invalid_cdc_cursor_position_behavior: Optional[pulumi.Input[str]] = None,
                 server_time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        :param pulumi.Input[str] invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param pulumi.Input[str] server_time_zone: Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
        """
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if server_time_zone is not None:
            pulumi.set(__self__, "server_time_zone", server_time_zone)

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @initial_waiting_seconds.setter
    def initial_waiting_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_waiting_seconds", value)

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @invalid_cdc_cursor_position_behavior.setter
    def invalid_cdc_cursor_position_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_cdc_cursor_position_behavior", value)

    @property
    @pulumi.getter(name="serverTimeZone")
    def server_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
        """
        return pulumi.get(self, "server_time_zone")

    @server_time_zone.setter
    def server_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_time_zone", value)


@pulumi.input_type
class SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMysqlConfigurationSslModeArgs:
    def __init__(__self__, *,
                 preferred: Optional[pulumi.Input['SourceMysqlConfigurationSslModePreferredArgs']] = None,
                 required: Optional[pulumi.Input['SourceMysqlConfigurationSslModeRequiredArgs']] = None,
                 verify_ca: Optional[pulumi.Input['SourceMysqlConfigurationSslModeVerifyCaArgs']] = None,
                 verify_identity: Optional[pulumi.Input['SourceMysqlConfigurationSslModeVerifyIdentityArgs']] = None):
        """
        :param pulumi.Input['SourceMysqlConfigurationSslModePreferredArgs'] preferred: Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
        :param pulumi.Input['SourceMysqlConfigurationSslModeRequiredArgs'] required: Always connect with SSL. If the MySQL server doesnt support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
        :param pulumi.Input['SourceMysqlConfigurationSslModeVerifyCaArgs'] verify_ca: Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
        :param pulumi.Input['SourceMysqlConfigurationSslModeVerifyIdentityArgs'] verify_identity: Always connect with SSL. Verify both CA and Hostname.
        """
        if preferred is not None:
            pulumi.set(__self__, "preferred", preferred)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_identity is not None:
            pulumi.set(__self__, "verify_identity", verify_identity)

    @property
    @pulumi.getter
    def preferred(self) -> Optional[pulumi.Input['SourceMysqlConfigurationSslModePreferredArgs']]:
        """
        Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
        """
        return pulumi.get(self, "preferred")

    @preferred.setter
    def preferred(self, value: Optional[pulumi.Input['SourceMysqlConfigurationSslModePreferredArgs']]):
        pulumi.set(self, "preferred", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input['SourceMysqlConfigurationSslModeRequiredArgs']]:
        """
        Always connect with SSL. If the MySQL server doesnt support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input['SourceMysqlConfigurationSslModeRequiredArgs']]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional[pulumi.Input['SourceMysqlConfigurationSslModeVerifyCaArgs']]:
        """
        Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
        """
        return pulumi.get(self, "verify_ca")

    @verify_ca.setter
    def verify_ca(self, value: Optional[pulumi.Input['SourceMysqlConfigurationSslModeVerifyCaArgs']]):
        pulumi.set(self, "verify_ca", value)

    @property
    @pulumi.getter(name="verifyIdentity")
    def verify_identity(self) -> Optional[pulumi.Input['SourceMysqlConfigurationSslModeVerifyIdentityArgs']]:
        """
        Always connect with SSL. Verify both CA and Hostname.
        """
        return pulumi.get(self, "verify_identity")

    @verify_identity.setter
    def verify_identity(self, value: Optional[pulumi.Input['SourceMysqlConfigurationSslModeVerifyIdentityArgs']]):
        pulumi.set(self, "verify_identity", value)


@pulumi.input_type
class SourceMysqlConfigurationSslModePreferredArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMysqlConfigurationSslModeRequiredArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMysqlConfigurationSslModeVerifyCaArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_certificate: Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        :param pulumi.Input[str] client_key: Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        :param pulumi.Input[str] client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class SourceMysqlConfigurationSslModeVerifyIdentityArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] client_certificate: Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        :param pulumi.Input[str] client_key: Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        :param pulumi.Input[str] client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class SourceMysqlConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['SourceMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class SourceMysqlConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceMysqlConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceMysqlConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceNetsuiteConfigurationArgs:
    def __init__(__self__, *,
                 consumer_key: pulumi.Input[str],
                 consumer_secret: pulumi.Input[str],
                 realm: pulumi.Input[str],
                 start_datetime: pulumi.Input[str],
                 token_key: pulumi.Input[str],
                 token_secret: pulumi.Input[str],
                 object_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] consumer_key: Consumer key associated with your integration
        :param pulumi.Input[str] consumer_secret: Consumer secret associated with your integration
        :param pulumi.Input[str] realm: Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
        :param pulumi.Input[str] start_datetime: Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
        :param pulumi.Input[str] token_key: Access token key
        :param pulumi.Input[str] token_secret: Access token secret
        :param pulumi.Input[Sequence[pulumi.Input[str]]] object_types: The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
        :param pulumi.Input[int] window_in_days: The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data. Default: 30
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "realm", realm)
        pulumi.set(__self__, "start_datetime", start_datetime)
        pulumi.set(__self__, "token_key", token_key)
        pulumi.set(__self__, "token_secret", token_secret)
        if object_types is not None:
            pulumi.set(__self__, "object_types", object_types)
        if window_in_days is not None:
            pulumi.set(__self__, "window_in_days", window_in_days)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        Consumer key associated with your integration
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> pulumi.Input[str]:
        """
        Consumer secret associated with your integration
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_secret", value)

    @property
    @pulumi.getter
    def realm(self) -> pulumi.Input[str]:
        """
        Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: pulumi.Input[str]):
        pulumi.set(self, "realm", value)

    @property
    @pulumi.getter(name="startDatetime")
    def start_datetime(self) -> pulumi.Input[str]:
        """
        Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
        """
        return pulumi.get(self, "start_datetime")

    @start_datetime.setter
    def start_datetime(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_datetime", value)

    @property
    @pulumi.getter(name="tokenKey")
    def token_key(self) -> pulumi.Input[str]:
        """
        Access token key
        """
        return pulumi.get(self, "token_key")

    @token_key.setter
    def token_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_key", value)

    @property
    @pulumi.getter(name="tokenSecret")
    def token_secret(self) -> pulumi.Input[str]:
        """
        Access token secret
        """
        return pulumi.get(self, "token_secret")

    @token_secret.setter
    def token_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_secret", value)

    @property
    @pulumi.getter(name="objectTypes")
    def object_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
        """
        return pulumi.get(self, "object_types")

    @object_types.setter
    def object_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "object_types", value)

    @property
    @pulumi.getter(name="windowInDays")
    def window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data. Default: 30
        """
        return pulumi.get(self, "window_in_days")

    @window_in_days.setter
    def window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_in_days", value)


@pulumi.input_type
class SourceNotionConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceNotionConfigurationCredentialsArgs']] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceNotionConfigurationCredentialsArgs'] credentials: Choose either OAuth (recommended for Airbyte Cloud) or Access Token. See our <a href='https://docs.airbyte.com/integrations/sources/notion#setup-guide'>docs</a> for more information.
        :param pulumi.Input[str] start_date: UTC date and time in the format YYYY-MM-DDTHH:MM:SS.000Z. During incremental sync, any data generated before this date will not be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceNotionConfigurationCredentialsArgs']]:
        """
        Choose either OAuth (recommended for Airbyte Cloud) or Access Token. See our <a href='https://docs.airbyte.com/integrations/sources/notion#setup-guide'>docs</a> for more information.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceNotionConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format YYYY-MM-DDTHH:MM:SS.000Z. During incremental sync, any data generated before this date will not be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceNotionConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input['SourceNotionConfigurationCredentialsAccessTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceNotionConfigurationCredentialsOAuth20Args']] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['SourceNotionConfigurationCredentialsAccessTokenArgs']]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['SourceNotionConfigurationCredentialsAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceNotionConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceNotionConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceNotionConfigurationCredentialsAccessTokenArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: The Access Token for your private Notion integration. See the <a href='https://docs.airbyte.com/integrations/sources/notion#step-1-create-an-integration-in-notion'>docs</a> for more information on how to obtain this token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        The Access Token for your private Notion integration. See the <a href='https://docs.airbyte.com/integrations/sources/notion#step-1-create-an-integration-in-notion'>docs</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class SourceNotionConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: The Access Token received by completing the OAuth flow for your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        :param pulumi.Input[str] client_id: The Client ID of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        :param pulumi.Input[str] client_secret: The Client Secret of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The Access Token received by completing the OAuth flow for your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceNytimesConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 period: pulumi.Input[int],
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 share_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: API Key
        :param pulumi.Input[int] period: Period of time (in days). must be one of ["1", "7", "30"]
        :param pulumi.Input[str] start_date: Start date to begin the article retrieval (format YYYY-MM)
        :param pulumi.Input[str] end_date: End date to stop the article retrieval (format YYYY-MM)
        :param pulumi.Input[str] share_type: Share Type. must be one of ["facebook"]
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if share_type is not None:
            pulumi.set(__self__, "share_type", share_type)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[int]:
        """
        Period of time (in days). must be one of ["1", "7", "30"]
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[int]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start date to begin the article retrieval (format YYYY-MM)
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        End date to stop the article retrieval (format YYYY-MM)
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="shareType")
    def share_type(self) -> Optional[pulumi.Input[str]]:
        """
        Share Type. must be one of ["facebook"]
        """
        return pulumi.get(self, "share_type")

    @share_type.setter
    def share_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_type", value)


@pulumi.input_type
class SourceOktaConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceOktaConfigurationCredentialsArgs']] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: The Okta domain. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to find it.
        :param pulumi.Input[str] start_date: UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceOktaConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceOktaConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The Okta domain. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to find it.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceOktaConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['SourceOktaConfigurationCredentialsApiTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceOktaConfigurationCredentialsOAuth20Args']] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['SourceOktaConfigurationCredentialsApiTokenArgs']]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['SourceOktaConfigurationCredentialsApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceOktaConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceOktaConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceOktaConfigurationCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: An Okta token. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to generate it.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        An Okta token. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)


@pulumi.input_type
class SourceOktaConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your OAuth application.
        :param pulumi.Input[str] client_secret: The Client Secret of your OAuth application.
        :param pulumi.Input[str] refresh_token: Refresh Token to obtain new Access Token, when it's expired.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token to obtain new Access Token, when it's expired.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceOmnisendConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceOnesignalConfigurationArgs:
    def __init__(__self__, *,
                 applications: pulumi.Input[Sequence[pulumi.Input['SourceOnesignalConfigurationApplicationArgs']]],
                 outcome_names: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 user_auth_key: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SourceOnesignalConfigurationApplicationArgs']]] applications: Applications keys, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys">docs</a> for more information on how to obtain this data
        :param pulumi.Input[str] outcome_names: Comma-separated list of names and the value (sum/count) for the returned outcome data. See the <a href="https://documentation.onesignal.com/reference/view-outcomes">docs</a> for more details
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        :param pulumi.Input[str] user_auth_key: OneSignal User Auth Key, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys#user-auth-key">docs</a> for more information on how to obtain this key.
        """
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "outcome_names", outcome_names)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "user_auth_key", user_auth_key)

    @property
    @pulumi.getter
    def applications(self) -> pulumi.Input[Sequence[pulumi.Input['SourceOnesignalConfigurationApplicationArgs']]]:
        """
        Applications keys, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys">docs</a> for more information on how to obtain this data
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: pulumi.Input[Sequence[pulumi.Input['SourceOnesignalConfigurationApplicationArgs']]]):
        pulumi.set(self, "applications", value)

    @property
    @pulumi.getter(name="outcomeNames")
    def outcome_names(self) -> pulumi.Input[str]:
        """
        Comma-separated list of names and the value (sum/count) for the returned outcome data. See the <a href="https://documentation.onesignal.com/reference/view-outcomes">docs</a> for more details
        """
        return pulumi.get(self, "outcome_names")

    @outcome_names.setter
    def outcome_names(self, value: pulumi.Input[str]):
        pulumi.set(self, "outcome_names", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="userAuthKey")
    def user_auth_key(self) -> pulumi.Input[str]:
        """
        OneSignal User Auth Key, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys#user-auth-key">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "user_auth_key")

    @user_auth_key.setter
    def user_auth_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_auth_key", value)


@pulumi.input_type
class SourceOnesignalConfigurationApplicationArgs:
    def __init__(__self__, *,
                 app_api_key: pulumi.Input[str],
                 app_id: pulumi.Input[str],
                 app_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "app_api_key", app_api_key)
        pulumi.set(__self__, "app_id", app_id)
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)

    @property
    @pulumi.getter(name="appApiKey")
    def app_api_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "app_api_key")

    @app_api_key.setter
    def app_api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_api_key", value)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "app_name")

    @app_name.setter
    def app_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_name", value)


@pulumi.input_type
class SourceOracleConfigurationArgs:
    def __init__(__self__, *,
                 encryption: pulumi.Input['SourceOracleConfigurationEncryptionArgs'],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 connection_data: Optional[pulumi.Input['SourceOracleConfigurationConnectionDataArgs']] = None,
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tunnel_method: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input['SourceOracleConfigurationEncryptionArgs'] encryption: The encryption method with is used when communicating with the database.
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: The username which is used to access the database.
        :param pulumi.Input['SourceOracleConfigurationConnectionDataArgs'] connection_data: Connect data that will be used for DB connection
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] password: The password associated with the username.
        :param pulumi.Input[int] port: Port of the database.
               Oracle Corporations recommends the following port numbers:
               1521 - Default listening port for client connections to the listener. 
               2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
               Default: 1521
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemas: The list of schemas to sync from. Defaults to user. Case sensitive.
        :param pulumi.Input['SourceOracleConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "encryption", encryption)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if connection_data is not None:
            pulumi.set(__self__, "connection_data", connection_data)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def encryption(self) -> pulumi.Input['SourceOracleConfigurationEncryptionArgs']:
        """
        The encryption method with is used when communicating with the database.
        """
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: pulumi.Input['SourceOracleConfigurationEncryptionArgs']):
        pulumi.set(self, "encryption", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="connectionData")
    def connection_data(self) -> Optional[pulumi.Input['SourceOracleConfigurationConnectionDataArgs']]:
        """
        Connect data that will be used for DB connection
        """
        return pulumi.get(self, "connection_data")

    @connection_data.setter
    def connection_data(self, value: Optional[pulumi.Input['SourceOracleConfigurationConnectionDataArgs']]):
        pulumi.set(self, "connection_data", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database.
        Oracle Corporations recommends the following port numbers:
        1521 - Default listening port for client connections to the listener. 
        2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
        Default: 1521
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of schemas to sync from. Defaults to user. Case sensitive.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemas", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class SourceOracleConfigurationConnectionDataArgs:
    def __init__(__self__, *,
                 service_name: Optional[pulumi.Input['SourceOracleConfigurationConnectionDataServiceNameArgs']] = None,
                 system_idsid: Optional[pulumi.Input['SourceOracleConfigurationConnectionDataSystemIdsidArgs']] = None):
        """
        :param pulumi.Input['SourceOracleConfigurationConnectionDataServiceNameArgs'] service_name: Use service name
        :param pulumi.Input['SourceOracleConfigurationConnectionDataSystemIdsidArgs'] system_idsid: Use SID (Oracle System Identifier)
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if system_idsid is not None:
            pulumi.set(__self__, "system_idsid", system_idsid)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input['SourceOracleConfigurationConnectionDataServiceNameArgs']]:
        """
        Use service name
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input['SourceOracleConfigurationConnectionDataServiceNameArgs']]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="systemIdsid")
    def system_idsid(self) -> Optional[pulumi.Input['SourceOracleConfigurationConnectionDataSystemIdsidArgs']]:
        """
        Use SID (Oracle System Identifier)
        """
        return pulumi.get(self, "system_idsid")

    @system_idsid.setter
    def system_idsid(self, value: Optional[pulumi.Input['SourceOracleConfigurationConnectionDataSystemIdsidArgs']]):
        pulumi.set(self, "system_idsid", value)


@pulumi.input_type
class SourceOracleConfigurationConnectionDataServiceNameArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str]):
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class SourceOracleConfigurationConnectionDataSystemIdsidArgs:
    def __init__(__self__, *,
                 sid: pulumi.Input[str]):
        pulumi.set(__self__, "sid", sid)

    @property
    @pulumi.getter
    def sid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "sid")

    @sid.setter
    def sid(self, value: pulumi.Input[str]):
        pulumi.set(self, "sid", value)


@pulumi.input_type
class SourceOracleConfigurationEncryptionArgs:
    def __init__(__self__, *,
                 native_network_encryption_nne: Optional[pulumi.Input['SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs']] = None,
                 tls_encrypted_verify_certificate: Optional[pulumi.Input['SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs']] = None):
        """
        :param pulumi.Input['SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs'] native_network_encryption_nne: The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
        :param pulumi.Input['SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs'] tls_encrypted_verify_certificate: Verify and use the certificate provided by the server.
        """
        if native_network_encryption_nne is not None:
            pulumi.set(__self__, "native_network_encryption_nne", native_network_encryption_nne)
        if tls_encrypted_verify_certificate is not None:
            pulumi.set(__self__, "tls_encrypted_verify_certificate", tls_encrypted_verify_certificate)

    @property
    @pulumi.getter(name="nativeNetworkEncryptionNne")
    def native_network_encryption_nne(self) -> Optional[pulumi.Input['SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs']]:
        """
        The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
        """
        return pulumi.get(self, "native_network_encryption_nne")

    @native_network_encryption_nne.setter
    def native_network_encryption_nne(self, value: Optional[pulumi.Input['SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs']]):
        pulumi.set(self, "native_network_encryption_nne", value)

    @property
    @pulumi.getter(name="tlsEncryptedVerifyCertificate")
    def tls_encrypted_verify_certificate(self) -> Optional[pulumi.Input['SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs']]:
        """
        Verify and use the certificate provided by the server.
        """
        return pulumi.get(self, "tls_encrypted_verify_certificate")

    @tls_encrypted_verify_certificate.setter
    def tls_encrypted_verify_certificate(self, value: Optional[pulumi.Input['SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs']]):
        pulumi.set(self, "tls_encrypted_verify_certificate", value)


@pulumi.input_type
class SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs:
    def __init__(__self__, *,
                 encryption_algorithm: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] encryption_algorithm: This parameter defines what encryption algorithm is used. must be one of ["AES256", "RC4_56", "3DES168"]; Default: "AES256"
        """
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter defines what encryption algorithm is used. must be one of ["AES256", "RC4_56", "3DES168"]; Default: "AES256"
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_algorithm", value)


@pulumi.input_type
class SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs:
    def __init__(__self__, *,
                 ssl_certificate: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ssl_certificate: Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
        """
        pulumi.set(__self__, "ssl_certificate", ssl_certificate)

    @property
    @pulumi.getter(name="sslCertificate")
    def ssl_certificate(self) -> pulumi.Input[str]:
        """
        Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
        """
        return pulumi.get(self, "ssl_certificate")

    @ssl_certificate.setter
    def ssl_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssl_certificate", value)


@pulumi.input_type
class SourceOracleConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['SourceOracleConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class SourceOracleConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceOracleConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceOracleConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourceOrbConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 lookback_window_days: Optional[pulumi.Input[int]] = None,
                 numeric_event_properties_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 plan_id: Optional[pulumi.Input[str]] = None,
                 string_event_properties_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subscription_usage_grouping_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Orb API Key, issued from the Orb admin console.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at before this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        :param pulumi.Input[str] end_date: UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at after this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        :param pulumi.Input[int] lookback_window_days: When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        :param pulumi.Input[Sequence[pulumi.Input[str]]] numeric_event_properties_keys: Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        :param pulumi.Input[str] plan_id: Orb Plan ID to filter subscriptions that should have usage fetched.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] string_event_properties_keys: Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        :param pulumi.Input[str] subscription_usage_grouping_key: Property key name to group subscription usage by.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if lookback_window_days is not None:
            pulumi.set(__self__, "lookback_window_days", lookback_window_days)
        if numeric_event_properties_keys is not None:
            pulumi.set(__self__, "numeric_event_properties_keys", numeric_event_properties_keys)
        if plan_id is not None:
            pulumi.set(__self__, "plan_id", plan_id)
        if string_event_properties_keys is not None:
            pulumi.set(__self__, "string_event_properties_keys", string_event_properties_keys)
        if subscription_usage_grouping_key is not None:
            pulumi.set(__self__, "subscription_usage_grouping_key", subscription_usage_grouping_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Orb API Key, issued from the Orb admin console.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at before this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at after this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="lookbackWindowDays")
    def lookback_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        """
        return pulumi.get(self, "lookback_window_days")

    @lookback_window_days.setter
    def lookback_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window_days", value)

    @property
    @pulumi.getter(name="numericEventPropertiesKeys")
    def numeric_event_properties_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        """
        return pulumi.get(self, "numeric_event_properties_keys")

    @numeric_event_properties_keys.setter
    def numeric_event_properties_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "numeric_event_properties_keys", value)

    @property
    @pulumi.getter(name="planId")
    def plan_id(self) -> Optional[pulumi.Input[str]]:
        """
        Orb Plan ID to filter subscriptions that should have usage fetched.
        """
        return pulumi.get(self, "plan_id")

    @plan_id.setter
    def plan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plan_id", value)

    @property
    @pulumi.getter(name="stringEventPropertiesKeys")
    def string_event_properties_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        """
        return pulumi.get(self, "string_event_properties_keys")

    @string_event_properties_keys.setter
    def string_event_properties_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_event_properties_keys", value)

    @property
    @pulumi.getter(name="subscriptionUsageGroupingKey")
    def subscription_usage_grouping_key(self) -> Optional[pulumi.Input[str]]:
        """
        Property key name to group subscription usage by.
        """
        return pulumi.get(self, "subscription_usage_grouping_key")

    @subscription_usage_grouping_key.setter
    def subscription_usage_grouping_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_usage_grouping_key", value)


@pulumi.input_type
class SourceOrbitConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 workspace: pulumi.Input[str],
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Authorizes you to work with Orbit workspaces associated with the token.
        :param pulumi.Input[str] workspace: The unique name of the workspace that your API token is associated with.
        :param pulumi.Input[str] start_date: Date in the format 2022-06-26. Only load members whose last activities are after this date.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "workspace", workspace)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Authorizes you to work with Orbit workspaces associated with the token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def workspace(self) -> pulumi.Input[str]:
        """
        The unique name of the workspace that your API token is associated with.
        """
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: pulumi.Input[str]):
        pulumi.set(self, "workspace", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        Date in the format 2022-06-26. Only load members whose last activities are after this date.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceOutbrainAmplifyConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsArgs'],
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 geo_location_breakdown: Optional[pulumi.Input[str]] = None,
                 report_granularity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsArgs'] credentials: Credentials for making authenticated requests requires either username/password or access_token.
        :param pulumi.Input[str] start_date: Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
        :param pulumi.Input[str] end_date: Date in the format YYYY-MM-DD.
        :param pulumi.Input[str] geo_location_breakdown: The granularity used for geo location data in reports. must be one of ["country", "region", "subregion"]
        :param pulumi.Input[str] report_granularity: The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>. must be one of ["daily", "weekly", "monthly"]
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if geo_location_breakdown is not None:
            pulumi.set(__self__, "geo_location_breakdown", geo_location_breakdown)
        if report_granularity is not None:
            pulumi.set(__self__, "report_granularity", report_granularity)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsArgs']:
        """
        Credentials for making authenticated requests requires either username/password or access_token.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        Date in the format YYYY-MM-DD.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="geoLocationBreakdown")
    def geo_location_breakdown(self) -> Optional[pulumi.Input[str]]:
        """
        The granularity used for geo location data in reports. must be one of ["country", "region", "subregion"]
        """
        return pulumi.get(self, "geo_location_breakdown")

    @geo_location_breakdown.setter
    def geo_location_breakdown(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "geo_location_breakdown", value)

    @property
    @pulumi.getter(name="reportGranularity")
    def report_granularity(self) -> Optional[pulumi.Input[str]]:
        """
        The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>. must be one of ["daily", "weekly", "monthly"]
        """
        return pulumi.get(self, "report_granularity")

    @report_granularity.setter
    def report_granularity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "report_granularity", value)


@pulumi.input_type
class SourceOutbrainAmplifyConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsAccessTokenArgs']] = None,
                 username_password: Optional[pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsUsernamePasswordArgs']] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsAccessTokenArgs']]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsUsernamePasswordArgs']]:
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['SourceOutbrainAmplifyConfigurationCredentialsUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)


@pulumi.input_type
class SourceOutbrainAmplifyConfigurationCredentialsAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceOutbrainAmplifyConfigurationCredentialsUsernamePasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Add Password for authentication.
        :param pulumi.Input[str] username: Add Username for authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Add Password for authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Add Username for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SourceOutreachConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 redirect_uri: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Outreach developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Outreach developer application.
        :param pulumi.Input[str] redirect_uri: A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
        :param pulumi.Input[str] refresh_token: The token for obtaining the new access token.
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "redirect_uri", redirect_uri)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Outreach developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Outreach developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> pulumi.Input[str]:
        """
        A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token for obtaining the new access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourcePaypalTransactionConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 dispute_start_date: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 is_sandbox: Optional[pulumi.Input[bool]] = None,
                 refresh_token: Optional[pulumi.Input[str]] = None,
                 time_window: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Paypal developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Paypal developer application.
        :param pulumi.Input[str] start_date: Start Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. Date must be in range from 3 years till 12 hrs before present time.
        :param pulumi.Input[str] dispute_start_date: Start Date parameter for the list dispute endpoint in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This Start Date must be in range within 180 days before present time, and requires ONLY 3 miliseconds(mandatory). If you don't use this option, it defaults to a start date set 180 days in the past.
        :param pulumi.Input[str] end_date: End Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This can be help you select specific range of time, mainly for test purposes  or data integrity tests. When this is not used, now_utc() is used by the streams. This does not apply to Disputes and Product streams.
        :param pulumi.Input[bool] is_sandbox: Determines whether to use the sandbox or production environment. Default: false
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access token.
        :param pulumi.Input[int] time_window: The number of days per request. Must be a number between 1 and 31. Default: 7
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "start_date", start_date)
        if dispute_start_date is not None:
            pulumi.set(__self__, "dispute_start_date", dispute_start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if is_sandbox is not None:
            pulumi.set(__self__, "is_sandbox", is_sandbox)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Paypal developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Paypal developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. Date must be in range from 3 years till 12 hrs before present time.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="disputeStartDate")
    def dispute_start_date(self) -> Optional[pulumi.Input[str]]:
        """
        Start Date parameter for the list dispute endpoint in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This Start Date must be in range within 180 days before present time, and requires ONLY 3 miliseconds(mandatory). If you don't use this option, it defaults to a start date set 180 days in the past.
        """
        return pulumi.get(self, "dispute_start_date")

    @dispute_start_date.setter
    def dispute_start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dispute_start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        End Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This can be help you select specific range of time, mainly for test purposes  or data integrity tests. When this is not used, now_utc() is used by the streams. This does not apply to Disputes and Product streams.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="isSandbox")
    def is_sandbox(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to use the sandbox or production environment. Default: false
        """
        return pulumi.get(self, "is_sandbox")

    @is_sandbox.setter
    def is_sandbox(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_sandbox", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[str]]:
        """
        The key to refresh the expired access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[pulumi.Input[int]]:
        """
        The number of days per request. Must be a number between 1 and 31. Default: 7
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_window", value)


@pulumi.input_type
class SourcePaystackConfigurationArgs:
    def __init__(__self__, *,
                 secret_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 lookback_window_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] secret_key: The Paystack API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.paystack.com/#/settings/developer">here</a>).
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[int] lookback_window_days: When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation. Default: 0
        """
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)
        if lookback_window_days is not None:
            pulumi.set(__self__, "lookback_window_days", lookback_window_days)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        The Paystack API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.paystack.com/#/settings/developer">here</a>).
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="lookbackWindowDays")
    def lookback_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation. Default: 0
        """
        return pulumi.get(self, "lookback_window_days")

    @lookback_window_days.setter
    def lookback_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window_days", value)


@pulumi.input_type
class SourcePendoConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourcePersistiqConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: PersistIq API Key. See the <a href="https://apidocs.persistiq.com/#authentication">docs</a> for more information on where to find that key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        PersistIq API Key. See the <a href="https://apidocs.persistiq.com/#authentication">docs</a> for more information on where to find that key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourcePexelsApiConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 query: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None,
                 locale: Optional[pulumi.Input[str]] = None,
                 orientation: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
        :param pulumi.Input[str] query: Optional, the search query, Example Ocean, Tigers, Pears, etc.
        :param pulumi.Input[str] color: Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
        :param pulumi.Input[str] locale: Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
        :param pulumi.Input[str] orientation: Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
        :param pulumi.Input[str] size: Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query", query)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Optional, the search query, Example Ocean, Tigers, Pears, etc.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter
    def orientation(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
        """
        return pulumi.get(self, "orientation")

    @orientation.setter
    def orientation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orientation", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


@pulumi.input_type
class SourcePinterestConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourcePinterestConfigurationCredentialsArgs']] = None,
                 custom_reports: Optional[pulumi.Input[Sequence[pulumi.Input['SourcePinterestConfigurationCustomReportArgs']]]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SourcePinterestConfigurationCustomReportArgs']]] custom_reports: A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        :param pulumi.Input[str] start_date: A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] statuses: For the ads, ad_groups, and campaigns streams, specifying a status will filter out records that do not match the specified ones. If a status is not specified, the source will default to records with a status of either ACTIVE or PAUSED.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourcePinterestConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourcePinterestConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourcePinterestConfigurationCustomReportArgs']]]]:
        """
        A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        """
        return pulumi.get(self, "custom_reports")

    @custom_reports.setter
    def custom_reports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourcePinterestConfigurationCustomReportArgs']]]]):
        pulumi.set(self, "custom_reports", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        For the ads, ad_groups, and campaigns streams, specifying a status will filter out records that do not match the specified ones. If a status is not specified, the source will default to records with a status of either ACTIVE or PAUSED.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "statuses", value)


@pulumi.input_type
class SourcePinterestConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Client ID of your OAuth application
        :param pulumi.Input[str] client_secret: The Client Secret of your OAuth application.
        :param pulumi.Input[str] refresh_token: Refresh Token to obtain new Access Token, when it's expired.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your OAuth application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token to obtain new Access Token, when it's expired.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourcePinterestConfigurationCustomReportArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input[str]]],
                 name: pulumi.Input[str],
                 attribution_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 click_window_days: Optional[pulumi.Input[int]] = None,
                 conversion_report_time: Optional[pulumi.Input[str]] = None,
                 engagement_window_days: Optional[pulumi.Input[int]] = None,
                 granularity: Optional[pulumi.Input[str]] = None,
                 level: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 view_window_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: A list of chosen columns
        :param pulumi.Input[str] name: The name value of report
        :param pulumi.Input[Sequence[pulumi.Input[str]]] attribution_types: List of types of attribution for the conversion report
        :param pulumi.Input[int] click_window_days: Number of days to use as the conversion attribution window for a pin click action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: 30
        :param pulumi.Input[str] conversion_report_time: The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.. must be one of ["TIME_OF_AD_ACTION", "TIME_OF_CONVERSION"]; Default: "TIME_OF_AD_ACTION"
        :param pulumi.Input[int] engagement_window_days: Number of days to use as the conversion attribution window for an engagement action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        :param pulumi.Input[str] granularity: Chosen granularity for API. must be one of ["TOTAL", "DAY", "HOUR", "WEEK", "MONTH"]; Default: "TOTAL"
        :param pulumi.Input[str] level: Chosen level for API. must be one of ["ADVERTISER", "ADVERTISER_TARGETING", "CAMPAIGN", "CAMPAIGN_TARGETING", "AD_GROUP", "AD_GROUP_TARGETING", "PIN_PROMOTION", "PIN_PROMOTION_TARGETING", "KEYWORD", "PRODUCT_GROUP", "PRODUCT_GROUP_TARGETING", "PRODUCT_ITEM"]; Default: "ADVERTISER"
        :param pulumi.Input[str] start_date: A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by report api (913 days from today).
        :param pulumi.Input[int] view_window_days: Number of days to use as the conversion attribution window for a view action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "name", name)
        if attribution_types is not None:
            pulumi.set(__self__, "attribution_types", attribution_types)
        if click_window_days is not None:
            pulumi.set(__self__, "click_window_days", click_window_days)
        if conversion_report_time is not None:
            pulumi.set(__self__, "conversion_report_time", conversion_report_time)
        if engagement_window_days is not None:
            pulumi.set(__self__, "engagement_window_days", engagement_window_days)
        if granularity is not None:
            pulumi.set(__self__, "granularity", granularity)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if view_window_days is not None:
            pulumi.set(__self__, "view_window_days", view_window_days)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of chosen columns
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name value of report
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="attributionTypes")
    def attribution_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of types of attribution for the conversion report
        """
        return pulumi.get(self, "attribution_types")

    @attribution_types.setter
    def attribution_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "attribution_types", value)

    @property
    @pulumi.getter(name="clickWindowDays")
    def click_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days to use as the conversion attribution window for a pin click action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: 30
        """
        return pulumi.get(self, "click_window_days")

    @click_window_days.setter
    def click_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "click_window_days", value)

    @property
    @pulumi.getter(name="conversionReportTime")
    def conversion_report_time(self) -> Optional[pulumi.Input[str]]:
        """
        The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.. must be one of ["TIME_OF_AD_ACTION", "TIME_OF_CONVERSION"]; Default: "TIME_OF_AD_ACTION"
        """
        return pulumi.get(self, "conversion_report_time")

    @conversion_report_time.setter
    def conversion_report_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "conversion_report_time", value)

    @property
    @pulumi.getter(name="engagementWindowDays")
    def engagement_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days to use as the conversion attribution window for an engagement action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        """
        return pulumi.get(self, "engagement_window_days")

    @engagement_window_days.setter
    def engagement_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "engagement_window_days", value)

    @property
    @pulumi.getter
    def granularity(self) -> Optional[pulumi.Input[str]]:
        """
        Chosen granularity for API. must be one of ["TOTAL", "DAY", "HOUR", "WEEK", "MONTH"]; Default: "TOTAL"
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "granularity", value)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        Chosen level for API. must be one of ["ADVERTISER", "ADVERTISER_TARGETING", "CAMPAIGN", "CAMPAIGN_TARGETING", "AD_GROUP", "AD_GROUP_TARGETING", "PIN_PROMOTION", "PIN_PROMOTION_TARGETING", "KEYWORD", "PRODUCT_GROUP", "PRODUCT_GROUP_TARGETING", "PRODUCT_ITEM"]; Default: "ADVERTISER"
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by report api (913 days from today).
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="viewWindowDays")
    def view_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days to use as the conversion attribution window for a view action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        """
        return pulumi.get(self, "view_window_days")

    @view_window_days.setter
    def view_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "view_window_days", value)


@pulumi.input_type
class SourcePipedriveConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 replication_start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: The Pipedrive API Token.
        :param pulumi.Input[str] replication_start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "replication_start_date", replication_start_date)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The Pipedrive API Token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="replicationStartDate")
    def replication_start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
        """
        return pulumi.get(self, "replication_start_date")

    @replication_start_date.setter
    def replication_start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "replication_start_date", value)


@pulumi.input_type
class SourcePocketConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 consumer_key: pulumi.Input[str],
                 content_type: Optional[pulumi.Input[str]] = None,
                 detail_type: Optional[pulumi.Input[str]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 favorite: Optional[pulumi.Input[bool]] = None,
                 search: Optional[pulumi.Input[str]] = None,
                 since: Optional[pulumi.Input[str]] = None,
                 sort: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The user's Pocket access token.
        :param pulumi.Input[str] consumer_key: Your application's Consumer Key.
        :param pulumi.Input[str] content_type: Select the content type of the items to retrieve. must be one of ["article", "video", "image"]
        :param pulumi.Input[str] detail_type: Select the granularity of the information about each item. must be one of ["simple", "complete"]
        :param pulumi.Input[str] domain: Only return items from a particular `domain`.
        :param pulumi.Input[bool] favorite: Retrieve only favorited items. Default: false
        :param pulumi.Input[str] search: Only return items whose title or url contain the `search` string.
        :param pulumi.Input[str] since: Only return items modified since the given timestamp.
        :param pulumi.Input[str] sort: Sort retrieved items by the given criteria. must be one of ["newest", "oldest", "title", "site"]
        :param pulumi.Input[str] state: Select the state of the items to retrieve. must be one of ["unread", "archive", "all"]
        :param pulumi.Input[str] tag: Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "consumer_key", consumer_key)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if detail_type is not None:
            pulumi.set(__self__, "detail_type", detail_type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if favorite is not None:
            pulumi.set(__self__, "favorite", favorite)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if since is not None:
            pulumi.set(__self__, "since", since)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The user's Pocket access token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> pulumi.Input[str]:
        """
        Your application's Consumer Key.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "consumer_key", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        Select the content type of the items to retrieve. must be one of ["article", "video", "image"]
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="detailType")
    def detail_type(self) -> Optional[pulumi.Input[str]]:
        """
        Select the granularity of the information about each item. must be one of ["simple", "complete"]
        """
        return pulumi.get(self, "detail_type")

    @detail_type.setter
    def detail_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail_type", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        Only return items from a particular `domain`.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def favorite(self) -> Optional[pulumi.Input[bool]]:
        """
        Retrieve only favorited items. Default: false
        """
        return pulumi.get(self, "favorite")

    @favorite.setter
    def favorite(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "favorite", value)

    @property
    @pulumi.getter
    def search(self) -> Optional[pulumi.Input[str]]:
        """
        Only return items whose title or url contain the `search` string.
        """
        return pulumi.get(self, "search")

    @search.setter
    def search(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search", value)

    @property
    @pulumi.getter
    def since(self) -> Optional[pulumi.Input[str]]:
        """
        Only return items modified since the given timestamp.
        """
        return pulumi.get(self, "since")

    @since.setter
    def since(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "since", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        Sort retrieved items by the given criteria. must be one of ["newest", "oldest", "title", "site"]
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Select the state of the items to retrieve. must be one of ["unread", "archive", "all"]
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class SourcePokeapiConfigurationArgs:
    def __init__(__self__, *,
                 pokemon_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] pokemon_name: Pokemon requested from the API. must be one of ["bulbasaur", "ivysaur", "venusaur", "charmander", "charmeleon", "charizard", "squirtle", "wartortle", "blastoise", "caterpie", "metapod", "butterfree", "weedle", "kakuna", "beedrill", "pidgey", "pidgeotto", "pidgeot", "rattata", "raticate", "spearow", "fearow", "ekans", "arbok", "pikachu", "raichu", "sandshrew", "sandslash", "nidoranf", "nidorina", "nidoqueen", "nidoranm", "nidorino", "nidoking", "clefairy", "clefable", "vulpix", "ninetales", "jigglypuff", "wigglytuff", "zubat", "golbat", "oddish", "gloom", "vileplume", "paras", "parasect", "venonat", "venomoth", "diglett", "dugtrio", "meowth", "persian", "psyduck", "golduck", "mankey", "primeape", "growlithe", "arcanine", "poliwag", "poliwhirl", "poliwrath", "abra", "kadabra", "alakazam", "machop", "machoke", "machamp", "bellsprout", "weepinbell", "victreebel", "tentacool", "tentacruel", "geodude", "graveler", "golem", "ponyta", "rapidash", "slowpoke", "slowbro", "magnemite", "magneton", "farfetchd", "doduo", "dodrio", "seel", "dewgong", "grimer", "muk", "shellder", "cloyster", "gastly", "haunter", "gengar", "onix", "drowzee", "hypno", "krabby", "kingler", "voltorb", "electrode", "exeggcute", "exeggutor", "cubone", "marowak", "hitmonlee", "hitmonchan", "lickitung", "koffing", "weezing", "rhyhorn", "rhydon", "chansey", "tangela", "kangaskhan", "horsea", "seadra", "goldeen", "seaking", "staryu", "starmie", "mrmime", "scyther", "jynx", "electabuzz", "magmar", "pinsir", "tauros", "magikarp", "gyarados", "lapras", "ditto", "eevee", "vaporeon", "jolteon", "flareon", "porygon", "omanyte", "omastar", "kabuto", "kabutops", "aerodactyl", "snorlax", "articuno", "zapdos", "moltres", "dratini", "dragonair", "dragonite", "mewtwo", "mew", "chikorita", "bayleef", "meganium", "cyndaquil", "quilava", "typhlosion", "totodile", "croconaw", "feraligatr", "sentret", "furret", "hoothoot", "noctowl", "ledyba", "ledian", "spinarak", "ariados", "crobat", "chinchou", "lanturn", "pichu", "cleffa", "igglybuff", "togepi", "togetic", "natu", "xatu", "mareep", "flaaffy", "ampharos", "bellossom", "marill", "azumarill", "sudowoodo", "politoed", "hoppip", "skiploom", "jumpluff", "aipom", "sunkern", "sunflora", "yanma", "wooper", "quagsire", "espeon", "umbreon", "murkrow", "slowking", "misdreavus", "unown", "wobbuffet", "girafarig", "pineco", "forretress", "dunsparce", "gligar", "steelix", "snubbull", "granbull", "qwilfish", "scizor", "shuckle", "heracross", "sneasel", "teddiursa", "ursaring", "slugma", "magcargo", "swinub", "piloswine", "corsola", "remoraid", "octillery", "delibird", "mantine", "skarmory", "houndour", "houndoom", "kingdra", "phanpy", "donphan", "porygon2", "stantler", "smeargle", "tyrogue", "hitmontop", "smoochum", "elekid", "magby", "miltank", "blissey", "raikou", "entei", "suicune", "larvitar", "pupitar", "tyranitar", "lugia", "ho-oh", "celebi", "treecko", "grovyle", "sceptile", "torchic", "combusken", "blaziken", "mudkip", "marshtomp", "swampert", "poochyena", "mightyena", "zigzagoon", "linoone", "wurmple", "silcoon", "beautifly", "cascoon", "dustox", "lotad", "lombre", "ludicolo", "seedot", "nuzleaf", "shiftry", "taillow", "swellow", "wingull", "pelipper", "ralts", "kirlia", "gardevoir", "surskit", "masquerain", "shroomish", "breloom", "slakoth", "vigoroth", "slaking", "nincada", "ninjask", "shedinja", "whismur", "loudred", "exploud", "makuhita", "hariyama", "azurill", "nosepass", "skitty", "delcatty", "sableye", "mawile", "aron", "lairon", "aggron", "meditite", "medicham", "electrike", "manectric", "plusle", "minun", "volbeat", "illumise", "roselia", "gulpin", "swalot", "carvanha", "sharpedo", "wailmer", "wailord", "numel", "camerupt", "torkoal", "spoink", "grumpig", "spinda", "trapinch", "vibrava", "flygon", "cacnea", "cacturne", "swablu", "altaria", "zangoose", "seviper", "lunatone", "solrock", "barboach", "whiscash", "corphish", "crawdaunt", "baltoy", "claydol", "lileep", "cradily", "anorith", "armaldo", "feebas", "milotic", "castform", "kecleon", "shuppet", "banette", "duskull", "dusclops", "tropius", "chimecho", "absol", "wynaut", "snorunt", "glalie", "spheal", "sealeo", "walrein", "clamperl", "huntail", "gorebyss", "relicanth", "luvdisc", "bagon", "shelgon", "salamence", "beldum", "metang", "metagross", "regirock", "regice", "registeel", "latias", "latios", "kyogre", "groudon", "rayquaza", "jirachi", "deoxys", "turtwig", "grotle", "torterra", "chimchar", "monferno", "infernape", "piplup", "prinplup", "empoleon", "starly", "staravia", "staraptor", "bidoof", "bibarel", "kricketot", "kricketune", "shinx", "luxio", "luxray", "budew", "roserade", "cranidos", "rampardos", "shieldon", "bastiodon", "burmy", "wormadam", "mothim", "combee", "vespiquen", "pachirisu", "buizel", "floatzel", "cherubi", "cherrim", "shellos", "gastrodon", "ambipom", "drifloon", "drifblim", "buneary", "lopunny", "mismagius", "honchkrow", "glameow", "purugly", "chingling", "stunky", "skuntank", "bronzor", "bronzong", "bonsly", "mimejr", "happiny", "chatot", "spiritomb", "gible", "gabite", "garchomp", "munchlax", "riolu", "lucario", "hippopotas", "hippowdon", "skorupi", "drapion", "croagunk", "toxicroak", "carnivine", "finneon", "lumineon", "mantyke", "snover", "abomasnow", "weavile", "magnezone", "lickilicky", "rhyperior", "tangrowth", "electivire", "magmortar", "togekiss", "yanmega", "leafeon", "glaceon", "gliscor", "mamoswine", "porygon-z", "gallade", "probopass", "dusknoir", "froslass", "rotom", "uxie", "mesprit", "azelf", "dialga", "palkia", "heatran", "regigigas", "giratina", "cresselia", "phione", "manaphy", "darkrai", "shaymin", "arceus", "victini", "snivy", "servine", "serperior", "tepig", "pignite", "emboar", "oshawott", "dewott", "samurott", "patrat", "watchog", "lillipup", "herdier", "stoutland", "purrloin", "liepard", "pansage", "simisage", "pansear", "simisear", "panpour", "simipour", "munna", "musharna", "pidove", "tranquill", "unfezant", "blitzle", "zebstrika", "roggenrola", "boldore", "gigalith", "woobat", "swoobat", "drilbur", "excadrill", "audino", "timburr", "gurdurr", "conkeldurr", "tympole", "palpitoad", "seismitoad", "throh", "sawk", "sewaddle", "swadloon", "leavanny", "venipede", "whirlipede", "scolipede", "cottonee", "whimsicott", "petilil", "lilligant", "basculin", "sandile", "krokorok", "krookodile", "darumaka", "darmanitan", "maractus", "dwebble", "crustle", "scraggy", "scrafty", "sigilyph", "yamask", "cofagrigus", "tirtouga", "carracosta", "archen", "archeops", "trubbish", "garbodor", "zorua", "zoroark", "minccino", "cinccino", "gothita", "gothorita", "gothitelle", "solosis", "duosion", "reuniclus", "ducklett", "swanna", "vanillite", "vanillish", "vanilluxe", "deerling", "sawsbuck", "emolga", "karrablast", "escavalier", "foongus", "amoonguss", "frillish", "jellicent", "alomomola", "joltik", "galvantula", "ferroseed", "ferrothorn", "klink", "klang", "klinklang", "tynamo", "eelektrik", "eelektross", "elgyem", "beheeyem", "litwick", "lampent", "chandelure", "axew", "fraxure", "haxorus", "cubchoo", "beartic", "cryogonal", "shelmet", "accelgor", "stunfisk", "mienfoo", "mienshao", "druddigon", "golett", "golurk", "pawniard", "bisharp", "bouffalant", "rufflet", "braviary", "vullaby", "mandibuzz", "heatmor", "durant", "deino", "zweilous", "hydreigon", "larvesta", "volcarona", "cobalion", "terrakion", "virizion", "tornadus", "thundurus", "reshiram", "zekrom", "landorus", "kyurem", "keldeo", "meloetta", "genesect", "chespin", "quilladin", "chesnaught", "fennekin", "braixen", "delphox", "froakie", "frogadier", "greninja", "bunnelby", "diggersby", "fletchling", "fletchinder", "talonflame", "scatterbug", "spewpa", "vivillon", "litleo", "pyroar", "flabebe", "floette", "florges", "skiddo", "gogoat", "pancham", "pangoro", "furfrou", "espurr", "meowstic", "honedge", "doublade", "aegislash", "spritzee", "aromatisse", "swirlix", "slurpuff", "inkay", "malamar", "binacle", "barbaracle", "skrelp", "dragalge", "clauncher", "clawitzer", "helioptile", "heliolisk", "tyrunt", "tyrantrum", "amaura", "aurorus", "sylveon", "hawlucha", "dedenne", "carbink", "goomy", "sliggoo", "goodra", "klefki", "phantump", "trevenant", "pumpkaboo", "gourgeist", "bergmite", "avalugg", "noibat", "noivern", "xerneas", "yveltal", "zygarde", "diancie", "hoopa", "volcanion", "rowlet", "dartrix", "decidueye", "litten", "torracat", "incineroar", "popplio", "brionne", "primarina", "pikipek", "trumbeak", "toucannon", "yungoos", "gumshoos", "grubbin", "charjabug", "vikavolt", "crabrawler", "crabominable", "oricorio", "cutiefly", "ribombee", "rockruff", "lycanroc", "wishiwashi", "mareanie", "toxapex", "mudbray", "mudsdale", "dewpider", "araquanid", "fomantis", "lurantis", "morelull", "shiinotic", "salandit", "salazzle", "stufful", "bewear", "bounsweet", "steenee", "tsareena", "comfey", "oranguru", "passimian", "wimpod", "golisopod", "sandygast", "palossand", "pyukumuku", "typenull", "silvally", "minior", "komala", "turtonator", "togedemaru", "mimikyu", "bruxish", "drampa", "dhelmise", "jangmo-o", "hakamo-o", "kommo-o", "tapukoko", "tapulele", "tapubulu", "tapufini", "cosmog", "cosmoem", "solgaleo", "lunala", "nihilego", "buzzwole", "pheromosa", "xurkitree", "celesteela", "kartana", "guzzlord", "necrozma", "magearna", "marshadow", "poipole", "naganadel", "stakataka", "blacephalon", "zeraora", "meltan", "melmetal", "grookey", "thwackey", "rillaboom", "scorbunny", "raboot", "cinderace", "sobble", "drizzile", "inteleon", "skwovet", "greedent", "rookidee", "corvisquire", "corviknight", "blipbug", "dottler", "orbeetle", "nickit", "thievul", "gossifleur", "eldegoss", "wooloo", "dubwool", "chewtle", "drednaw", "yamper", "boltund", "rolycoly", "carkol", "coalossal", "applin", "flapple", "appletun", "silicobra", "sandaconda", "cramorant", "arrokuda", "barraskewda", "toxel", "toxtricity", "sizzlipede", "centiskorch", "clobbopus", "grapploct", "sinistea", "polteageist", "hatenna", "hattrem", "hatterene", "impidimp", "morgrem", "grimmsnarl", "obstagoon", "perrserker", "cursola", "sirfetchd", "mrrime", "runerigus", "milcery", "alcremie", "falinks", "pincurchin", "snom", "frosmoth", "stonjourner", "eiscue", "indeedee", "morpeko", "cufant", "copperajah", "dracozolt", "arctozolt", "dracovish", "arctovish", "duraludon", "dreepy", "drakloak", "dragapult", "zacian", "zamazenta", "eternatus", "kubfu", "urshifu", "zarude", "regieleki", "regidrago", "glastrier", "spectrier", "calyrex"]
        """
        pulumi.set(__self__, "pokemon_name", pokemon_name)

    @property
    @pulumi.getter(name="pokemonName")
    def pokemon_name(self) -> pulumi.Input[str]:
        """
        Pokemon requested from the API. must be one of ["bulbasaur", "ivysaur", "venusaur", "charmander", "charmeleon", "charizard", "squirtle", "wartortle", "blastoise", "caterpie", "metapod", "butterfree", "weedle", "kakuna", "beedrill", "pidgey", "pidgeotto", "pidgeot", "rattata", "raticate", "spearow", "fearow", "ekans", "arbok", "pikachu", "raichu", "sandshrew", "sandslash", "nidoranf", "nidorina", "nidoqueen", "nidoranm", "nidorino", "nidoking", "clefairy", "clefable", "vulpix", "ninetales", "jigglypuff", "wigglytuff", "zubat", "golbat", "oddish", "gloom", "vileplume", "paras", "parasect", "venonat", "venomoth", "diglett", "dugtrio", "meowth", "persian", "psyduck", "golduck", "mankey", "primeape", "growlithe", "arcanine", "poliwag", "poliwhirl", "poliwrath", "abra", "kadabra", "alakazam", "machop", "machoke", "machamp", "bellsprout", "weepinbell", "victreebel", "tentacool", "tentacruel", "geodude", "graveler", "golem", "ponyta", "rapidash", "slowpoke", "slowbro", "magnemite", "magneton", "farfetchd", "doduo", "dodrio", "seel", "dewgong", "grimer", "muk", "shellder", "cloyster", "gastly", "haunter", "gengar", "onix", "drowzee", "hypno", "krabby", "kingler", "voltorb", "electrode", "exeggcute", "exeggutor", "cubone", "marowak", "hitmonlee", "hitmonchan", "lickitung", "koffing", "weezing", "rhyhorn", "rhydon", "chansey", "tangela", "kangaskhan", "horsea", "seadra", "goldeen", "seaking", "staryu", "starmie", "mrmime", "scyther", "jynx", "electabuzz", "magmar", "pinsir", "tauros", "magikarp", "gyarados", "lapras", "ditto", "eevee", "vaporeon", "jolteon", "flareon", "porygon", "omanyte", "omastar", "kabuto", "kabutops", "aerodactyl", "snorlax", "articuno", "zapdos", "moltres", "dratini", "dragonair", "dragonite", "mewtwo", "mew", "chikorita", "bayleef", "meganium", "cyndaquil", "quilava", "typhlosion", "totodile", "croconaw", "feraligatr", "sentret", "furret", "hoothoot", "noctowl", "ledyba", "ledian", "spinarak", "ariados", "crobat", "chinchou", "lanturn", "pichu", "cleffa", "igglybuff", "togepi", "togetic", "natu", "xatu", "mareep", "flaaffy", "ampharos", "bellossom", "marill", "azumarill", "sudowoodo", "politoed", "hoppip", "skiploom", "jumpluff", "aipom", "sunkern", "sunflora", "yanma", "wooper", "quagsire", "espeon", "umbreon", "murkrow", "slowking", "misdreavus", "unown", "wobbuffet", "girafarig", "pineco", "forretress", "dunsparce", "gligar", "steelix", "snubbull", "granbull", "qwilfish", "scizor", "shuckle", "heracross", "sneasel", "teddiursa", "ursaring", "slugma", "magcargo", "swinub", "piloswine", "corsola", "remoraid", "octillery", "delibird", "mantine", "skarmory", "houndour", "houndoom", "kingdra", "phanpy", "donphan", "porygon2", "stantler", "smeargle", "tyrogue", "hitmontop", "smoochum", "elekid", "magby", "miltank", "blissey", "raikou", "entei", "suicune", "larvitar", "pupitar", "tyranitar", "lugia", "ho-oh", "celebi", "treecko", "grovyle", "sceptile", "torchic", "combusken", "blaziken", "mudkip", "marshtomp", "swampert", "poochyena", "mightyena", "zigzagoon", "linoone", "wurmple", "silcoon", "beautifly", "cascoon", "dustox", "lotad", "lombre", "ludicolo", "seedot", "nuzleaf", "shiftry", "taillow", "swellow", "wingull", "pelipper", "ralts", "kirlia", "gardevoir", "surskit", "masquerain", "shroomish", "breloom", "slakoth", "vigoroth", "slaking", "nincada", "ninjask", "shedinja", "whismur", "loudred", "exploud", "makuhita", "hariyama", "azurill", "nosepass", "skitty", "delcatty", "sableye", "mawile", "aron", "lairon", "aggron", "meditite", "medicham", "electrike", "manectric", "plusle", "minun", "volbeat", "illumise", "roselia", "gulpin", "swalot", "carvanha", "sharpedo", "wailmer", "wailord", "numel", "camerupt", "torkoal", "spoink", "grumpig", "spinda", "trapinch", "vibrava", "flygon", "cacnea", "cacturne", "swablu", "altaria", "zangoose", "seviper", "lunatone", "solrock", "barboach", "whiscash", "corphish", "crawdaunt", "baltoy", "claydol", "lileep", "cradily", "anorith", "armaldo", "feebas", "milotic", "castform", "kecleon", "shuppet", "banette", "duskull", "dusclops", "tropius", "chimecho", "absol", "wynaut", "snorunt", "glalie", "spheal", "sealeo", "walrein", "clamperl", "huntail", "gorebyss", "relicanth", "luvdisc", "bagon", "shelgon", "salamence", "beldum", "metang", "metagross", "regirock", "regice", "registeel", "latias", "latios", "kyogre", "groudon", "rayquaza", "jirachi", "deoxys", "turtwig", "grotle", "torterra", "chimchar", "monferno", "infernape", "piplup", "prinplup", "empoleon", "starly", "staravia", "staraptor", "bidoof", "bibarel", "kricketot", "kricketune", "shinx", "luxio", "luxray", "budew", "roserade", "cranidos", "rampardos", "shieldon", "bastiodon", "burmy", "wormadam", "mothim", "combee", "vespiquen", "pachirisu", "buizel", "floatzel", "cherubi", "cherrim", "shellos", "gastrodon", "ambipom", "drifloon", "drifblim", "buneary", "lopunny", "mismagius", "honchkrow", "glameow", "purugly", "chingling", "stunky", "skuntank", "bronzor", "bronzong", "bonsly", "mimejr", "happiny", "chatot", "spiritomb", "gible", "gabite", "garchomp", "munchlax", "riolu", "lucario", "hippopotas", "hippowdon", "skorupi", "drapion", "croagunk", "toxicroak", "carnivine", "finneon", "lumineon", "mantyke", "snover", "abomasnow", "weavile", "magnezone", "lickilicky", "rhyperior", "tangrowth", "electivire", "magmortar", "togekiss", "yanmega", "leafeon", "glaceon", "gliscor", "mamoswine", "porygon-z", "gallade", "probopass", "dusknoir", "froslass", "rotom", "uxie", "mesprit", "azelf", "dialga", "palkia", "heatran", "regigigas", "giratina", "cresselia", "phione", "manaphy", "darkrai", "shaymin", "arceus", "victini", "snivy", "servine", "serperior", "tepig", "pignite", "emboar", "oshawott", "dewott", "samurott", "patrat", "watchog", "lillipup", "herdier", "stoutland", "purrloin", "liepard", "pansage", "simisage", "pansear", "simisear", "panpour", "simipour", "munna", "musharna", "pidove", "tranquill", "unfezant", "blitzle", "zebstrika", "roggenrola", "boldore", "gigalith", "woobat", "swoobat", "drilbur", "excadrill", "audino", "timburr", "gurdurr", "conkeldurr", "tympole", "palpitoad", "seismitoad", "throh", "sawk", "sewaddle", "swadloon", "leavanny", "venipede", "whirlipede", "scolipede", "cottonee", "whimsicott", "petilil", "lilligant", "basculin", "sandile", "krokorok", "krookodile", "darumaka", "darmanitan", "maractus", "dwebble", "crustle", "scraggy", "scrafty", "sigilyph", "yamask", "cofagrigus", "tirtouga", "carracosta", "archen", "archeops", "trubbish", "garbodor", "zorua", "zoroark", "minccino", "cinccino", "gothita", "gothorita", "gothitelle", "solosis", "duosion", "reuniclus", "ducklett", "swanna", "vanillite", "vanillish", "vanilluxe", "deerling", "sawsbuck", "emolga", "karrablast", "escavalier", "foongus", "amoonguss", "frillish", "jellicent", "alomomola", "joltik", "galvantula", "ferroseed", "ferrothorn", "klink", "klang", "klinklang", "tynamo", "eelektrik", "eelektross", "elgyem", "beheeyem", "litwick", "lampent", "chandelure", "axew", "fraxure", "haxorus", "cubchoo", "beartic", "cryogonal", "shelmet", "accelgor", "stunfisk", "mienfoo", "mienshao", "druddigon", "golett", "golurk", "pawniard", "bisharp", "bouffalant", "rufflet", "braviary", "vullaby", "mandibuzz", "heatmor", "durant", "deino", "zweilous", "hydreigon", "larvesta", "volcarona", "cobalion", "terrakion", "virizion", "tornadus", "thundurus", "reshiram", "zekrom", "landorus", "kyurem", "keldeo", "meloetta", "genesect", "chespin", "quilladin", "chesnaught", "fennekin", "braixen", "delphox", "froakie", "frogadier", "greninja", "bunnelby", "diggersby", "fletchling", "fletchinder", "talonflame", "scatterbug", "spewpa", "vivillon", "litleo", "pyroar", "flabebe", "floette", "florges", "skiddo", "gogoat", "pancham", "pangoro", "furfrou", "espurr", "meowstic", "honedge", "doublade", "aegislash", "spritzee", "aromatisse", "swirlix", "slurpuff", "inkay", "malamar", "binacle", "barbaracle", "skrelp", "dragalge", "clauncher", "clawitzer", "helioptile", "heliolisk", "tyrunt", "tyrantrum", "amaura", "aurorus", "sylveon", "hawlucha", "dedenne", "carbink", "goomy", "sliggoo", "goodra", "klefki", "phantump", "trevenant", "pumpkaboo", "gourgeist", "bergmite", "avalugg", "noibat", "noivern", "xerneas", "yveltal", "zygarde", "diancie", "hoopa", "volcanion", "rowlet", "dartrix", "decidueye", "litten", "torracat", "incineroar", "popplio", "brionne", "primarina", "pikipek", "trumbeak", "toucannon", "yungoos", "gumshoos", "grubbin", "charjabug", "vikavolt", "crabrawler", "crabominable", "oricorio", "cutiefly", "ribombee", "rockruff", "lycanroc", "wishiwashi", "mareanie", "toxapex", "mudbray", "mudsdale", "dewpider", "araquanid", "fomantis", "lurantis", "morelull", "shiinotic", "salandit", "salazzle", "stufful", "bewear", "bounsweet", "steenee", "tsareena", "comfey", "oranguru", "passimian", "wimpod", "golisopod", "sandygast", "palossand", "pyukumuku", "typenull", "silvally", "minior", "komala", "turtonator", "togedemaru", "mimikyu", "bruxish", "drampa", "dhelmise", "jangmo-o", "hakamo-o", "kommo-o", "tapukoko", "tapulele", "tapubulu", "tapufini", "cosmog", "cosmoem", "solgaleo", "lunala", "nihilego", "buzzwole", "pheromosa", "xurkitree", "celesteela", "kartana", "guzzlord", "necrozma", "magearna", "marshadow", "poipole", "naganadel", "stakataka", "blacephalon", "zeraora", "meltan", "melmetal", "grookey", "thwackey", "rillaboom", "scorbunny", "raboot", "cinderace", "sobble", "drizzile", "inteleon", "skwovet", "greedent", "rookidee", "corvisquire", "corviknight", "blipbug", "dottler", "orbeetle", "nickit", "thievul", "gossifleur", "eldegoss", "wooloo", "dubwool", "chewtle", "drednaw", "yamper", "boltund", "rolycoly", "carkol", "coalossal", "applin", "flapple", "appletun", "silicobra", "sandaconda", "cramorant", "arrokuda", "barraskewda", "toxel", "toxtricity", "sizzlipede", "centiskorch", "clobbopus", "grapploct", "sinistea", "polteageist", "hatenna", "hattrem", "hatterene", "impidimp", "morgrem", "grimmsnarl", "obstagoon", "perrserker", "cursola", "sirfetchd", "mrrime", "runerigus", "milcery", "alcremie", "falinks", "pincurchin", "snom", "frosmoth", "stonjourner", "eiscue", "indeedee", "morpeko", "cufant", "copperajah", "dracozolt", "arctozolt", "dracovish", "arctovish", "duraludon", "dreepy", "drakloak", "dragapult", "zacian", "zamazenta", "eternatus", "kubfu", "urshifu", "zarude", "regieleki", "regidrago", "glastrier", "spectrier", "calyrex"]
        """
        return pulumi.get(self, "pokemon_name")

    @pokemon_name.setter
    def pokemon_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "pokemon_name", value)


@pulumi.input_type
class SourcePolygonStockApiConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 end_date: pulumi.Input[str],
                 multiplier: pulumi.Input[int],
                 start_date: pulumi.Input[str],
                 stocks_ticker: pulumi.Input[str],
                 timespan: pulumi.Input[str],
                 adjusted: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[int]] = None,
                 sort: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Your API ACCESS Key
        :param pulumi.Input[str] end_date: The target date for the aggregate window.
        :param pulumi.Input[int] multiplier: The size of the timespan multiplier.
        :param pulumi.Input[str] start_date: The beginning date for the aggregate window.
        :param pulumi.Input[str] stocks_ticker: The exchange symbol that this item is traded under.
        :param pulumi.Input[str] timespan: The size of the time window.
        :param pulumi.Input[str] adjusted: Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
        :param pulumi.Input[int] limit: The target date for the aggregate window.
        :param pulumi.Input[str] sort: Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "multiplier", multiplier)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "stocks_ticker", stocks_ticker)
        pulumi.set(__self__, "timespan", timespan)
        if adjusted is not None:
            pulumi.set(__self__, "adjusted", adjusted)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API ACCESS Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> pulumi.Input[str]:
        """
        The target date for the aggregate window.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def multiplier(self) -> pulumi.Input[int]:
        """
        The size of the timespan multiplier.
        """
        return pulumi.get(self, "multiplier")

    @multiplier.setter
    def multiplier(self, value: pulumi.Input[int]):
        pulumi.set(self, "multiplier", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The beginning date for the aggregate window.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="stocksTicker")
    def stocks_ticker(self) -> pulumi.Input[str]:
        """
        The exchange symbol that this item is traded under.
        """
        return pulumi.get(self, "stocks_ticker")

    @stocks_ticker.setter
    def stocks_ticker(self, value: pulumi.Input[str]):
        pulumi.set(self, "stocks_ticker", value)

    @property
    @pulumi.getter
    def timespan(self) -> pulumi.Input[str]:
        """
        The size of the time window.
        """
        return pulumi.get(self, "timespan")

    @timespan.setter
    def timespan(self, value: pulumi.Input[str]):
        pulumi.set(self, "timespan", value)

    @property
    @pulumi.getter
    def adjusted(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
        """
        return pulumi.get(self, "adjusted")

    @adjusted.setter
    def adjusted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "adjusted", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[int]]:
        """
        The target date for the aggregate window.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def sort(self) -> Optional[pulumi.Input[str]]:
        """
        Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
        """
        return pulumi.get(self, "sort")

    @sort.setter
    def sort(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sort", value)


@pulumi.input_type
class SourcePostgresConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 replication_method: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodArgs']] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_mode: Optional[pulumi.Input['SourcePostgresConfigurationSslModeArgs']] = None,
                 tunnel_method: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodArgs']] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Hostname of the database.
        :param pulumi.Input[str] username: Username to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[int] port: Port of the database. Default: 5432
        :param pulumi.Input['SourcePostgresConfigurationReplicationMethodArgs'] replication_method: Configures how data is extracted from the database.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemas: The list of schemas (case sensitive) to sync from. Defaults to public.
        :param pulumi.Input['SourcePostgresConfigurationSslModeArgs'] ssl_mode: SSL connection modes. 
                 Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        :param pulumi.Input['SourcePostgresConfigurationTunnelMethodArgs'] tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replication_method is not None:
            pulumi.set(__self__, "replication_method", replication_method)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database. Default: 5432
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="replicationMethod")
    def replication_method(self) -> Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodArgs']]:
        """
        Configures how data is extracted from the database.
        """
        return pulumi.get(self, "replication_method")

    @replication_method.setter
    def replication_method(self, value: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodArgs']]):
        pulumi.set(self, "replication_method", value)

    @property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of schemas (case sensitive) to sync from. Defaults to public.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemas", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModeArgs']]:
        """
        SSL connection modes. 
          Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModeArgs']]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodArgs']]:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @tunnel_method.setter
    def tunnel_method(self, value: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodArgs']]):
        pulumi.set(self, "tunnel_method", value)


@pulumi.input_type
class SourcePostgresConfigurationReplicationMethodArgs:
    def __init__(__self__, *,
                 detect_changes_with_xmin_system_column: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs']] = None,
                 read_changes_using_write_ahead_log_cdc: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs']] = None,
                 scan_changes_with_user_defined_cursor: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']] = None):
        """
        :param pulumi.Input['SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs'] detect_changes_with_xmin_system_column: <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
        :param pulumi.Input['SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs'] read_changes_using_write_ahead_log_cdc: <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
        :param pulumi.Input['SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs'] scan_changes_with_user_defined_cursor: Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        if detect_changes_with_xmin_system_column is not None:
            pulumi.set(__self__, "detect_changes_with_xmin_system_column", detect_changes_with_xmin_system_column)
        if read_changes_using_write_ahead_log_cdc is not None:
            pulumi.set(__self__, "read_changes_using_write_ahead_log_cdc", read_changes_using_write_ahead_log_cdc)
        if scan_changes_with_user_defined_cursor is not None:
            pulumi.set(__self__, "scan_changes_with_user_defined_cursor", scan_changes_with_user_defined_cursor)

    @property
    @pulumi.getter(name="detectChangesWithXminSystemColumn")
    def detect_changes_with_xmin_system_column(self) -> Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs']]:
        """
        <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
        """
        return pulumi.get(self, "detect_changes_with_xmin_system_column")

    @detect_changes_with_xmin_system_column.setter
    def detect_changes_with_xmin_system_column(self, value: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs']]):
        pulumi.set(self, "detect_changes_with_xmin_system_column", value)

    @property
    @pulumi.getter(name="readChangesUsingWriteAheadLogCdc")
    def read_changes_using_write_ahead_log_cdc(self) -> Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs']]:
        """
        <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
        """
        return pulumi.get(self, "read_changes_using_write_ahead_log_cdc")

    @read_changes_using_write_ahead_log_cdc.setter
    def read_changes_using_write_ahead_log_cdc(self, value: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs']]):
        pulumi.set(self, "read_changes_using_write_ahead_log_cdc", value)

    @property
    @pulumi.getter(name="scanChangesWithUserDefinedCursor")
    def scan_changes_with_user_defined_cursor(self) -> Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']]:
        """
        Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        return pulumi.get(self, "scan_changes_with_user_defined_cursor")

    @scan_changes_with_user_defined_cursor.setter
    def scan_changes_with_user_defined_cursor(self, value: Optional[pulumi.Input['SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs']]):
        pulumi.set(self, "scan_changes_with_user_defined_cursor", value)


@pulumi.input_type
class SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs:
    def __init__(__self__, *,
                 publication: pulumi.Input[str],
                 replication_slot: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 heartbeat_action_query: Optional[pulumi.Input[str]] = None,
                 initial_waiting_seconds: Optional[pulumi.Input[int]] = None,
                 invalid_cdc_cursor_position_behavior: Optional[pulumi.Input[str]] = None,
                 lsn_commit_behaviour: Optional[pulumi.Input[str]] = None,
                 plugin: Optional[pulumi.Input[str]] = None,
                 queue_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] publication: A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
        :param pulumi.Input[str] replication_slot: A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] heartbeat_action_query: Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting. Default: ""
        :param pulumi.Input[int] initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>. Default: 1200
        :param pulumi.Input[str] invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param pulumi.Input[str] lsn_commit_behaviour: Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync. must be one of ["While reading Data", "After loading Data in the destination"]; Default: "After loading Data in the destination"
        :param pulumi.Input[str] plugin: A logical decoding plugin installed on the PostgreSQL server. must be one of ["pgoutput"]; Default: "pgoutput"
        :param pulumi.Input[int] queue_size: The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        pulumi.set(__self__, "publication", publication)
        pulumi.set(__self__, "replication_slot", replication_slot)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if heartbeat_action_query is not None:
            pulumi.set(__self__, "heartbeat_action_query", heartbeat_action_query)
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if lsn_commit_behaviour is not None:
            pulumi.set(__self__, "lsn_commit_behaviour", lsn_commit_behaviour)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)

    @property
    @pulumi.getter
    def publication(self) -> pulumi.Input[str]:
        """
        A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
        """
        return pulumi.get(self, "publication")

    @publication.setter
    def publication(self, value: pulumi.Input[str]):
        pulumi.set(self, "publication", value)

    @property
    @pulumi.getter(name="replicationSlot")
    def replication_slot(self) -> pulumi.Input[str]:
        """
        A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
        """
        return pulumi.get(self, "replication_slot")

    @replication_slot.setter
    def replication_slot(self, value: pulumi.Input[str]):
        pulumi.set(self, "replication_slot", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="heartbeatActionQuery")
    def heartbeat_action_query(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting. Default: ""
        """
        return pulumi.get(self, "heartbeat_action_query")

    @heartbeat_action_query.setter
    def heartbeat_action_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "heartbeat_action_query", value)

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>. Default: 1200
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @initial_waiting_seconds.setter
    def initial_waiting_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_waiting_seconds", value)

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @invalid_cdc_cursor_position_behavior.setter
    def invalid_cdc_cursor_position_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invalid_cdc_cursor_position_behavior", value)

    @property
    @pulumi.getter(name="lsnCommitBehaviour")
    def lsn_commit_behaviour(self) -> Optional[pulumi.Input[str]]:
        """
        Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync. must be one of ["While reading Data", "After loading Data in the destination"]; Default: "After loading Data in the destination"
        """
        return pulumi.get(self, "lsn_commit_behaviour")

    @lsn_commit_behaviour.setter
    def lsn_commit_behaviour(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lsn_commit_behaviour", value)

    @property
    @pulumi.getter
    def plugin(self) -> Optional[pulumi.Input[str]]:
        """
        A logical decoding plugin installed on the PostgreSQL server. must be one of ["pgoutput"]; Default: "pgoutput"
        """
        return pulumi.get(self, "plugin")

    @plugin.setter
    def plugin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin", value)

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        return pulumi.get(self, "queue_size")

    @queue_size.setter
    def queue_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "queue_size", value)


@pulumi.input_type
class SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourcePostgresConfigurationSslModeArgs:
    def __init__(__self__, *,
                 allow: Optional[pulumi.Input['SourcePostgresConfigurationSslModeAllowArgs']] = None,
                 disable: Optional[pulumi.Input['SourcePostgresConfigurationSslModeDisableArgs']] = None,
                 prefer: Optional[pulumi.Input['SourcePostgresConfigurationSslModePreferArgs']] = None,
                 require: Optional[pulumi.Input['SourcePostgresConfigurationSslModeRequireArgs']] = None,
                 verify_ca: Optional[pulumi.Input['SourcePostgresConfigurationSslModeVerifyCaArgs']] = None,
                 verify_full: Optional[pulumi.Input['SourcePostgresConfigurationSslModeVerifyFullArgs']] = None):
        """
        :param pulumi.Input['SourcePostgresConfigurationSslModeAllowArgs'] allow: Enables encryption only when required by the source database.
        :param pulumi.Input['SourcePostgresConfigurationSslModeDisableArgs'] disable: Disables encryption of communication between Airbyte and source database.
        :param pulumi.Input['SourcePostgresConfigurationSslModePreferArgs'] prefer: Allows unencrypted connection only if the source database does not support encryption.
        :param pulumi.Input['SourcePostgresConfigurationSslModeRequireArgs'] require: Always require encryption. If the source database server does not support encryption, connection will fail.
        :param pulumi.Input['SourcePostgresConfigurationSslModeVerifyCaArgs'] verify_ca: Always require encryption and verifies that the source database server has a valid SSL certificate.
        :param pulumi.Input['SourcePostgresConfigurationSslModeVerifyFullArgs'] verify_full: This is the most secure mode. Always require encryption and verifies the identity of the source database server.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModeAllowArgs']]:
        """
        Enables encryption only when required by the source database.
        """
        return pulumi.get(self, "allow")

    @allow.setter
    def allow(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModeAllowArgs']]):
        pulumi.set(self, "allow", value)

    @property
    @pulumi.getter
    def disable(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModeDisableArgs']]:
        """
        Disables encryption of communication between Airbyte and source database.
        """
        return pulumi.get(self, "disable")

    @disable.setter
    def disable(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModeDisableArgs']]):
        pulumi.set(self, "disable", value)

    @property
    @pulumi.getter
    def prefer(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModePreferArgs']]:
        """
        Allows unencrypted connection only if the source database does not support encryption.
        """
        return pulumi.get(self, "prefer")

    @prefer.setter
    def prefer(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModePreferArgs']]):
        pulumi.set(self, "prefer", value)

    @property
    @pulumi.getter
    def require(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModeRequireArgs']]:
        """
        Always require encryption. If the source database server does not support encryption, connection will fail.
        """
        return pulumi.get(self, "require")

    @require.setter
    def require(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModeRequireArgs']]):
        pulumi.set(self, "require", value)

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModeVerifyCaArgs']]:
        """
        Always require encryption and verifies that the source database server has a valid SSL certificate.
        """
        return pulumi.get(self, "verify_ca")

    @verify_ca.setter
    def verify_ca(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModeVerifyCaArgs']]):
        pulumi.set(self, "verify_ca", value)

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional[pulumi.Input['SourcePostgresConfigurationSslModeVerifyFullArgs']]:
        """
        This is the most secure mode. Always require encryption and verifies the identity of the source database server.
        """
        return pulumi.get(self, "verify_full")

    @verify_full.setter
    def verify_full(self, value: Optional[pulumi.Input['SourcePostgresConfigurationSslModeVerifyFullArgs']]):
        pulumi.set(self, "verify_full", value)


@pulumi.input_type
class SourcePostgresConfigurationSslModeAllowArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourcePostgresConfigurationSslModeDisableArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourcePostgresConfigurationSslModePreferArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourcePostgresConfigurationSslModeRequireArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourcePostgresConfigurationSslModeVerifyCaArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] client_certificate: Client certificate
        :param pulumi.Input[str] client_key: Client key
        :param pulumi.Input[str] client_key_password: Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class SourcePostgresConfigurationSslModeVerifyFullArgs:
    def __init__(__self__, *,
                 ca_certificate: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_key_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certificate: CA certificate
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] client_certificate: Client certificate
        :param pulumi.Input[str] client_key: Client key
        :param pulumi.Input[str] client_key_password: Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> pulumi.Input[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")

    @client_key_password.setter
    def client_key_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key_password", value)


@pulumi.input_type
class SourcePostgresConfigurationTunnelMethodArgs:
    def __init__(__self__, *,
                 no_tunnel: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodNoTunnelArgs']] = None,
                 password_authentication: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodSshKeyAuthenticationArgs']] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodNoTunnelArgs']]:
        return pulumi.get(self, "no_tunnel")

    @no_tunnel.setter
    def no_tunnel(self, value: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodNoTunnelArgs']]):
        pulumi.set(self, "no_tunnel", value)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['SourcePostgresConfigurationTunnelMethodSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class SourcePostgresConfigurationTunnelMethodNoTunnelArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourcePostgresConfigurationTunnelMethodPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_user_password: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host
        :param pulumi.Input[str] tunnel_user_password: OS-level password for logging into the jump server host
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @tunnel_user_password.setter
    def tunnel_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user_password", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourcePostgresConfigurationTunnelMethodSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 ssh_key: pulumi.Input[str],
                 tunnel_host: pulumi.Input[str],
                 tunnel_user: pulumi.Input[str],
                 tunnel_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param pulumi.Input[str] tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param pulumi.Input[str] tunnel_user: OS-level username for logging into the jump server host.
        :param pulumi.Input[int] tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> pulumi.Input[str]:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @tunnel_host.setter
    def tunnel_host(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_host", value)

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> pulumi.Input[str]:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @tunnel_user.setter
    def tunnel_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "tunnel_user", value)

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")

    @tunnel_port.setter
    def tunnel_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "tunnel_port", value)


@pulumi.input_type
class SourcePosthogConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 base_url: Optional[pulumi.Input[str]] = None,
                 events_time_step: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] api_key: API Key. See the <a href="https://docs.airbyte.com/integrations/sources/posthog">docs</a> for information on how to generate this key.
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate the data. Any data before this date will not be replicated.
        :param pulumi.Input[str] base_url: Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com). Default: "https://app.posthog.com"
        :param pulumi.Input[int] events_time_step: Set lower value in case of failing long running sync of events stream. Default: 30
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if events_time_step is not None:
            pulumi.set(__self__, "events_time_step", events_time_step)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key. See the <a href="https://docs.airbyte.com/integrations/sources/posthog">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate the data. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com). Default: "https://app.posthog.com"
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="eventsTimeStep")
    def events_time_step(self) -> Optional[pulumi.Input[int]]:
        """
        Set lower value in case of failing long running sync of events stream. Default: 30
        """
        return pulumi.get(self, "events_time_step")

    @events_time_step.setter
    def events_time_step(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "events_time_step", value)


@pulumi.input_type
class SourcePostmarkappConfigurationArgs:
    def __init__(__self__, *,
                 x_postmark_account_token: pulumi.Input[str],
                 x_postmark_server_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] x_postmark_account_token: API Key for account
        :param pulumi.Input[str] x_postmark_server_token: API Key for server
        """
        pulumi.set(__self__, "x_postmark_account_token", x_postmark_account_token)
        pulumi.set(__self__, "x_postmark_server_token", x_postmark_server_token)

    @property
    @pulumi.getter(name="xPostmarkAccountToken")
    def x_postmark_account_token(self) -> pulumi.Input[str]:
        """
        API Key for account
        """
        return pulumi.get(self, "x_postmark_account_token")

    @x_postmark_account_token.setter
    def x_postmark_account_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "x_postmark_account_token", value)

    @property
    @pulumi.getter(name="xPostmarkServerToken")
    def x_postmark_server_token(self) -> pulumi.Input[str]:
        """
        API Key for server
        """
        return pulumi.get(self, "x_postmark_server_token")

    @x_postmark_server_token.setter
    def x_postmark_server_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "x_postmark_server_token", value)


@pulumi.input_type
class SourcePrestashopConfigurationArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_key: Your PrestaShop access key. See <a href="https://devdocs.prestashop.com/1.7/webservice/tutorials/creating-access/#create-an-access-key"> the docs </a> for info on how to obtain this.
        :param pulumi.Input[str] start_date: The Start date in the format YYYY-MM-DD.
        :param pulumi.Input[str] url: Shop URL without trailing slash.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        Your PrestaShop access key. See <a href="https://devdocs.prestashop.com/1.7/webservice/tutorials/creating-access/#create-an-access-key"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The Start date in the format YYYY-MM-DD.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Shop URL without trailing slash.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SourcePunkApiConfigurationArgs:
    def __init__(__self__, *,
                 brewed_after: pulumi.Input[str],
                 brewed_before: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] brewed_after: To extract specific data with Unique ID
        :param pulumi.Input[str] brewed_before: To extract specific data with Unique ID
        :param pulumi.Input[str] id: To extract specific data with Unique ID
        """
        pulumi.set(__self__, "brewed_after", brewed_after)
        pulumi.set(__self__, "brewed_before", brewed_before)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="brewedAfter")
    def brewed_after(self) -> pulumi.Input[str]:
        """
        To extract specific data with Unique ID
        """
        return pulumi.get(self, "brewed_after")

    @brewed_after.setter
    def brewed_after(self, value: pulumi.Input[str]):
        pulumi.set(self, "brewed_after", value)

    @property
    @pulumi.getter(name="brewedBefore")
    def brewed_before(self) -> pulumi.Input[str]:
        """
        To extract specific data with Unique ID
        """
        return pulumi.get(self, "brewed_before")

    @brewed_before.setter
    def brewed_before(self, value: pulumi.Input[str]):
        pulumi.set(self, "brewed_before", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        To extract specific data with Unique ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class SourcePypiConfigurationArgs:
    def __init__(__self__, *,
                 project_name: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] project_name: Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
        :param pulumi.Input[str] version: Version of the project/package.  Use it to find a particular release instead of all releases.
        """
        pulumi.set(__self__, "project_name", project_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> pulumi.Input[str]:
        """
        Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the project/package.  Use it to find a particular release instead of all releases.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class SourceQualarooConfigurationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 token: pulumi.Input[str],
                 survey_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[str] token: A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] survey_ids: IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)
        if survey_ids is not None:
            pulumi.set(__self__, "survey_ids", survey_ids)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="surveyIds")
    def survey_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
        """
        return pulumi.get(self, "survey_ids")

    @survey_ids.setter
    def survey_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "survey_ids", value)


@pulumi.input_type
class SourceRailzConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: Client ID (client_id)
        :param pulumi.Input[str] secret_key: Secret key (secret_key)
        :param pulumi.Input[str] start_date: Start date
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Client ID (client_id)
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        Secret key (secret_key)
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start date
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceRechargeConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 use_orders_deprecated_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] access_token: The value of the Access Token generated. See the <a href="https://docs.airbyte.com/integrations/sources/recharge">docs</a> for more information.
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[bool] use_orders_deprecated_api: Define whether or not the `Orders` stream should use the deprecated `2021-01` API version, or use `2021-11`, otherwise. Default: true
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "start_date", start_date)
        if use_orders_deprecated_api is not None:
            pulumi.set(__self__, "use_orders_deprecated_api", use_orders_deprecated_api)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The value of the Access Token generated. See the <a href="https://docs.airbyte.com/integrations/sources/recharge">docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="useOrdersDeprecatedApi")
    def use_orders_deprecated_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Define whether or not the `Orders` stream should use the deprecated `2021-01` API version, or use `2021-11`, otherwise. Default: true
        """
        return pulumi.get(self, "use_orders_deprecated_api")

    @use_orders_deprecated_api.setter
    def use_orders_deprecated_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_orders_deprecated_api", value)


@pulumi.input_type
class SourceRecreationConfigurationArgs:
    def __init__(__self__, *,
                 apikey: pulumi.Input[str],
                 query_campsites: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apikey: API Key
        """
        pulumi.set(__self__, "apikey", apikey)
        if query_campsites is not None:
            pulumi.set(__self__, "query_campsites", query_campsites)

    @property
    @pulumi.getter
    def apikey(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "apikey")

    @apikey.setter
    def apikey(self, value: pulumi.Input[str]):
        pulumi.set(self, "apikey", value)

    @property
    @pulumi.getter(name="queryCampsites")
    def query_campsites(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query_campsites")

    @query_campsites.setter
    def query_campsites(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_campsites", value)


@pulumi.input_type
class SourceRecruiteeConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 company_id: pulumi.Input[int]):
        """
        :param pulumi.Input[str] api_key: Recruitee API Key. See <a href="https://docs.recruitee.com/reference/getting-started#generate-api-token">here</a>.
        :param pulumi.Input[int] company_id: Recruitee Company ID. You can also find this ID on the <a href="https://app.recruitee.com/#/settings/api_tokens">Recruitee API tokens page</a>.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "company_id", company_id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Recruitee API Key. See <a href="https://docs.recruitee.com/reference/getting-started#generate-api-token">here</a>.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="companyId")
    def company_id(self) -> pulumi.Input[int]:
        """
        Recruitee Company ID. You can also find this ID on the <a href="https://app.recruitee.com/#/settings/api_tokens">Recruitee API tokens page</a>.
        """
        return pulumi.get(self, "company_id")

    @company_id.setter
    def company_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "company_id", value)


@pulumi.input_type
class SourceRecurlyConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 begin_time: Optional[pulumi.Input[str]] = None,
                 end_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Recurly API Key. See the  <a href="https://docs.airbyte.com/integrations/sources/recurly">docs</a> for more information on how to generate this key.
        :param pulumi.Input[str] begin_time: ISO8601 timestamp from which the replication from Recurly API will start from.
        :param pulumi.Input[str] end_time: ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
        """
        pulumi.set(__self__, "api_key", api_key)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Recurly API Key. See the  <a href="https://docs.airbyte.com/integrations/sources/recurly">docs</a> for more information on how to generate this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[pulumi.Input[str]]:
        """
        ISO8601 timestamp from which the replication from Recurly API will start from.
        """
        return pulumi.get(self, "begin_time")

    @begin_time.setter
    def begin_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "begin_time", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)


@pulumi.input_type
class SourceRedshiftConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] database: Name of the database.
        :param pulumi.Input[str] host: Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
        :param pulumi.Input[str] password: Password associated with the username.
        :param pulumi.Input[str] username: Username to use to access the database.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[int] port: Port of the database. Default: 5439
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schemas: The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port of the database. Default: 5439
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schemas", value)


@pulumi.input_type
class SourceRetentlyConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input['SourceRetentlyConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Retently
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate to Retently
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceRetentlyConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_retently_o_auth: Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuthArgs']] = None,
                 authenticate_with_api_token: Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsAuthenticateWithApiTokenArgs']] = None):
        if authenticate_via_retently_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_retently_o_auth", authenticate_via_retently_o_auth)
        if authenticate_with_api_token is not None:
            pulumi.set(__self__, "authenticate_with_api_token", authenticate_with_api_token)

    @property
    @pulumi.getter(name="authenticateViaRetentlyOAuth")
    def authenticate_via_retently_o_auth(self) -> Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuthArgs']]:
        return pulumi.get(self, "authenticate_via_retently_o_auth")

    @authenticate_via_retently_o_auth.setter
    def authenticate_via_retently_o_auth(self, value: Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuthArgs']]):
        pulumi.set(self, "authenticate_via_retently_o_auth", value)

    @property
    @pulumi.getter(name="authenticateWithApiToken")
    def authenticate_with_api_token(self) -> Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsAuthenticateWithApiTokenArgs']]:
        return pulumi.get(self, "authenticate_with_api_token")

    @authenticate_with_api_token.setter
    def authenticate_with_api_token(self, value: Optional[pulumi.Input['SourceRetentlyConfigurationCredentialsAuthenticateWithApiTokenArgs']]):
        pulumi.set(self, "authenticate_with_api_token", value)


@pulumi.input_type
class SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuthArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Retently developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Retently developer application.
        :param pulumi.Input[str] refresh_token: Retently Refresh Token which can be used to fetch new Bearer Tokens when the current one expires.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Retently developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Retently developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Retently Refresh Token which can be used to fetch new Bearer Tokens when the current one expires.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceRetentlyConfigurationCredentialsAuthenticateWithApiTokenArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Retently API Token. See the <a href="https://app.retently.com/settings/api/tokens">docs</a> for more information on how to obtain this key.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_key", api_key)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Retently API Token. See the <a href="https://app.retently.com/settings/api/tokens">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceRkiCovidConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] start_date: UTC date in the format 2017-01-25. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date in the format 2017-01-25. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceRssConfigurationArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: RSS Feed URL
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        RSS Feed URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class SourceS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceS3ConfigurationStreamArgs']]],
                 aws_access_key_id: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[str]] = None,
                 dataset: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 format: Optional[pulumi.Input['SourceS3ConfigurationFormatArgs']] = None,
                 path_pattern: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input['SourceS3ConfigurationProviderArgs']] = None,
                 region_name: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of the S3 bucket where the file(s) exist.
        :param pulumi.Input[Sequence[pulumi.Input['SourceS3ConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] aws_access_key_id: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param pulumi.Input[str] aws_secret_access_key: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param pulumi.Input[str] dataset: Deprecated and will be removed soon. Please do not use this field anymore and use streams.name instead. The name of the stream you would like this source to output. Can contain letters, numbers, or underscores.
        :param pulumi.Input[str] endpoint: Endpoint to an S3 compatible service. Leave empty to use AWS. The custom endpoint must be secure, but the 'https' prefix is not required. Default: ""
        :param pulumi.Input['SourceS3ConfigurationFormatArgs'] format: Deprecated and will be removed soon. Please do not use this field anymore and use streams.format instead. The format of the files you'd like to replicate
        :param pulumi.Input[str] path_pattern: Deprecated and will be removed soon. Please do not use this field anymore and use streams.globs instead. A regular expression which tells the connector which files to replicate. All files which match this pattern will be replicated. Use | to separate multiple patterns. See <a href="https://facelessuser.github.io/wcmatch/glob/" target="_blank">this page</a> to understand pattern syntax (GLOBSTAR and SPLIT flags are enabled). Use pattern <strong>**</strong> to pick up all files.
        :param pulumi.Input['SourceS3ConfigurationProviderArgs'] provider: Deprecated and will be removed soon. Please do not use this field anymore and use bucket, aws_access_key_id, aws_secret_access_key and endpoint instead. Use this to load files from S3 or S3-compatible services
        :param pulumi.Input[str] region_name: AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        :param pulumi.Input[str] role_arn: Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        :param pulumi.Input[str] schema: Deprecated and will be removed soon. Please do not use this field anymore and use streams.input_schema instead. Optionally provide a schema to enforce, as a valid JSON string. Ensure this is a mapping of <strong>{ "column" : "type" }</strong>, where types are valid <a href="https://json-schema.org/understanding-json-schema/reference/type.html" target="_blank">JSON Schema datatypes</a>. Leave as {} to auto-infer the schema. Default: "{}"
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "streams", streams)
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if path_pattern is not None:
            pulumi.set(__self__, "path_pattern", path_pattern)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of the S3 bucket where the file(s) exist.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceS3ConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceS3ConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.name instead. The name of the stream you would like this source to output. Can contain letters, numbers, or underscores.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint to an S3 compatible service. Leave empty to use AWS. The custom endpoint must be secure, but the 'https' prefix is not required. Default: ""
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input['SourceS3ConfigurationFormatArgs']]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.format instead. The format of the files you'd like to replicate
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input['SourceS3ConfigurationFormatArgs']]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.globs instead. A regular expression which tells the connector which files to replicate. All files which match this pattern will be replicated. Use | to separate multiple patterns. See <a href="https://facelessuser.github.io/wcmatch/glob/" target="_blank">this page</a> to understand pattern syntax (GLOBSTAR and SPLIT flags are enabled). Use pattern <strong>**</strong> to pick up all files.
        """
        return pulumi.get(self, "path_pattern")

    @path_pattern.setter
    def path_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_pattern", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input['SourceS3ConfigurationProviderArgs']]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use bucket, aws_access_key_id, aws_secret_access_key and endpoint instead. Use this to load files from S3 or S3-compatible services
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input['SourceS3ConfigurationProviderArgs']]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.input_schema instead. Optionally provide a schema to enforce, as a valid JSON string. Ensure this is a mapping of <strong>{ "column" : "type" }</strong>, where types are valid <a href="https://json-schema.org/understanding-json-schema/reference/type.html" target="_blank">JSON Schema datatypes</a>. Leave as {} to auto-infer the schema. Default: "{}"
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceS3ConfigurationFormatArgs:
    def __init__(__self__, *,
                 avro: Optional[pulumi.Input['SourceS3ConfigurationFormatAvroArgs']] = None,
                 csv: Optional[pulumi.Input['SourceS3ConfigurationFormatCsvArgs']] = None,
                 jsonl: Optional[pulumi.Input['SourceS3ConfigurationFormatJsonlArgs']] = None,
                 parquet: Optional[pulumi.Input['SourceS3ConfigurationFormatParquetArgs']] = None):
        """
        :param pulumi.Input['SourceS3ConfigurationFormatAvroArgs'] avro: This connector utilises <a href="https://fastavro.readthedocs.io/en/latest/" target="_blank">fastavro</a> for Avro parsing.
        :param pulumi.Input['SourceS3ConfigurationFormatCsvArgs'] csv: This connector utilises <a href="https: // arrow.apache.org/docs/python/generated/pyarrow.csv.open_csv.html" target="_blank">PyArrow (Apache Arrow)</a> for CSV parsing.
        :param pulumi.Input['SourceS3ConfigurationFormatJsonlArgs'] jsonl: This connector uses <a href="https://arrow.apache.org/docs/python/json.html" target="_blank">PyArrow</a> for JSON Lines (jsonl) file parsing.
        :param pulumi.Input['SourceS3ConfigurationFormatParquetArgs'] parquet: This connector utilises <a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetFile.html" target="_blank">PyArrow (Apache Arrow)</a> for Parquet parsing.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if jsonl is not None:
            pulumi.set(__self__, "jsonl", jsonl)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def avro(self) -> Optional[pulumi.Input['SourceS3ConfigurationFormatAvroArgs']]:
        """
        This connector utilises <a href="https://fastavro.readthedocs.io/en/latest/" target="_blank">fastavro</a> for Avro parsing.
        """
        return pulumi.get(self, "avro")

    @avro.setter
    def avro(self, value: Optional[pulumi.Input['SourceS3ConfigurationFormatAvroArgs']]):
        pulumi.set(self, "avro", value)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['SourceS3ConfigurationFormatCsvArgs']]:
        """
        This connector utilises <a href="https: // arrow.apache.org/docs/python/generated/pyarrow.csv.open_csv.html" target="_blank">PyArrow (Apache Arrow)</a> for CSV parsing.
        """
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['SourceS3ConfigurationFormatCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def jsonl(self) -> Optional[pulumi.Input['SourceS3ConfigurationFormatJsonlArgs']]:
        """
        This connector uses <a href="https://arrow.apache.org/docs/python/json.html" target="_blank">PyArrow</a> for JSON Lines (jsonl) file parsing.
        """
        return pulumi.get(self, "jsonl")

    @jsonl.setter
    def jsonl(self, value: Optional[pulumi.Input['SourceS3ConfigurationFormatJsonlArgs']]):
        pulumi.set(self, "jsonl", value)

    @property
    @pulumi.getter
    def parquet(self) -> Optional[pulumi.Input['SourceS3ConfigurationFormatParquetArgs']]:
        """
        This connector utilises <a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetFile.html" target="_blank">PyArrow (Apache Arrow)</a> for Parquet parsing.
        """
        return pulumi.get(self, "parquet")

    @parquet.setter
    def parquet(self, value: Optional[pulumi.Input['SourceS3ConfigurationFormatParquetArgs']]):
        pulumi.set(self, "parquet", value)


@pulumi.input_type
class SourceS3ConfigurationFormatAvroArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceS3ConfigurationFormatCsvArgs:
    def __init__(__self__, *,
                 additional_reader_options: Optional[pulumi.Input[str]] = None,
                 advanced_options: Optional[pulumi.Input[str]] = None,
                 block_size: Optional[pulumi.Input[int]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 infer_datatypes: Optional[pulumi.Input[bool]] = None,
                 newlines_in_values: Optional[pulumi.Input[bool]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_reader_options: Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank">detailed here</a>. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
        :param pulumi.Input[str] advanced_options: Optionally add a valid JSON string here to provide additional <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank">Pyarrow ReadOptions</a>. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
        :param pulumi.Input[int] block_size: The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 10000
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[bool] infer_datatypes: Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings. Default: true
        :param pulumi.Input[bool] newlines_in_values: Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False. Default: false
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        if additional_reader_options is not None:
            pulumi.set(__self__, "additional_reader_options", additional_reader_options)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if infer_datatypes is not None:
            pulumi.set(__self__, "infer_datatypes", infer_datatypes)
        if newlines_in_values is not None:
            pulumi.set(__self__, "newlines_in_values", newlines_in_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)

    @property
    @pulumi.getter(name="additionalReaderOptions")
    def additional_reader_options(self) -> Optional[pulumi.Input[str]]:
        """
        Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank">detailed here</a>. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
        """
        return pulumi.get(self, "additional_reader_options")

    @additional_reader_options.setter
    def additional_reader_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_reader_options", value)

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[pulumi.Input[str]]:
        """
        Optionally add a valid JSON string here to provide additional <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank">Pyarrow ReadOptions</a>. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
        """
        return pulumi.get(self, "advanced_options")

    @advanced_options.setter
    def advanced_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "advanced_options", value)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[pulumi.Input[int]]:
        """
        The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 10000
        """
        return pulumi.get(self, "block_size")

    @block_size.setter
    def block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="inferDatatypes")
    def infer_datatypes(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings. Default: true
        """
        return pulumi.get(self, "infer_datatypes")

    @infer_datatypes.setter
    def infer_datatypes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "infer_datatypes", value)

    @property
    @pulumi.getter(name="newlinesInValues")
    def newlines_in_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False. Default: false
        """
        return pulumi.get(self, "newlines_in_values")

    @newlines_in_values.setter
    def newlines_in_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "newlines_in_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)


@pulumi.input_type
class SourceS3ConfigurationFormatJsonlArgs:
    def __init__(__self__, *,
                 block_size: Optional[pulumi.Input[int]] = None,
                 newlines_in_values: Optional[pulumi.Input[bool]] = None,
                 unexpected_field_behavior: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] block_size: The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 0
        :param pulumi.Input[bool] newlines_in_values: Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False. Default: false
        :param pulumi.Input[str] unexpected_field_behavior: How JSON fields outside of explicit_schema (if given) are treated. Check <a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank">PyArrow documentation</a> for details. must be one of ["ignore", "infer", "error"]; Default: "infer"
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if newlines_in_values is not None:
            pulumi.set(__self__, "newlines_in_values", newlines_in_values)
        if unexpected_field_behavior is not None:
            pulumi.set(__self__, "unexpected_field_behavior", unexpected_field_behavior)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[pulumi.Input[int]]:
        """
        The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 0
        """
        return pulumi.get(self, "block_size")

    @block_size.setter
    def block_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_size", value)

    @property
    @pulumi.getter(name="newlinesInValues")
    def newlines_in_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False. Default: false
        """
        return pulumi.get(self, "newlines_in_values")

    @newlines_in_values.setter
    def newlines_in_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "newlines_in_values", value)

    @property
    @pulumi.getter(name="unexpectedFieldBehavior")
    def unexpected_field_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        How JSON fields outside of explicit_schema (if given) are treated. Check <a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank">PyArrow documentation</a> for details. must be one of ["ignore", "infer", "error"]; Default: "infer"
        """
        return pulumi.get(self, "unexpected_field_behavior")

    @unexpected_field_behavior.setter
    def unexpected_field_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unexpected_field_behavior", value)


@pulumi.input_type
class SourceS3ConfigurationFormatParquetArgs:
    def __init__(__self__, *,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 buffer_size: Optional[pulumi.Input[int]] = None,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] batch_size: Maximum number of records per batch read from the input files. Batches may be smaller if there arent enough rows in the file. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 65536
        :param pulumi.Input[int] buffer_size: Perform read buffering when deserializing individual column chunks. By default every group column will be loaded fully to memory. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 2
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: If you only want to sync a subset of the columns from the file(s), add the columns you want here as a comma-delimited list. Leave it empty to sync all columns.
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if buffer_size is not None:
            pulumi.set(__self__, "buffer_size", buffer_size)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of records per batch read from the input files. Batches may be smaller if there arent enough rows in the file. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 65536
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> Optional[pulumi.Input[int]]:
        """
        Perform read buffering when deserializing individual column chunks. By default every group column will be loaded fully to memory. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 2
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "buffer_size", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If you only want to sync a subset of the columns from the file(s), add the columns you want here as a comma-delimited list. Leave it empty to sync all columns.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "columns", value)


@pulumi.input_type
class SourceS3ConfigurationProviderArgs:
    def __init__(__self__, *,
                 aws_access_key_id: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[str]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 path_prefix: Optional[pulumi.Input[str]] = None,
                 region_name: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_access_key_id: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param pulumi.Input[str] aws_secret_access_key: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param pulumi.Input[str] bucket: Name of the S3 bucket where the file(s) exist.
        :param pulumi.Input[str] endpoint: Endpoint to an S3 compatible service. Leave empty to use AWS. Default: ""
        :param pulumi.Input[str] path_prefix: By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate. Default: ""
        :param pulumi.Input[str] region_name: AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        :param pulumi.Input[str] role_arn: Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the S3 bucket where the file(s) exist.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint to an S3 compatible service. Leave empty to use AWS. Default: ""
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate. Default: ""
        """
        return pulumi.get(self, "path_prefix")

    @path_prefix.setter
    def path_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_prefix", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceS3ConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceS3ConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 legacy_prefix: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceS3ConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] legacy_prefix: The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceS3ConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceS3ConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @legacy_prefix.setter
    def legacy_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legacy_prefix", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 avro_format: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatAvroFormatArgs']] = None,
                 csv_format: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatArgs']] = None,
                 document_file_type_format_experimental: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']] = None,
                 jsonl_format: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatJsonlFormatArgs']] = None,
                 parquet_format: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatParquetFormatArgs']] = None):
        """
        :param pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs'] document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatAvroFormatArgs']]:
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @document_file_type_format_experimental.setter
    def document_file_type_format_experimental(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]):
        pulumi.set(self, "document_file_type_format_experimental", value)

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatJsonlFormatArgs']]:
        return pulumi.get(self, "jsonl_format")

    @jsonl_format.setter
    def jsonl_format(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatJsonlFormatArgs']]):
        pulumi.set(self, "jsonl_format", value)

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatParquetFormatArgs']]:
        return pulumi.get(self, "parquet_format")

    @parquet_format.setter
    def parquet_format(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatParquetFormatArgs']]):
        pulumi.set(self, "parquet_format", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatAvroFormatArgs:
    def __init__(__self__, *,
                 double_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")

    @double_as_string.setter
    def double_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_as_string", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 ignore_errors_on_fields_mismatch: Optional[pulumi.Input[bool]] = None,
                 inference_type: Optional[pulumi.Input[str]] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[bool] ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param pulumi.Input[str] inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @ignore_errors_on_fields_mismatch.setter
    def ignore_errors_on_fields_mismatch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors_on_fields_mismatch", value)

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[pulumi.Input[str]]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @inference_type.setter
    def inference_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_type", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs:
    def __init__(__self__, *,
                 processing: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']] = None,
                 skip_unprocessable_files: Optional[pulumi.Input[bool]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs'] processing: Processing configuration
        :param pulumi.Input[bool] skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param pulumi.Input[str] strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @skip_unprocessable_files.setter
    def skip_unprocessable_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unprocessable_files", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs:
    def __init__(__self__, *,
                 local: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']] = None):
        """
        :param pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs'] local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input['SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]):
        pulumi.set(self, "local", value)


@pulumi.input_type
class SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceS3ConfigurationStreamFormatJsonlFormatArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceS3ConfigurationStreamFormatParquetFormatArgs:
    def __init__(__self__, *,
                 decimal_as_float: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")

    @decimal_as_float.setter
    def decimal_as_float(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decimal_as_float", value)


@pulumi.input_type
class SourceSalesforceConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 force_use_bulk_api: Optional[pulumi.Input[bool]] = None,
                 is_sandbox: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 stream_slice_step: Optional[pulumi.Input[str]] = None,
                 streams_criterias: Optional[pulumi.Input[Sequence[pulumi.Input['SourceSalesforceConfigurationStreamsCriteriaArgs']]]] = None):
        """
        :param pulumi.Input[str] client_id: Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>
        :param pulumi.Input[str] client_secret: Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>
        :param pulumi.Input[str] refresh_token: Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
        :param pulumi.Input[bool] force_use_bulk_api: Toggle to use Bulk API (this might cause empty fields for some streams). Default: false
        :param pulumi.Input[bool] is_sandbox: Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>. Default: false
        :param pulumi.Input[str] start_date: Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
        :param pulumi.Input[str] stream_slice_step: The size of the time window (ISO8601 duration) to slice requests. Default: "P30D"
        :param pulumi.Input[Sequence[pulumi.Input['SourceSalesforceConfigurationStreamsCriteriaArgs']]] streams_criterias: Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if force_use_bulk_api is not None:
            pulumi.set(__self__, "force_use_bulk_api", force_use_bulk_api)
        if is_sandbox is not None:
            pulumi.set(__self__, "is_sandbox", is_sandbox)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if stream_slice_step is not None:
            pulumi.set(__self__, "stream_slice_step", stream_slice_step)
        if streams_criterias is not None:
            pulumi.set(__self__, "streams_criterias", streams_criterias)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="forceUseBulkApi")
    def force_use_bulk_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle to use Bulk API (this might cause empty fields for some streams). Default: false
        """
        return pulumi.get(self, "force_use_bulk_api")

    @force_use_bulk_api.setter
    def force_use_bulk_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_use_bulk_api", value)

    @property
    @pulumi.getter(name="isSandbox")
    def is_sandbox(self) -> Optional[pulumi.Input[bool]]:
        """
        Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>. Default: false
        """
        return pulumi.get(self, "is_sandbox")

    @is_sandbox.setter
    def is_sandbox(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_sandbox", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="streamSliceStep")
    def stream_slice_step(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the time window (ISO8601 duration) to slice requests. Default: "P30D"
        """
        return pulumi.get(self, "stream_slice_step")

    @stream_slice_step.setter
    def stream_slice_step(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_slice_step", value)

    @property
    @pulumi.getter(name="streamsCriterias")
    def streams_criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceSalesforceConfigurationStreamsCriteriaArgs']]]]:
        """
        Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
        """
        return pulumi.get(self, "streams_criterias")

    @streams_criterias.setter
    def streams_criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceSalesforceConfigurationStreamsCriteriaArgs']]]]):
        pulumi.set(self, "streams_criterias", value)


@pulumi.input_type
class SourceSalesforceConfigurationStreamsCriteriaArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 criteria: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] criteria: must be one of ["starts with", "ends with", "contains", "exacts", "starts not with", "ends not with", "not contains", "not exacts"]; Default: "contains"
        """
        pulumi.set(__self__, "value", value)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input[str]]:
        """
        must be one of ["starts with", "ends with", "contains", "exacts", "starts not with", "ends not with", "not contains", "not exacts"]; Default: "contains"
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "criteria", value)


@pulumi.input_type
class SourceSalesloftConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceSalesloftConfigurationCredentialsArgs'],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceSalesloftConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceSalesloftConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSalesloftConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_api_key: Optional[pulumi.Input['SourceSalesloftConfigurationCredentialsAuthenticateViaApiKeyArgs']] = None,
                 authenticate_via_o_auth: Optional[pulumi.Input['SourceSalesloftConfigurationCredentialsAuthenticateViaOAuthArgs']] = None):
        if authenticate_via_api_key is not None:
            pulumi.set(__self__, "authenticate_via_api_key", authenticate_via_api_key)
        if authenticate_via_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_o_auth", authenticate_via_o_auth)

    @property
    @pulumi.getter(name="authenticateViaApiKey")
    def authenticate_via_api_key(self) -> Optional[pulumi.Input['SourceSalesloftConfigurationCredentialsAuthenticateViaApiKeyArgs']]:
        return pulumi.get(self, "authenticate_via_api_key")

    @authenticate_via_api_key.setter
    def authenticate_via_api_key(self, value: Optional[pulumi.Input['SourceSalesloftConfigurationCredentialsAuthenticateViaApiKeyArgs']]):
        pulumi.set(self, "authenticate_via_api_key", value)

    @property
    @pulumi.getter(name="authenticateViaOAuth")
    def authenticate_via_o_auth(self) -> Optional[pulumi.Input['SourceSalesloftConfigurationCredentialsAuthenticateViaOAuthArgs']]:
        return pulumi.get(self, "authenticate_via_o_auth")

    @authenticate_via_o_auth.setter
    def authenticate_via_o_auth(self, value: Optional[pulumi.Input['SourceSalesloftConfigurationCredentialsAuthenticateViaOAuthArgs']]):
        pulumi.set(self, "authenticate_via_o_auth", value)


@pulumi.input_type
class SourceSalesloftConfigurationCredentialsAuthenticateViaApiKeyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key for making authenticated requests. More instruction on how to find this value in our <a href="https://docs.airbyte.com/integrations/sources/salesloft#setup-guide">docs</a>
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key for making authenticated requests. More instruction on how to find this value in our <a href="https://docs.airbyte.com/integrations/sources/salesloft#setup-guide">docs</a>
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceSalesloftConfigurationCredentialsAuthenticateViaOAuthArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 token_expiry_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The Client ID of your Salesloft developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Salesloft developer application.
        :param pulumi.Input[str] refresh_token: The token for obtaining a new access token.
        :param pulumi.Input[str] token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Salesloft developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Salesloft developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The token for obtaining a new access token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> pulumi.Input[str]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")

    @token_expiry_date.setter
    def token_expiry_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_expiry_date", value)


@pulumi.input_type
class SourceSapFieldglassConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceSecodaConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Your API Access Key. See <a href="https://docs.secoda.co/secoda-api/authentication">here</a>. The key is case sensitive.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API Access Key. See <a href="https://docs.secoda.co/secoda-api/authentication">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceSendgridConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Sendgrid API Key, use <a href=\\"https://app.sendgrid.com/settings/api_keys/\\">admin</a> to generate this key.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Sendgrid API Key, use <a href=\\"https://app.sendgrid.com/settings/api_keys/\\">admin</a> to generate this key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSendinblueConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Your API Key. See <a href="https://developers.sendinblue.com/docs/getting-started">here</a>.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API Key. See <a href="https://developers.sendinblue.com/docs/getting-started">here</a>.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceSenseforceConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 backend_url: pulumi.Input[str],
                 dataset_id: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 slice_range: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] access_token: Your API access token. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a>. The toke is case sensitive.
        :param pulumi.Input[str] backend_url: Your Senseforce API backend URL. This is the URL shown during the Login screen. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
        :param pulumi.Input[str] dataset_id: The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the start_date to 2020-10-10 or later
        :param pulumi.Input[int] slice_range: The time increment used by the connector when requesting data from the Senseforce API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted and the more likely one could run into rate limites.  Furthermore, consider that large chunks of time might take a long time for the Senseforce query to return data - meaning it could take in effect longer than with more smaller time slices. If there are a lot of data per day, set this setting to 1. If there is only very little data per day, you might change the setting to 10 or more. Default: 10
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "backend_url", backend_url)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "start_date", start_date)
        if slice_range is not None:
            pulumi.set(__self__, "slice_range", slice_range)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Your API access token. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a>. The toke is case sensitive.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="backendUrl")
    def backend_url(self) -> pulumi.Input[str]:
        """
        Your Senseforce API backend URL. This is the URL shown during the Login screen. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
        """
        return pulumi.get(self, "backend_url")

    @backend_url.setter
    def backend_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_url", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the start_date to 2020-10-10 or later
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="sliceRange")
    def slice_range(self) -> Optional[pulumi.Input[int]]:
        """
        The time increment used by the connector when requesting data from the Senseforce API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted and the more likely one could run into rate limites.  Furthermore, consider that large chunks of time might take a long time for the Senseforce query to return data - meaning it could take in effect longer than with more smaller time slices. If there are a lot of data per day, set this setting to 1. If there is only very little data per day, you might change the setting to 10 or more. Default: 10
        """
        return pulumi.get(self, "slice_range")

    @slice_range.setter
    def slice_range(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slice_range", value)


@pulumi.input_type
class SourceSentryConfigurationArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[str],
                 organization: pulumi.Input[str],
                 project: pulumi.Input[str],
                 discover_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_token: Log into Sentry and then <a href="https://sentry.io/settings/account/api/auth-tokens/">create authentication tokens</a>.For self-hosted, you can find or create authentication tokens by visiting "{instance_url_prefix}/settings/account/api/auth-tokens/"
        :param pulumi.Input[str] organization: The slug of the organization the groups belong to.
        :param pulumi.Input[str] project: The name (slug) of the Project you want to sync.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] discover_fields: Fields to retrieve when fetching discover events
        :param pulumi.Input[str] hostname: Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty. Default: "sentry.io"
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "project", project)
        if discover_fields is not None:
            pulumi.set(__self__, "discover_fields", discover_fields)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[str]:
        """
        Log into Sentry and then <a href="https://sentry.io/settings/account/api/auth-tokens/">create authentication tokens</a>.For self-hosted, you can find or create authentication tokens by visiting "{instance_url_prefix}/settings/account/api/auth-tokens/"
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter
    def organization(self) -> pulumi.Input[str]:
        """
        The slug of the organization the groups belong to.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter
    def project(self) -> pulumi.Input[str]:
        """
        The name (slug) of the Project you want to sync.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[str]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="discoverFields")
    def discover_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Fields to retrieve when fetching discover events
        """
        return pulumi.get(self, "discover_fields")

    @discover_fields.setter
    def discover_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "discover_fields", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty. Default: "sentry.io"
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


@pulumi.input_type
class SourceSftpBulkConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceSftpBulkConfigurationCredentialsArgs'],
                 host: pulumi.Input[str],
                 streams: pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamArgs']]],
                 username: pulumi.Input[str],
                 folder_path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceSftpBulkConfigurationCredentialsArgs'] credentials: Credentials for connecting to the SFTP Server
        :param pulumi.Input[str] host: The server host address
        :param pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamArgs']]] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param pulumi.Input[str] username: The server user
        :param pulumi.Input[str] folder_path: The directory to search files for sync. Default: "/"
        :param pulumi.Input[int] port: The server port. Default: 22
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "streams", streams)
        pulumi.set(__self__, "username", username)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceSftpBulkConfigurationCredentialsArgs']:
        """
        Credentials for connecting to the SFTP Server
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceSftpBulkConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The server host address
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def streams(self) -> pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamArgs']]]:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @streams.setter
    def streams(self, value: pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamArgs']]]):
        pulumi.set(self, "streams", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The server user
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory to search files for sync. Default: "/"
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The server port. Default: 22
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSftpBulkConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 authenticate_via_password: Optional[pulumi.Input['SourceSftpBulkConfigurationCredentialsAuthenticateViaPasswordArgs']] = None,
                 authenticate_via_private_key: Optional[pulumi.Input['SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKeyArgs']] = None):
        if authenticate_via_password is not None:
            pulumi.set(__self__, "authenticate_via_password", authenticate_via_password)
        if authenticate_via_private_key is not None:
            pulumi.set(__self__, "authenticate_via_private_key", authenticate_via_private_key)

    @property
    @pulumi.getter(name="authenticateViaPassword")
    def authenticate_via_password(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationCredentialsAuthenticateViaPasswordArgs']]:
        return pulumi.get(self, "authenticate_via_password")

    @authenticate_via_password.setter
    def authenticate_via_password(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationCredentialsAuthenticateViaPasswordArgs']]):
        pulumi.set(self, "authenticate_via_password", value)

    @property
    @pulumi.getter(name="authenticateViaPrivateKey")
    def authenticate_via_private_key(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKeyArgs']]:
        return pulumi.get(self, "authenticate_via_private_key")

    @authenticate_via_private_key.setter
    def authenticate_via_private_key(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKeyArgs']]):
        pulumi.set(self, "authenticate_via_private_key", value)


@pulumi.input_type
class SourceSftpBulkConfigurationCredentialsAuthenticateViaPasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Password
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


@pulumi.input_type
class SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKeyArgs:
    def __init__(__self__, *,
                 private_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] private_key: The Private key
        """
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[str]:
        """
        The Private key
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamArgs:
    def __init__(__self__, *,
                 format: pulumi.Input['SourceSftpBulkConfigurationStreamFormatArgs'],
                 name: pulumi.Input[str],
                 days_to_sync_if_history_is_full: Optional[pulumi.Input[int]] = None,
                 globs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 input_schema: Optional[pulumi.Input[str]] = None,
                 legacy_prefix: Optional[pulumi.Input[str]] = None,
                 primary_key: Optional[pulumi.Input[str]] = None,
                 schemaless: Optional[pulumi.Input[bool]] = None,
                 validation_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceSftpBulkConfigurationStreamFormatArgs'] format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param pulumi.Input[str] name: The name of the stream.
        :param pulumi.Input[int] days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param pulumi.Input[Sequence[pulumi.Input[str]]] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param pulumi.Input[str] input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param pulumi.Input[str] legacy_prefix: The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        :param pulumi.Input[str] primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param pulumi.Input[bool] schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param pulumi.Input[str] validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['SourceSftpBulkConfigurationStreamFormatArgs']:
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['SourceSftpBulkConfigurationStreamFormatArgs']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[pulumi.Input[int]]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @days_to_sync_if_history_is_full.setter
    def days_to_sync_if_history_is_full(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days_to_sync_if_history_is_full", value)

    @property
    @pulumi.getter
    def globs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @globs.setter
    def globs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "globs", value)

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[str]]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_schema", value)

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @legacy_prefix.setter
    def legacy_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "legacy_prefix", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[str]]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @schemaless.setter
    def schemaless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "schemaless", value)

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")

    @validation_policy.setter
    def validation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_policy", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatArgs:
    def __init__(__self__, *,
                 avro_format: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatAvroFormatArgs']] = None,
                 csv_format: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatArgs']] = None,
                 document_file_type_format_experimental: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']] = None,
                 jsonl_format: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatJsonlFormatArgs']] = None,
                 parquet_format: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatParquetFormatArgs']] = None):
        """
        :param pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs'] document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatAvroFormatArgs']]:
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatArgs']]:
        return pulumi.get(self, "csv_format")

    @csv_format.setter
    def csv_format(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatArgs']]):
        pulumi.set(self, "csv_format", value)

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @document_file_type_format_experimental.setter
    def document_file_type_format_experimental(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs']]):
        pulumi.set(self, "document_file_type_format_experimental", value)

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatJsonlFormatArgs']]:
        return pulumi.get(self, "jsonl_format")

    @jsonl_format.setter
    def jsonl_format(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatJsonlFormatArgs']]):
        pulumi.set(self, "jsonl_format", value)

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatParquetFormatArgs']]:
        return pulumi.get(self, "parquet_format")

    @parquet_format.setter
    def parquet_format(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatParquetFormatArgs']]):
        pulumi.set(self, "parquet_format", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatAvroFormatArgs:
    def __init__(__self__, *,
                 double_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")

    @double_as_string.setter
    def double_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_as_string", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 double_quote: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 false_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 header_definition: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']] = None,
                 ignore_errors_on_fields_mismatch: Optional[pulumi.Input[bool]] = None,
                 inference_type: Optional[pulumi.Input[str]] = None,
                 null_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 skip_rows_after_header: Optional[pulumi.Input[int]] = None,
                 skip_rows_before_header: Optional[pulumi.Input[int]] = None,
                 strings_can_be_null: Optional[pulumi.Input[bool]] = None,
                 true_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param pulumi.Input[bool] double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param pulumi.Input[str] encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param pulumi.Input[str] escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs'] header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param pulumi.Input[bool] ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param pulumi.Input[str] inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param pulumi.Input[str] quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param pulumi.Input[int] skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param pulumi.Input[int] skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param pulumi.Input[bool] strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @double_quote.setter
    def double_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "double_quote", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @false_values.setter
    def false_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "false_values", value)

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @header_definition.setter
    def header_definition(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs']]):
        pulumi.set(self, "header_definition", value)

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @ignore_errors_on_fields_mismatch.setter
    def ignore_errors_on_fields_mismatch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors_on_fields_mismatch", value)

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[pulumi.Input[str]]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @inference_type.setter
    def inference_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_type", value)

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @null_values.setter
    def null_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "null_values", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @skip_rows_after_header.setter
    def skip_rows_after_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_after_header", value)

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @skip_rows_before_header.setter
    def skip_rows_before_header(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_rows_before_header", value)

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @strings_can_be_null.setter
    def strings_can_be_null(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "strings_can_be_null", value)

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")

    @true_values.setter
    def true_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "true_values", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs:
    def __init__(__self__, *,
                 autogenerated: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']] = None,
                 from_csv: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']] = None,
                 user_provided: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]:
        return pulumi.get(self, "autogenerated")

    @autogenerated.setter
    def autogenerated(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs']]):
        pulumi.set(self, "autogenerated", value)

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]:
        return pulumi.get(self, "from_csv")

    @from_csv.setter
    def from_csv(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs']]):
        pulumi.set(self, "from_csv", value)

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]:
        return pulumi.get(self, "user_provided")

    @user_provided.setter
    def user_provided(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs']]):
        pulumi.set(self, "user_provided", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogeneratedArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsvArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvidedArgs:
    def __init__(__self__, *,
                 column_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "column_names", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs:
    def __init__(__self__, *,
                 processing: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']] = None,
                 skip_unprocessable_files: Optional[pulumi.Input[bool]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs'] processing: Processing configuration
        :param pulumi.Input[bool] skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param pulumi.Input[str] strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @processing.setter
    def processing(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs']]):
        pulumi.set(self, "processing", value)

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @skip_unprocessable_files.setter
    def skip_unprocessable_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_unprocessable_files", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs:
    def __init__(__self__, *,
                 local: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']] = None,
                 via_api: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs']] = None):
        """
        :param pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs'] local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        :param pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs'] via_api: Process files via an API, using the `hi_res` mode. This option is useful for increased performance and accuracy, but requires an API key and a hosted instance of unstructured.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)
        if via_api is not None:
            pulumi.set(__self__, "via_api", via_api)

    @property
    @pulumi.getter
    def local(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @local.setter
    def local(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs']]):
        pulumi.set(self, "local", value)

    @property
    @pulumi.getter(name="viaApi")
    def via_api(self) -> Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs']]:
        """
        Process files via an API, using the `hi_res` mode. This option is useful for increased performance and accuracy, but requires an API key and a hosted instance of unstructured.
        """
        return pulumi.get(self, "via_api")

    @via_api.setter
    def via_api(self, value: Optional[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs']]):
        pulumi.set(self, "via_api", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[str]] = None,
                 api_url: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] api_key: The API key to use matching the environment. Default: ""
        :param pulumi.Input[str] api_url: The URL of the unstructured API to use. Default: "https://api.unstructured.io"
        :param pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs']]] parameters: List of parameters send to the API
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        The API key to use matching the environment. Default: ""
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the unstructured API to use. Default: "https://api.unstructured.io"
        """
        return pulumi.get(self, "api_url")

    @api_url.setter
    def api_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_url", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs']]]]:
        """
        List of parameters send to the API
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the unstructured API parameter to use
        :param pulumi.Input[str] value: The value of the parameter
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the unstructured API parameter to use
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatJsonlFormatArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceSftpBulkConfigurationStreamFormatParquetFormatArgs:
    def __init__(__self__, *,
                 decimal_as_float: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")

    @decimal_as_float.setter
    def decimal_as_float(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "decimal_as_float", value)


@pulumi.input_type
class SourceSftpConfigurationArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 user: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceSftpConfigurationCredentialsArgs']] = None,
                 file_pattern: Optional[pulumi.Input[str]] = None,
                 file_types: Optional[pulumi.Input[str]] = None,
                 folder_path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: The server host address
        :param pulumi.Input[str] user: The server user
        :param pulumi.Input['SourceSftpConfigurationCredentialsArgs'] credentials: The server authentication method
        :param pulumi.Input[str] file_pattern: The regular expression to specify files for sync in a chosen Folder Path. Default: ""
        :param pulumi.Input[str] file_types: Coma separated file types. Currently only 'csv' and 'json' types are supported. Default: "csv,json"
        :param pulumi.Input[str] folder_path: The directory to search files for sync. Default: ""
        :param pulumi.Input[int] port: The server port. Default: 22
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if file_pattern is not None:
            pulumi.set(__self__, "file_pattern", file_pattern)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The server host address
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        The server user
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceSftpConfigurationCredentialsArgs']]:
        """
        The server authentication method
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceSftpConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression to specify files for sync in a chosen Folder Path. Default: ""
        """
        return pulumi.get(self, "file_pattern")

    @file_pattern.setter
    def file_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_pattern", value)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[str]]:
        """
        Coma separated file types. Currently only 'csv' and 'json' types are supported. Default: "csv,json"
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_types", value)

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[pulumi.Input[str]]:
        """
        The directory to search files for sync. Default: ""
        """
        return pulumi.get(self, "folder_path")

    @folder_path.setter
    def folder_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The server port. Default: 22
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class SourceSftpConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 password_authentication: Optional[pulumi.Input['SourceSftpConfigurationCredentialsPasswordAuthenticationArgs']] = None,
                 ssh_key_authentication: Optional[pulumi.Input['SourceSftpConfigurationCredentialsSshKeyAuthenticationArgs']] = None):
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional[pulumi.Input['SourceSftpConfigurationCredentialsPasswordAuthenticationArgs']]:
        return pulumi.get(self, "password_authentication")

    @password_authentication.setter
    def password_authentication(self, value: Optional[pulumi.Input['SourceSftpConfigurationCredentialsPasswordAuthenticationArgs']]):
        pulumi.set(self, "password_authentication", value)

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional[pulumi.Input['SourceSftpConfigurationCredentialsSshKeyAuthenticationArgs']]:
        return pulumi.get(self, "ssh_key_authentication")

    @ssh_key_authentication.setter
    def ssh_key_authentication(self, value: Optional[pulumi.Input['SourceSftpConfigurationCredentialsSshKeyAuthenticationArgs']]):
        pulumi.set(self, "ssh_key_authentication", value)


@pulumi.input_type
class SourceSftpConfigurationCredentialsPasswordAuthenticationArgs:
    def __init__(__self__, *,
                 auth_user_password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_user_password: OS-level password for logging into the jump server host
        """
        pulumi.set(__self__, "auth_user_password", auth_user_password)

    @property
    @pulumi.getter(name="authUserPassword")
    def auth_user_password(self) -> pulumi.Input[str]:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "auth_user_password")

    @auth_user_password.setter
    def auth_user_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_user_password", value)


@pulumi.input_type
class SourceSftpConfigurationCredentialsSshKeyAuthenticationArgs:
    def __init__(__self__, *,
                 auth_ssh_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        pulumi.set(__self__, "auth_ssh_key", auth_ssh_key)

    @property
    @pulumi.getter(name="authSshKey")
    def auth_ssh_key(self) -> pulumi.Input[str]:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "auth_ssh_key")

    @auth_ssh_key.setter
    def auth_ssh_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_ssh_key", value)


@pulumi.input_type
class SourceShopifyConfigurationArgs:
    def __init__(__self__, *,
                 shop: pulumi.Input[str],
                 bulk_window_in_days: Optional[pulumi.Input[int]] = None,
                 credentials: Optional[pulumi.Input['SourceShopifyConfigurationCredentialsArgs']] = None,
                 fetch_transactions_user_id: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] shop: The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
        :param pulumi.Input[int] bulk_window_in_days: Defines what would be a date range per single BULK Job. Default: 30
        :param pulumi.Input['SourceShopifyConfigurationCredentialsArgs'] credentials: The authorization method to use to retrieve data from Shopify
        :param pulumi.Input[bool] fetch_transactions_user_id: Defines which API type (REST/BULK) to use to fetch `Transactions` data. If you are a `Shopify Plus` user, leave the default value to speed up the fetch. Default: false
        :param pulumi.Input[str] start_date: The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated. Default: "2020-01-01"
        """
        pulumi.set(__self__, "shop", shop)
        if bulk_window_in_days is not None:
            pulumi.set(__self__, "bulk_window_in_days", bulk_window_in_days)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if fetch_transactions_user_id is not None:
            pulumi.set(__self__, "fetch_transactions_user_id", fetch_transactions_user_id)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def shop(self) -> pulumi.Input[str]:
        """
        The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
        """
        return pulumi.get(self, "shop")

    @shop.setter
    def shop(self, value: pulumi.Input[str]):
        pulumi.set(self, "shop", value)

    @property
    @pulumi.getter(name="bulkWindowInDays")
    def bulk_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Defines what would be a date range per single BULK Job. Default: 30
        """
        return pulumi.get(self, "bulk_window_in_days")

    @bulk_window_in_days.setter
    def bulk_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bulk_window_in_days", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceShopifyConfigurationCredentialsArgs']]:
        """
        The authorization method to use to retrieve data from Shopify
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceShopifyConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="fetchTransactionsUserId")
    def fetch_transactions_user_id(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines which API type (REST/BULK) to use to fetch `Transactions` data. If you are a `Shopify Plus` user, leave the default value to speed up the fetch. Default: false
        """
        return pulumi.get(self, "fetch_transactions_user_id")

    @fetch_transactions_user_id.setter
    def fetch_transactions_user_id(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fetch_transactions_user_id", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated. Default: "2020-01-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceShopifyConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_password: Optional[pulumi.Input['SourceShopifyConfigurationCredentialsApiPasswordArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceShopifyConfigurationCredentialsOAuth20Args']] = None):
        """
        :param pulumi.Input['SourceShopifyConfigurationCredentialsApiPasswordArgs'] api_password: API Password Auth
        :param pulumi.Input['SourceShopifyConfigurationCredentialsOAuth20Args'] o_auth20: OAuth2.0
        """
        if api_password is not None:
            pulumi.set(__self__, "api_password", api_password)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiPassword")
    def api_password(self) -> Optional[pulumi.Input['SourceShopifyConfigurationCredentialsApiPasswordArgs']]:
        """
        API Password Auth
        """
        return pulumi.get(self, "api_password")

    @api_password.setter
    def api_password(self, value: Optional[pulumi.Input['SourceShopifyConfigurationCredentialsApiPasswordArgs']]):
        pulumi.set(self, "api_password", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceShopifyConfigurationCredentialsOAuth20Args']]:
        """
        OAuth2.0
        """
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceShopifyConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceShopifyConfigurationCredentialsApiPasswordArgs:
    def __init__(__self__, *,
                 api_password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_password: The API Password for your private application in the `Shopify` store.
        """
        pulumi.set(__self__, "api_password", api_password)

    @property
    @pulumi.getter(name="apiPassword")
    def api_password(self) -> pulumi.Input[str]:
        """
        The API Password for your private application in the `Shopify` store.
        """
        return pulumi.get(self, "api_password")

    @api_password.setter
    def api_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_password", value)


@pulumi.input_type
class SourceShopifyConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The Client ID of the Shopify developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of the Shopify developer application.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        The Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the Shopify developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the Shopify developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceShortioConfigurationArgs:
    def __init__(__self__, *,
                 domain_id: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] secret_key: Short.io Secret Key
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        Short.io Secret Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSlackConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 channel_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 credentials: Optional[pulumi.Input['SourceSlackConfigurationCredentialsArgs']] = None,
                 include_private_channels: Optional[pulumi.Input[bool]] = None,
                 join_channels: Optional[pulumi.Input[bool]] = None,
                 lookback_window: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] channel_filters: A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
        :param pulumi.Input['SourceSlackConfigurationCredentialsArgs'] credentials: Choose how to authenticate into Slack
        :param pulumi.Input[bool] include_private_channels: Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels. . Default: false
        :param pulumi.Input[bool] join_channels: Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages. . Default: true
        :param pulumi.Input[int] lookback_window: How far into the past to look for messages in threads, default is 0 days. Default: 0
        """
        pulumi.set(__self__, "start_date", start_date)
        if channel_filters is not None:
            pulumi.set(__self__, "channel_filters", channel_filters)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if include_private_channels is not None:
            pulumi.set(__self__, "include_private_channels", include_private_channels)
        if join_channels is not None:
            pulumi.set(__self__, "join_channels", join_channels)
        if lookback_window is not None:
            pulumi.set(__self__, "lookback_window", lookback_window)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="channelFilters")
    def channel_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
        """
        return pulumi.get(self, "channel_filters")

    @channel_filters.setter
    def channel_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "channel_filters", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceSlackConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate into Slack
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceSlackConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="includePrivateChannels")
    def include_private_channels(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels. . Default: false
        """
        return pulumi.get(self, "include_private_channels")

    @include_private_channels.setter
    def include_private_channels(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_private_channels", value)

    @property
    @pulumi.getter(name="joinChannels")
    def join_channels(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages. . Default: true
        """
        return pulumi.get(self, "join_channels")

    @join_channels.setter
    def join_channels(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "join_channels", value)

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional[pulumi.Input[int]]:
        """
        How far into the past to look for messages in threads, default is 0 days. Default: 0
        """
        return pulumi.get(self, "lookback_window")

    @lookback_window.setter
    def lookback_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window", value)


@pulumi.input_type
class SourceSlackConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['SourceSlackConfigurationCredentialsApiTokenArgs']] = None,
                 sign_in_via_slack_o_auth: Optional[pulumi.Input['SourceSlackConfigurationCredentialsSignInViaSlackOAuthArgs']] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if sign_in_via_slack_o_auth is not None:
            pulumi.set(__self__, "sign_in_via_slack_o_auth", sign_in_via_slack_o_auth)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['SourceSlackConfigurationCredentialsApiTokenArgs']]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['SourceSlackConfigurationCredentialsApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="signInViaSlackOAuth")
    def sign_in_via_slack_o_auth(self) -> Optional[pulumi.Input['SourceSlackConfigurationCredentialsSignInViaSlackOAuthArgs']]:
        return pulumi.get(self, "sign_in_via_slack_o_auth")

    @sign_in_via_slack_o_auth.setter
    def sign_in_via_slack_o_auth(self, value: Optional[pulumi.Input['SourceSlackConfigurationCredentialsSignInViaSlackOAuthArgs']]):
        pulumi.set(self, "sign_in_via_slack_o_auth", value)


@pulumi.input_type
class SourceSlackConfigurationCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)


@pulumi.input_type
class SourceSlackConfigurationCredentialsSignInViaSlackOAuthArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
        :param pulumi.Input[str] client_id: Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
        :param pulumi.Input[str] client_secret: Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceSmailyConfigurationArgs:
    def __init__(__self__, *,
                 api_password: pulumi.Input[str],
                 api_subdomain: pulumi.Input[str],
                 api_username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_password: API user password. See https://smaily.com/help/api/general/create-api-user/
        :param pulumi.Input[str] api_subdomain: API Subdomain. See https://smaily.com/help/api/general/create-api-user/
        :param pulumi.Input[str] api_username: API user username. See https://smaily.com/help/api/general/create-api-user/
        """
        pulumi.set(__self__, "api_password", api_password)
        pulumi.set(__self__, "api_subdomain", api_subdomain)
        pulumi.set(__self__, "api_username", api_username)

    @property
    @pulumi.getter(name="apiPassword")
    def api_password(self) -> pulumi.Input[str]:
        """
        API user password. See https://smaily.com/help/api/general/create-api-user/
        """
        return pulumi.get(self, "api_password")

    @api_password.setter
    def api_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_password", value)

    @property
    @pulumi.getter(name="apiSubdomain")
    def api_subdomain(self) -> pulumi.Input[str]:
        """
        API Subdomain. See https://smaily.com/help/api/general/create-api-user/
        """
        return pulumi.get(self, "api_subdomain")

    @api_subdomain.setter
    def api_subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_subdomain", value)

    @property
    @pulumi.getter(name="apiUsername")
    def api_username(self) -> pulumi.Input[str]:
        """
        API user username. See https://smaily.com/help/api/general/create-api-user/
        """
        return pulumi.get(self, "api_username")

    @api_username.setter
    def api_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_username", value)


@pulumi.input_type
class SourceSmartengageConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: API Key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceSmartsheetsConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceSmartsheetsConfigurationCredentialsArgs'],
                 spreadsheet_id: pulumi.Input[str],
                 metadata_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 start_datetime: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] spreadsheet_id: The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
        :param pulumi.Input[Sequence[pulumi.Input[str]]] metadata_fields: A List of available columns which metadata can be pulled from.
        :param pulumi.Input[str] start_datetime: Only rows modified after this date/time will be replicated. This should be an ISO 8601 string, for instance: `2000-01-01T13:00:00`. Default: "2020-01-01T00:00:00+00:00"
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "spreadsheet_id", spreadsheet_id)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if start_datetime is not None:
            pulumi.set(__self__, "start_datetime", start_datetime)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceSmartsheetsConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceSmartsheetsConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="spreadsheetId")
    def spreadsheet_id(self) -> pulumi.Input[str]:
        """
        The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
        """
        return pulumi.get(self, "spreadsheet_id")

    @spreadsheet_id.setter
    def spreadsheet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "spreadsheet_id", value)

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A List of available columns which metadata can be pulled from.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "metadata_fields", value)

    @property
    @pulumi.getter(name="startDatetime")
    def start_datetime(self) -> Optional[pulumi.Input[str]]:
        """
        Only rows modified after this date/time will be replicated. This should be an ISO 8601 string, for instance: `2000-01-01T13:00:00`. Default: "2020-01-01T00:00:00+00:00"
        """
        return pulumi.get(self, "start_datetime")

    @start_datetime.setter
    def start_datetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_datetime", value)


@pulumi.input_type
class SourceSmartsheetsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_access_token: Optional[pulumi.Input['SourceSmartsheetsConfigurationCredentialsApiAccessTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceSmartsheetsConfigurationCredentialsOAuth20Args']] = None):
        if api_access_token is not None:
            pulumi.set(__self__, "api_access_token", api_access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiAccessToken")
    def api_access_token(self) -> Optional[pulumi.Input['SourceSmartsheetsConfigurationCredentialsApiAccessTokenArgs']]:
        return pulumi.get(self, "api_access_token")

    @api_access_token.setter
    def api_access_token(self, value: Optional[pulumi.Input['SourceSmartsheetsConfigurationCredentialsApiAccessTokenArgs']]):
        pulumi.set(self, "api_access_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceSmartsheetsConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceSmartsheetsConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceSmartsheetsConfigurationCredentialsApiAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: The access token to use for accessing your data from Smartsheets. This access token must be generated by a user with at least read access to the data you'd like to replicate. Generate an access token in the Smartsheets main menu by clicking Account > Apps & Integrations > API Access. See the <a href="https://docs.airbyte.com/integrations/sources/smartsheets/#setup-guide">setup guide</a> for information on how to obtain this token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The access token to use for accessing your data from Smartsheets. This access token must be generated by a user with at least read access to the data you'd like to replicate. Generate an access token in the Smartsheets main menu by clicking Account > Apps & Integrations > API Access. See the <a href="https://docs.airbyte.com/integrations/sources/smartsheets/#setup-guide">setup guide</a> for information on how to obtain this token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceSmartsheetsConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 token_expiry_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The API ID of the SmartSheets developer application.
        :param pulumi.Input[str] client_secret: The API Secret the SmartSheets developer application.
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access_token.
        :param pulumi.Input[str] token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The API ID of the SmartSheets developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The API Secret the SmartSheets developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> pulumi.Input[str]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")

    @token_expiry_date.setter
    def token_expiry_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_expiry_date", value)


@pulumi.input_type
class SourceSnapchatMarketingConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 action_report_time: Optional[pulumi.Input[str]] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None,
                 swipe_up_attribution_window: Optional[pulumi.Input[str]] = None,
                 view_attribution_window: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Snapchat developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Snapchat developer application.
        :param pulumi.Input[str] refresh_token: Refresh Token to renew the expired Access Token.
        :param pulumi.Input[str] action_report_time: Specifies the principle for conversion reporting. must be one of ["conversion", "impression"]; Default: "conversion"
        :param pulumi.Input[str] end_date: Date in the format 2017-01-25. Any data after this date will not be replicated.
        :param pulumi.Input[str] start_date: Date in the format 2022-01-01. Any data before this date will not be replicated. Default: "2022-01-01"
        :param pulumi.Input[str] swipe_up_attribution_window: Attribution window for swipe ups. must be one of ["1_DAY", "7_DAY", "28_DAY"]; Default: "28_DAY"
        :param pulumi.Input[str] view_attribution_window: Attribution window for views. must be one of ["1_HOUR", "3_HOUR", "6_HOUR", "1_DAY", "7_DAY"]; Default: "1_DAY"
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if action_report_time is not None:
            pulumi.set(__self__, "action_report_time", action_report_time)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if swipe_up_attribution_window is not None:
            pulumi.set(__self__, "swipe_up_attribution_window", swipe_up_attribution_window)
        if view_attribution_window is not None:
            pulumi.set(__self__, "view_attribution_window", view_attribution_window)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Snapchat developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Snapchat developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="actionReportTime")
    def action_report_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the principle for conversion reporting. must be one of ["conversion", "impression"]; Default: "conversion"
        """
        return pulumi.get(self, "action_report_time")

    @action_report_time.setter
    def action_report_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_report_time", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        Date in the format 2017-01-25. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        Date in the format 2022-01-01. Any data before this date will not be replicated. Default: "2022-01-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="swipeUpAttributionWindow")
    def swipe_up_attribution_window(self) -> Optional[pulumi.Input[str]]:
        """
        Attribution window for swipe ups. must be one of ["1_DAY", "7_DAY", "28_DAY"]; Default: "28_DAY"
        """
        return pulumi.get(self, "swipe_up_attribution_window")

    @swipe_up_attribution_window.setter
    def swipe_up_attribution_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "swipe_up_attribution_window", value)

    @property
    @pulumi.getter(name="viewAttributionWindow")
    def view_attribution_window(self) -> Optional[pulumi.Input[str]]:
        """
        Attribution window for views. must be one of ["1_HOUR", "3_HOUR", "6_HOUR", "1_DAY", "7_DAY"]; Default: "1_DAY"
        """
        return pulumi.get(self, "view_attribution_window")

    @view_attribution_window.setter
    def view_attribution_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view_attribution_window", value)


@pulumi.input_type
class SourceSnowflakeConfigurationArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 host: pulumi.Input[str],
                 role: pulumi.Input[str],
                 warehouse: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsArgs']] = None,
                 jdbc_url_params: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database: The database you created for Airbyte to access data.
        :param pulumi.Input[str] host: The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
        :param pulumi.Input[str] role: The role you created for Airbyte to access Snowflake.
        :param pulumi.Input[str] warehouse: The warehouse you created for Airbyte to access data.
        :param pulumi.Input[str] jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param pulumi.Input[str] schema: The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "warehouse", warehouse)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The database you created for Airbyte to access data.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        The role you created for Airbyte to access Snowflake.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def warehouse(self) -> pulumi.Input[str]:
        """
        The warehouse you created for Airbyte to access data.
        """
        return pulumi.get(self, "warehouse")

    @warehouse.setter
    def warehouse(self, value: pulumi.Input[str]):
        pulumi.set(self, "warehouse", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[pulumi.Input[str]]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @jdbc_url_params.setter
    def jdbc_url_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jdbc_url_params", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)


@pulumi.input_type
class SourceSnowflakeConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth20: Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsOAuth20Args']] = None,
                 username_and_password: Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsUsernameAndPasswordArgs']] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if username_and_password is not None:
            pulumi.set(__self__, "username_and_password", username_and_password)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)

    @property
    @pulumi.getter(name="usernameAndPassword")
    def username_and_password(self) -> Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsUsernameAndPasswordArgs']]:
        return pulumi.get(self, "username_and_password")

    @username_and_password.setter
    def username_and_password(self, value: Optional[pulumi.Input['SourceSnowflakeConfigurationCredentialsUsernameAndPasswordArgs']]):
        pulumi.set(self, "username_and_password", value)


@pulumi.input_type
class SourceSnowflakeConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 access_token: Optional[pulumi.Input[str]] = None,
                 refresh_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your Snowflake developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Snowflake developer application.
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] refresh_token: Refresh Token for making authenticated requests.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Snowflake developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Snowflake developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[str]]:
        """
        Refresh Token for making authenticated requests.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceSnowflakeConfigurationCredentialsUsernameAndPasswordArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: The password associated with the username.
        :param pulumi.Input[str] username: The username you created to allow Airbyte to access the database.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The username you created to allow Airbyte to access the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class SourceSonarCloudConfigurationArgs:
    def __init__(__self__, *,
                 component_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 organization: pulumi.Input[str],
                 user_token: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] component_keys: Comma-separated list of component keys.
        :param pulumi.Input[str] organization: Organization key. See <a href="https://docs.sonarcloud.io/appendices/project-information/#project-and-organization-keys">here</a>.
        :param pulumi.Input[str] user_token: Your User Token. See <a href="https://docs.sonarcloud.io/advanced-setup/user-accounts/">here</a>. The token is case sensitive.
        :param pulumi.Input[str] end_date: To retrieve issues created before the given date (inclusive).
        :param pulumi.Input[str] start_date: To retrieve issues created after the given date (inclusive).
        """
        pulumi.set(__self__, "component_keys", component_keys)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "user_token", user_token)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="componentKeys")
    def component_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Comma-separated list of component keys.
        """
        return pulumi.get(self, "component_keys")

    @component_keys.setter
    def component_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "component_keys", value)

    @property
    @pulumi.getter
    def organization(self) -> pulumi.Input[str]:
        """
        Organization key. See <a href="https://docs.sonarcloud.io/appendices/project-information/#project-and-organization-keys">here</a>.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[str]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="userToken")
    def user_token(self) -> pulumi.Input[str]:
        """
        Your User Token. See <a href="https://docs.sonarcloud.io/advanced-setup/user-accounts/">here</a>. The token is case sensitive.
        """
        return pulumi.get(self, "user_token")

    @user_token.setter
    def user_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_token", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        To retrieve issues created before the given date (inclusive).
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        To retrieve issues created after the given date (inclusive).
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSpacexApiConfigurationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)


@pulumi.input_type
class SourceSquareConfigurationArgs:
    def __init__(__self__, *,
                 credentials: Optional[pulumi.Input['SourceSquareConfigurationCredentialsArgs']] = None,
                 include_deleted_objects: Optional[pulumi.Input[bool]] = None,
                 is_sandbox: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SourceSquareConfigurationCredentialsArgs'] credentials: Choose how to authenticate to Square.
        :param pulumi.Input[bool] include_deleted_objects: In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes). Default: false
        :param pulumi.Input[bool] is_sandbox: Determines whether to use the sandbox or production environment. Default: false
        :param pulumi.Input[str] start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated. Default: "2021-01-01"
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if include_deleted_objects is not None:
            pulumi.set(__self__, "include_deleted_objects", include_deleted_objects)
        if is_sandbox is not None:
            pulumi.set(__self__, "is_sandbox", is_sandbox)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceSquareConfigurationCredentialsArgs']]:
        """
        Choose how to authenticate to Square.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceSquareConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="includeDeletedObjects")
    def include_deleted_objects(self) -> Optional[pulumi.Input[bool]]:
        """
        In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes). Default: false
        """
        return pulumi.get(self, "include_deleted_objects")

    @include_deleted_objects.setter
    def include_deleted_objects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_deleted_objects", value)

    @property
    @pulumi.getter(name="isSandbox")
    def is_sandbox(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to use the sandbox or production environment. Default: false
        """
        return pulumi.get(self, "is_sandbox")

    @is_sandbox.setter
    def is_sandbox(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_sandbox", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated. Default: "2021-01-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSquareConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['SourceSquareConfigurationCredentialsApiKeyArgs']] = None,
                 oauth_authentication: Optional[pulumi.Input['SourceSquareConfigurationCredentialsOauthAuthenticationArgs']] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if oauth_authentication is not None:
            pulumi.set(__self__, "oauth_authentication", oauth_authentication)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['SourceSquareConfigurationCredentialsApiKeyArgs']]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['SourceSquareConfigurationCredentialsApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="oauthAuthentication")
    def oauth_authentication(self) -> Optional[pulumi.Input['SourceSquareConfigurationCredentialsOauthAuthenticationArgs']]:
        return pulumi.get(self, "oauth_authentication")

    @oauth_authentication.setter
    def oauth_authentication(self, value: Optional[pulumi.Input['SourceSquareConfigurationCredentialsOauthAuthenticationArgs']]):
        pulumi.set(self, "oauth_authentication", value)


@pulumi.input_type
class SourceSquareConfigurationCredentialsApiKeyArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: The API key for a Square application
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The API key for a Square application
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)


@pulumi.input_type
class SourceSquareConfigurationCredentialsOauthAuthenticationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The Square-issued ID of your application
        :param pulumi.Input[str] client_secret: The Square-issued application secret for your application
        :param pulumi.Input[str] refresh_token: A refresh token generated using the above client ID and secret
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Square-issued ID of your application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Square-issued application secret for your application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        A refresh token generated using the above client ID and secret
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceStravaConfigurationArgs:
    def __init__(__self__, *,
                 athlete_id: pulumi.Input[int],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[int] athlete_id: The Athlete ID of your Strava developer application.
        :param pulumi.Input[str] client_id: The Client ID of your Strava developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of your Strava developer application.
        :param pulumi.Input[str] refresh_token: The Refresh Token with the activity: read_all permissions.
        :param pulumi.Input[str] start_date: UTC date and time. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "athlete_id", athlete_id)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="athleteId")
    def athlete_id(self) -> pulumi.Input[int]:
        """
        The Athlete ID of your Strava developer application.
        """
        return pulumi.get(self, "athlete_id")

    @athlete_id.setter
    def athlete_id(self, value: pulumi.Input[int]):
        pulumi.set(self, "athlete_id", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your Strava developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your Strava developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The Refresh Token with the activity: read_all permissions.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceStripeConfigurationArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 call_rate_limit: Optional[pulumi.Input[int]] = None,
                 lookback_window_days: Optional[pulumi.Input[int]] = None,
                 num_workers: Optional[pulumi.Input[int]] = None,
                 slice_range: Optional[pulumi.Input[int]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_id: Your Stripe account ID (starts with 'acct_', find yours <a href="https://dashboard.stripe.com/settings/account">here</a>).
        :param pulumi.Input[str] client_secret: Stripe API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.stripe.com/apikeys">here</a>).
        :param pulumi.Input[int] call_rate_limit: The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
        :param pulumi.Input[int] lookback_window_days: When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info <a href="https://docs.airbyte.com/integrations/sources/stripe#requirements">here</a>. Default: 0
        :param pulumi.Input[int] num_workers: The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account. Default: 10
        :param pulumi.Input[int] slice_range: The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted. Default: 365
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated. Default: "2017-01-25T00:00:00Z"
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if call_rate_limit is not None:
            pulumi.set(__self__, "call_rate_limit", call_rate_limit)
        if lookback_window_days is not None:
            pulumi.set(__self__, "lookback_window_days", lookback_window_days)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if slice_range is not None:
            pulumi.set(__self__, "slice_range", slice_range)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        Your Stripe account ID (starts with 'acct_', find yours <a href="https://dashboard.stripe.com/settings/account">here</a>).
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Stripe API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.stripe.com/apikeys">here</a>).
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="callRateLimit")
    def call_rate_limit(self) -> Optional[pulumi.Input[int]]:
        """
        The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
        """
        return pulumi.get(self, "call_rate_limit")

    @call_rate_limit.setter
    def call_rate_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "call_rate_limit", value)

    @property
    @pulumi.getter(name="lookbackWindowDays")
    def lookback_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info <a href="https://docs.airbyte.com/integrations/sources/stripe#requirements">here</a>. Default: 0
        """
        return pulumi.get(self, "lookback_window_days")

    @lookback_window_days.setter
    def lookback_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window_days", value)

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[pulumi.Input[int]]:
        """
        The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account. Default: 10
        """
        return pulumi.get(self, "num_workers")

    @num_workers.setter
    def num_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_workers", value)

    @property
    @pulumi.getter(name="sliceRange")
    def slice_range(self) -> Optional[pulumi.Input[int]]:
        """
        The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted. Default: 365
        """
        return pulumi.get(self, "slice_range")

    @slice_range.setter
    def slice_range(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slice_range", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated. Default: "2017-01-25T00:00:00Z"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceSurveySparrowConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 region: Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionArgs']] = None,
                 survey_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] access_token: Your access token. See <a href="https://developers.surveysparrow.com/rest-apis#authentication">here</a>. The key is case sensitive.
        :param pulumi.Input['SourceSurveySparrowConfigurationRegionArgs'] region: Is your account location is EU based? If yes, the base url to retrieve data will be different.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] survey_ids: A List of your survey ids for survey-specific stream
        """
        pulumi.set(__self__, "access_token", access_token)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if survey_ids is not None:
            pulumi.set(__self__, "survey_ids", survey_ids)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Your access token. See <a href="https://developers.surveysparrow.com/rest-apis#authentication">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionArgs']]:
        """
        Is your account location is EU based? If yes, the base url to retrieve data will be different.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionArgs']]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="surveyIds")
    def survey_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A List of your survey ids for survey-specific stream
        """
        return pulumi.get(self, "survey_ids")

    @survey_ids.setter
    def survey_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "survey_ids", value)


@pulumi.input_type
class SourceSurveySparrowConfigurationRegionArgs:
    def __init__(__self__, *,
                 eu_based_account: Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionEuBasedAccountArgs']] = None,
                 global_account: Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionGlobalAccountArgs']] = None):
        if eu_based_account is not None:
            pulumi.set(__self__, "eu_based_account", eu_based_account)
        if global_account is not None:
            pulumi.set(__self__, "global_account", global_account)

    @property
    @pulumi.getter(name="euBasedAccount")
    def eu_based_account(self) -> Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionEuBasedAccountArgs']]:
        return pulumi.get(self, "eu_based_account")

    @eu_based_account.setter
    def eu_based_account(self, value: Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionEuBasedAccountArgs']]):
        pulumi.set(self, "eu_based_account", value)

    @property
    @pulumi.getter(name="globalAccount")
    def global_account(self) -> Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionGlobalAccountArgs']]:
        return pulumi.get(self, "global_account")

    @global_account.setter
    def global_account(self, value: Optional[pulumi.Input['SourceSurveySparrowConfigurationRegionGlobalAccountArgs']]):
        pulumi.set(self, "global_account", value)


@pulumi.input_type
class SourceSurveySparrowConfigurationRegionEuBasedAccountArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceSurveySparrowConfigurationRegionGlobalAccountArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceSurveymonkeyConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceSurveymonkeyConfigurationCredentialsArgs'],
                 start_date: pulumi.Input[str],
                 origin: Optional[pulumi.Input[str]] = None,
                 survey_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['SourceSurveymonkeyConfigurationCredentialsArgs'] credentials: The authorization method to use to retrieve data from SurveyMonkey
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[str] origin: Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different. must be one of ["USA", "Europe", "Canada"]; Default: "USA"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] survey_ids: IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if survey_ids is not None:
            pulumi.set(__self__, "survey_ids", survey_ids)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceSurveymonkeyConfigurationCredentialsArgs']:
        """
        The authorization method to use to retrieve data from SurveyMonkey
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceSurveymonkeyConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[str]]:
        """
        Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different. must be one of ["USA", "Europe", "Canada"]; Default: "USA"
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter(name="surveyIds")
    def survey_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
        """
        return pulumi.get(self, "survey_ids")

    @survey_ids.setter
    def survey_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "survey_ids", value)


@pulumi.input_type
class SourceSurveymonkeyConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests. See the <a href="https://docs.airbyte.io/integrations/sources/surveymonkey">docs</a> for information on how to generate this key.
        :param pulumi.Input[str] client_id: The Client ID of the SurveyMonkey developer application.
        :param pulumi.Input[str] client_secret: The Client Secret of the SurveyMonkey developer application.
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests. See the <a href="https://docs.airbyte.io/integrations/sources/surveymonkey">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of the SurveyMonkey developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of the SurveyMonkey developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceTempoConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)


@pulumi.input_type
class SourceTheGuardianApiConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 section: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Your API Key. See <a href="https://open-platform.theguardian.com/access/">here</a>. The key is case sensitive.
        :param pulumi.Input[str] start_date: Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the start_date will not be shown.
        :param pulumi.Input[str] end_date: (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the end_date will not be shown. Default is set to the current date (today) for incremental syncs.
        :param pulumi.Input[str] query: (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
        :param pulumi.Input[str] section: (Optional) Use this to filter the results by a particular section. See <a href="https://content.guardianapis.com/sections?api-key=test">here</a> for a list of all sections, and <a href="https://open-platform.theguardian.com/documentation/section">here</a> for the sections endpoint documentation.
        :param pulumi.Input[str] tag: (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See <a href="https://content.guardianapis.com/tags?api-key=test">here</a> for a list of all tags, and <a href="https://open-platform.theguardian.com/documentation/tag">here</a> for the tags endpoint documentation.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if section is not None:
            pulumi.set(__self__, "section", section)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API Key. See <a href="https://open-platform.theguardian.com/access/">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the start_date will not be shown.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the end_date will not be shown. Default is set to the current date (today) for incremental syncs.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def section(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Use this to filter the results by a particular section. See <a href="https://content.guardianapis.com/sections?api-key=test">here</a> for a list of all sections, and <a href="https://open-platform.theguardian.com/documentation/section">here</a> for the sections endpoint documentation.
        """
        return pulumi.get(self, "section")

    @section.setter
    def section(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "section", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See <a href="https://content.guardianapis.com/tags?api-key=test">here</a> for a list of all tags, and <a href="https://open-platform.theguardian.com/documentation/tag">here</a> for the tags endpoint documentation.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class SourceTiktokMarketingConfigurationArgs:
    def __init__(__self__, *,
                 attribution_window: Optional[pulumi.Input[int]] = None,
                 credentials: Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsArgs']] = None,
                 end_date: Optional[pulumi.Input[str]] = None,
                 include_deleted: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] attribution_window: The attribution window in days. Default: 3
        :param pulumi.Input['SourceTiktokMarketingConfigurationCredentialsArgs'] credentials: Authentication method
        :param pulumi.Input[str] end_date: The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between start_date and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
        :param pulumi.Input[bool] include_deleted: Set to active if you want to include deleted data in reports. Default: false
        :param pulumi.Input[str] start_date: The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated. Default: "2016-09-01"
        """
        if attribution_window is not None:
            pulumi.set(__self__, "attribution_window", attribution_window)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if include_deleted is not None:
            pulumi.set(__self__, "include_deleted", include_deleted)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="attributionWindow")
    def attribution_window(self) -> Optional[pulumi.Input[int]]:
        """
        The attribution window in days. Default: 3
        """
        return pulumi.get(self, "attribution_window")

    @attribution_window.setter
    def attribution_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "attribution_window", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsArgs']]:
        """
        Authentication method
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between start_date and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="includeDeleted")
    def include_deleted(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to active if you want to include deleted data in reports. Default: false
        """
        return pulumi.get(self, "include_deleted")

    @include_deleted.setter
    def include_deleted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_deleted", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated. Default: "2016-09-01"
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceTiktokMarketingConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth20: Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsOAuth20Args']] = None,
                 sandbox_access_token: Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsSandboxAccessTokenArgs']] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if sandbox_access_token is not None:
            pulumi.set(__self__, "sandbox_access_token", sandbox_access_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)

    @property
    @pulumi.getter(name="sandboxAccessToken")
    def sandbox_access_token(self) -> Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsSandboxAccessTokenArgs']]:
        return pulumi.get(self, "sandbox_access_token")

    @sandbox_access_token.setter
    def sandbox_access_token(self, value: Optional[pulumi.Input['SourceTiktokMarketingConfigurationCredentialsSandboxAccessTokenArgs']]):
        pulumi.set(self, "sandbox_access_token", value)


@pulumi.input_type
class SourceTiktokMarketingConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 app_id: pulumi.Input[str],
                 secret: pulumi.Input[str],
                 advertiser_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Long-term Authorized Access Token.
        :param pulumi.Input[str] app_id: The Developer Application App ID.
        :param pulumi.Input[str] secret: The Developer Application Secret.
        :param pulumi.Input[str] advertiser_id: The Advertiser ID to filter reports and streams. Let this empty to retrieve all.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "secret", secret)
        if advertiser_id is not None:
            pulumi.set(__self__, "advertiser_id", advertiser_id)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Long-term Authorized Access Token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> pulumi.Input[str]:
        """
        The Developer Application App ID.
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter
    def secret(self) -> pulumi.Input[str]:
        """
        The Developer Application Secret.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="advertiserId")
    def advertiser_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Advertiser ID to filter reports and streams. Let this empty to retrieve all.
        """
        return pulumi.get(self, "advertiser_id")

    @advertiser_id.setter
    def advertiser_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "advertiser_id", value)


@pulumi.input_type
class SourceTiktokMarketingConfigurationCredentialsSandboxAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 advertiser_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: The long-term authorized access token.
        :param pulumi.Input[str] advertiser_id: The Advertiser ID which generated for the developer's Sandbox application.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "advertiser_id", advertiser_id)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The long-term authorized access token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="advertiserId")
    def advertiser_id(self) -> pulumi.Input[str]:
        """
        The Advertiser ID which generated for the developer's Sandbox application.
        """
        return pulumi.get(self, "advertiser_id")

    @advertiser_id.setter
    def advertiser_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "advertiser_id", value)


@pulumi.input_type
class SourceTrelloConfigurationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 token: pulumi.Input[str],
                 board_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Trello API key. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[str] token: Trello API token. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] board_ids: IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated. Please note that this is not the 8-character ID in the board's shortLink (URL of the board). Rather, what is required here is the 24-character ID usually returned by the API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)
        if board_ids is not None:
            pulumi.set(__self__, "board_ids", board_ids)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Trello API key. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Trello API token. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="boardIds")
    def board_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated. Please note that this is not the 8-character ID in the board's shortLink (URL of the board). Rather, what is required here is the 24-character ID usually returned by the API
        """
        return pulumi.get(self, "board_ids")

    @board_ids.setter
    def board_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "board_ids", value)


@pulumi.input_type
class SourceTrustpilotConfigurationArgs:
    def __init__(__self__, *,
                 business_units: pulumi.Input[Sequence[pulumi.Input[str]]],
                 credentials: pulumi.Input['SourceTrustpilotConfigurationCredentialsArgs'],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] business_units: The names of business units which shall be synchronized. Some streams e.g. configured_business_units or private_reviews use this configuration.
        :param pulumi.Input[str] start_date: For streams with sync. method incremental the start date time to be used
        """
        pulumi.set(__self__, "business_units", business_units)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="businessUnits")
    def business_units(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The names of business units which shall be synchronized. Some streams e.g. configured_business_units or private_reviews use this configuration.
        """
        return pulumi.get(self, "business_units")

    @business_units.setter
    def business_units(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "business_units", value)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceTrustpilotConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceTrustpilotConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        For streams with sync. method incremental the start date time to be used
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceTrustpilotConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input['SourceTrustpilotConfigurationCredentialsApiKeyArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceTrustpilotConfigurationCredentialsOAuth20Args']] = None):
        """
        :param pulumi.Input['SourceTrustpilotConfigurationCredentialsApiKeyArgs'] api_key: The API key authentication method gives you access to only the streams which are part of the Public API. When you want to get streams available via the Consumer API (e.g. the private reviews) you need to use authentication method OAuth 2.0.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input['SourceTrustpilotConfigurationCredentialsApiKeyArgs']]:
        """
        The API key authentication method gives you access to only the streams which are part of the Public API. When you want to get streams available via the Consumer API (e.g. the private reviews) you need to use authentication method OAuth 2.0.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input['SourceTrustpilotConfigurationCredentialsApiKeyArgs']]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceTrustpilotConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceTrustpilotConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceTrustpilotConfigurationCredentialsApiKeyArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] client_id: The API key of the Trustpilot API application.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The API key of the Trustpilot API application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)


@pulumi.input_type
class SourceTrustpilotConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 token_expiry_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The API key of the Trustpilot API application. (represents the OAuth Client ID)
        :param pulumi.Input[str] client_secret: The Secret of the Trustpilot API application. (represents the OAuth Client Secret)
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access_token.
        :param pulumi.Input[str] token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The API key of the Trustpilot API application. (represents the OAuth Client ID)
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Secret of the Trustpilot API application. (represents the OAuth Client Secret)
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> pulumi.Input[str]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")

    @token_expiry_date.setter
    def token_expiry_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_expiry_date", value)


@pulumi.input_type
class SourceTvmazeScheduleConfigurationArgs:
    def __init__(__self__, *,
                 domestic_schedule_country_code: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 web_schedule_country_code: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domestic_schedule_country_code: Country code for domestic TV schedule retrieval.
        :param pulumi.Input[str] start_date: Start date for TV schedule retrieval. May be in the future.
        :param pulumi.Input[str] end_date: End date for TV schedule retrieval. May be in the future. Optional.
        :param pulumi.Input[str] web_schedule_country_code: ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
               all countries plus global web channels (e.g. Netflix). Alternatively,
               set to 'global' for just global web channels.
        """
        pulumi.set(__self__, "domestic_schedule_country_code", domestic_schedule_country_code)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if web_schedule_country_code is not None:
            pulumi.set(__self__, "web_schedule_country_code", web_schedule_country_code)

    @property
    @pulumi.getter(name="domesticScheduleCountryCode")
    def domestic_schedule_country_code(self) -> pulumi.Input[str]:
        """
        Country code for domestic TV schedule retrieval.
        """
        return pulumi.get(self, "domestic_schedule_country_code")

    @domestic_schedule_country_code.setter
    def domestic_schedule_country_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "domestic_schedule_country_code", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Start date for TV schedule retrieval. May be in the future.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        End date for TV schedule retrieval. May be in the future. Optional.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="webScheduleCountryCode")
    def web_schedule_country_code(self) -> Optional[pulumi.Input[str]]:
        """
        ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
        all countries plus global web channels (e.g. Netflix). Alternatively,
        set to 'global' for just global web channels.
        """
        return pulumi.get(self, "web_schedule_country_code")

    @web_schedule_country_code.setter
    def web_schedule_country_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "web_schedule_country_code", value)


@pulumi.input_type
class SourceTwilioConfigurationArgs:
    def __init__(__self__, *,
                 account_sid: pulumi.Input[str],
                 auth_token: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 lookback_window: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] account_sid: Twilio account SID
        :param pulumi.Input[str] auth_token: Twilio Auth Token.
        :param pulumi.Input[str] start_date: UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
        :param pulumi.Input[int] lookback_window: How far into the past to look for records. (in minutes). Default: 0
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "start_date", start_date)
        if lookback_window is not None:
            pulumi.set(__self__, "lookback_window", lookback_window)

    @property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> pulumi.Input[str]:
        """
        Twilio account SID
        """
        return pulumi.get(self, "account_sid")

    @account_sid.setter
    def account_sid(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_sid", value)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[str]:
        """
        Twilio Auth Token.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional[pulumi.Input[int]]:
        """
        How far into the past to look for records. (in minutes). Default: 0
        """
        return pulumi.get(self, "lookback_window")

    @lookback_window.setter
    def lookback_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lookback_window", value)


@pulumi.input_type
class SourceTwilioTaskrouterConfigurationArgs:
    def __init__(__self__, *,
                 account_sid: pulumi.Input[str],
                 auth_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] account_sid: Twilio Account ID
        :param pulumi.Input[str] auth_token: Twilio Auth Token
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "auth_token", auth_token)

    @property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> pulumi.Input[str]:
        """
        Twilio Account ID
        """
        return pulumi.get(self, "account_sid")

    @account_sid.setter
    def account_sid(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_sid", value)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[str]:
        """
        Twilio Auth Token
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_token", value)


@pulumi.input_type
class SourceTwitterConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 query: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: App only Bearer Token. See the <a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens">docs</a> for more information on how to obtain this token.
        :param pulumi.Input[str] query: Query for matching Tweets. You can learn how to build this query by reading <a href="https://developer.twitter.com/en/docs/twitter-api/tweets/search/integrate/build-a-query"> build a query guide </a>.
        :param pulumi.Input[str] end_date: The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
        :param pulumi.Input[str] start_date: The start date for retrieving tweets cannot be more than 7 days in the past.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query", query)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        App only Bearer Token. See the <a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens">docs</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query for matching Tweets. You can learn how to build this query by reading <a href="https://developer.twitter.com/en/docs/twitter-api/tweets/search/integrate/build-a-query"> build a query guide </a>.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The start date for retrieving tweets cannot be more than 7 days in the past.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceTypeformConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceTypeformConfigurationCredentialsArgs'],
                 form_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] form_ids: When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the form_id is u6nXL7. You can find form URLs on Share panel
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        if form_ids is not None:
            pulumi.set(__self__, "form_ids", form_ids)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceTypeformConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceTypeformConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="formIds")
    def form_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the form_id is u6nXL7. You can find form URLs on Share panel
        """
        return pulumi.get(self, "form_ids")

    @form_ids.setter
    def form_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "form_ids", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceTypeformConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 o_auth20: Optional[pulumi.Input['SourceTypeformConfigurationCredentialsOAuth20Args']] = None,
                 private_token: Optional[pulumi.Input['SourceTypeformConfigurationCredentialsPrivateTokenArgs']] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if private_token is not None:
            pulumi.set(__self__, "private_token", private_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceTypeformConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceTypeformConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)

    @property
    @pulumi.getter(name="privateToken")
    def private_token(self) -> Optional[pulumi.Input['SourceTypeformConfigurationCredentialsPrivateTokenArgs']]:
        return pulumi.get(self, "private_token")

    @private_token.setter
    def private_token(self, value: Optional[pulumi.Input['SourceTypeformConfigurationCredentialsPrivateTokenArgs']]):
        pulumi.set(self, "private_token", value)


@pulumi.input_type
class SourceTypeformConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 token_expiry_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The Client ID of the Typeform developer application.
        :param pulumi.Input[str] client_secret: The Client Secret the Typeform developer application.
        :param pulumi.Input[str] refresh_token: The key to refresh the expired access_token.
        :param pulumi.Input[str] token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of the Typeform developer application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret the Typeform developer application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> pulumi.Input[str]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")

    @token_expiry_date.setter
    def token_expiry_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "token_expiry_date", value)


@pulumi.input_type
class SourceTypeformConfigurationCredentialsPrivateTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Log into your Typeform account and then generate a personal Access Token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Log into your Typeform account and then generate a personal Access Token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceUsCensusConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 query_path: pulumi.Input[str],
                 query_params: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Your API Key. Get your key <a href="https://api.census.gov/data/key_signup.html">here</a>.
        :param pulumi.Input[str] query_path: The path portion of the GET request
        :param pulumi.Input[str] query_params: The query parameters portion of the GET request, without the api key
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query_path", query_path)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Your API Key. Get your key <a href="https://api.census.gov/data/key_signup.html">here</a>.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="queryPath")
    def query_path(self) -> pulumi.Input[str]:
        """
        The path portion of the GET request
        """
        return pulumi.get(self, "query_path")

    @query_path.setter
    def query_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_path", value)

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[pulumi.Input[str]]:
        """
        The query parameters portion of the GET request, without the api key
        """
        return pulumi.get(self, "query_params")

    @query_params.setter
    def query_params(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_params", value)


@pulumi.input_type
class SourceVantageConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Your API Access token. See <a href="https://vantage.readme.io/reference/authentication">here</a>.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Your API Access token. See <a href="https://vantage.readme.io/reference/authentication">here</a>.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceWebflowConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 site_id: pulumi.Input[str],
                 accept_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
        :param pulumi.Input[str] site_id: The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
        :param pulumi.Input[str] accept_version: The version of the Webflow API to use. See https://developers.webflow.com/#versioning
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "site_id", site_id)
        if accept_version is not None:
            pulumi.set(__self__, "accept_version", accept_version)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> pulumi.Input[str]:
        """
        The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
        """
        return pulumi.get(self, "site_id")

    @site_id.setter
    def site_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "site_id", value)

    @property
    @pulumi.getter(name="acceptVersion")
    def accept_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the Webflow API to use. See https://developers.webflow.com/#versioning
        """
        return pulumi.get(self, "accept_version")

    @accept_version.setter
    def accept_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "accept_version", value)


@pulumi.input_type
class SourceWhiskyHunterConfigurationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceWikipediaPageviewsConfigurationArgs:
    def __init__(__self__, *,
                 access: pulumi.Input[str],
                 agent: pulumi.Input[str],
                 article: pulumi.Input[str],
                 country: pulumi.Input[str],
                 end: pulumi.Input[str],
                 project: pulumi.Input[str],
                 start: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access: If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
        :param pulumi.Input[str] agent: If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
        :param pulumi.Input[str] article: The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
        :param pulumi.Input[str] country: The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
        :param pulumi.Input[str] end: The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
        :param pulumi.Input[str] project: If you want to filter by project, use the domain of any Wikimedia project.
        :param pulumi.Input[str] start: The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "agent", agent)
        pulumi.set(__self__, "article", article)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def access(self) -> pulumi.Input[str]:
        """
        If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: pulumi.Input[str]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def agent(self) -> pulumi.Input[str]:
        """
        If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[str]):
        pulumi.set(self, "agent", value)

    @property
    @pulumi.getter
    def article(self) -> pulumi.Input[str]:
        """
        The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
        """
        return pulumi.get(self, "article")

    @article.setter
    def article(self, value: pulumi.Input[str]):
        pulumi.set(self, "article", value)

    @property
    @pulumi.getter
    def country(self) -> pulumi.Input[str]:
        """
        The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: pulumi.Input[str]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[str]:
        """
        The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[str]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def project(self) -> pulumi.Input[str]:
        """
        If you want to filter by project, use the domain of any Wikimedia project.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[str]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)


@pulumi.input_type
class SourceWoocommerceConfigurationArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 api_secret: pulumi.Input[str],
                 shop: pulumi.Input[str],
                 start_date: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_key: Customer Key for API in WooCommerce shop
        :param pulumi.Input[str] api_secret: Customer Secret for API in WooCommerce shop
        :param pulumi.Input[str] shop: The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
        :param pulumi.Input[str] start_date: The date you would like to replicate data from. Format: YYYY-MM-DD
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "shop", shop)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Customer Key for API in WooCommerce shop
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> pulumi.Input[str]:
        """
        Customer Secret for API in WooCommerce shop
        """
        return pulumi.get(self, "api_secret")

    @api_secret.setter
    def api_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_secret", value)

    @property
    @pulumi.getter
    def shop(self) -> pulumi.Input[str]:
        """
        The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
        """
        return pulumi.get(self, "shop")

    @shop.setter
    def shop(self, value: pulumi.Input[str]):
        pulumi.set(self, "shop", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date you would like to replicate data from. Format: YYYY-MM-DD
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceXkcdConfigurationArgs:
    def __init__(__self__):
        pass


@pulumi.input_type
class SourceYandexMetricaConfigurationArgs:
    def __init__(__self__, *,
                 auth_token: pulumi.Input[str],
                 counter_id: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 end_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_token: Your Yandex Metrica API access token
        :param pulumi.Input[str] counter_id: Counter ID
        :param pulumi.Input[str] start_date: Starting point for your data replication, in format of "YYYY-MM-DD".
        :param pulumi.Input[str] end_date: Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "counter_id", counter_id)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> pulumi.Input[str]:
        """
        Your Yandex Metrica API access token
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter(name="counterId")
    def counter_id(self) -> pulumi.Input[str]:
        """
        Counter ID
        """
        return pulumi.get(self, "counter_id")

    @counter_id.setter
    def counter_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "counter_id", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Starting point for your data replication, in format of "YYYY-MM-DD".
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input[str]]:
        """
        Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_date", value)


@pulumi.input_type
class SourceYotpoConfigurationArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 app_key: pulumi.Input[str],
                 start_date: pulumi.Input[str],
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
        :param pulumi.Input[str] app_key: App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
        :param pulumi.Input[str] start_date: Date time filter for incremental filter, Specify which date to extract from.
        :param pulumi.Input[str] email: Email address registered with yotpo. Default: "example@gmail.com"
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "app_key", app_key)
        pulumi.set(__self__, "start_date", start_date)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="appKey")
    def app_key(self) -> pulumi.Input[str]:
        """
        App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
        """
        return pulumi.get(self, "app_key")

    @app_key.setter
    def app_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_key", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Date time filter for incremental filter, Specify which date to extract from.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        Email address registered with yotpo. Default: "example@gmail.com"
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class SourceYoutubeAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input['SourceYoutubeAnalyticsConfigurationCredentialsArgs']):
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['SourceYoutubeAnalyticsConfigurationCredentialsArgs']:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['SourceYoutubeAnalyticsConfigurationCredentialsArgs']):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceYoutubeAnalyticsConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: The Client ID of your developer application
        :param pulumi.Input[str] client_secret: The client secret of your developer application
        :param pulumi.Input[str] refresh_token: A refresh token generated using the above client ID and secret
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your developer application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret of your developer application
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        A refresh token generated using the above client ID and secret
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceZendeskChatConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsArgs']] = None,
                 subdomain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
        :param pulumi.Input[str] subdomain: Required if you access Zendesk Chat from a Zendesk Support subdomain. Default: ""
        """
        pulumi.set(__self__, "start_date", start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[pulumi.Input[str]]:
        """
        Required if you access Zendesk Chat from a Zendesk Support subdomain. Default: ""
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subdomain", value)


@pulumi.input_type
class SourceZendeskChatConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsAccessTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsOAuth20Args']] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsAccessTokenArgs']]:
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsAccessTokenArgs']]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceZendeskChatConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceZendeskChatConfigurationCredentialsAccessTokenArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: The Access Token to make authenticated requests.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The Access Token to make authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


@pulumi.input_type
class SourceZendeskChatConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 refresh_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The Client ID of your OAuth application
        :param pulumi.Input[str] client_secret: The Client Secret of your OAuth application.
        :param pulumi.Input[str] refresh_token: Refresh Token to obtain new Access Token, when it's expired.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Client ID of your OAuth application
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[str]]:
        """
        Refresh Token to obtain new Access Token, when it's expired.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class SourceZendeskSellConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: The API token for authenticating to Zendesk Sell
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The API token for authenticating to Zendesk Sell
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)


@pulumi.input_type
class SourceZendeskSunshineConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 subdomain: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
        :param pulumi.Input[str] subdomain: The subdomain for your Zendesk Account.
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "subdomain", subdomain)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[str]:
        """
        The subdomain for your Zendesk Account.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "subdomain", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsArgs']]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceZendeskSunshineConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsApiTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsOAuth20Args']] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsApiTokenArgs']]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceZendeskSunshineConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceZendeskSunshineConfigurationCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 email: pulumi.Input[str]):
        """
        :param pulumi.Input[str] api_token: API Token. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk_sunshine">docs</a> for information on how to generate this key.
        :param pulumi.Input[str] email: The user email for your Zendesk account
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        API Token. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk_sunshine">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The user email for your Zendesk account
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class SourceZendeskSunshineConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Long-term access Token for making authenticated requests.
        :param pulumi.Input[str] client_id: The Client ID of your OAuth application.
        :param pulumi.Input[str] client_secret: The Client Secret of your OAuth application.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Long-term access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceZendeskSupportConfigurationArgs:
    def __init__(__self__, *,
                 subdomain: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsArgs']] = None,
                 ignore_pagination: Optional[pulumi.Input[bool]] = None,
                 start_date: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subdomain: This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY_SUBDOMAIN.zendesk.com/, MY_SUBDOMAIN is the value of your subdomain.
        :param pulumi.Input['SourceZendeskSupportConfigurationCredentialsArgs'] credentials: Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
        :param pulumi.Input[bool] ignore_pagination: Makes each stream read a single page of data. Default: false
        :param pulumi.Input[str] start_date: The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "subdomain", subdomain)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if ignore_pagination is not None:
            pulumi.set(__self__, "ignore_pagination", ignore_pagination)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[str]:
        """
        This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY_SUBDOMAIN.zendesk.com/, MY_SUBDOMAIN is the value of your subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "subdomain", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsArgs']]:
        """
        Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="ignorePagination")
    def ignore_pagination(self) -> Optional[pulumi.Input[bool]]:
        """
        Makes each stream read a single page of data. Default: false
        """
        return pulumi.get(self, "ignore_pagination")

    @ignore_pagination.setter
    def ignore_pagination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_pagination", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[pulumi.Input[str]]:
        """
        The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_date", value)


@pulumi.input_type
class SourceZendeskSupportConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsApiTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsOAuth20Args']] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsApiTokenArgs']]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceZendeskSupportConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceZendeskSupportConfigurationCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 email: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: The value of the API token generated. See our <a href="https://docs.airbyte.com/integrations/sources/zendesk-support#setup-guide">full documentation</a> for more information on generating this token.
        :param pulumi.Input[str] email: The user email for your Zendesk account.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "email", email)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The value of the API token generated. See our <a href="https://docs.airbyte.com/integrations/sources/zendesk-support#setup-guide">full documentation</a> for more information on generating this token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The user email for your Zendesk account.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceZendeskSupportConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The OAuth access token. See the <a href="https://developer.zendesk.com/documentation/ticketing/working-with-oauth/creating-and-using-oauth-tokens-with-the-api/">Zendesk docs</a> for more information on generating this token.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] client_id: The OAuth client's ID. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        :param pulumi.Input[str] client_secret: The OAuth client secret. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        """
        pulumi.set(__self__, "access_token", access_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The OAuth access token. See the <a href="https://developer.zendesk.com/documentation/ticketing/working-with-oauth/creating-and-using-oauth-tokens-with-the-api/">Zendesk docs</a> for more information on generating this token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth client's ID. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The OAuth client secret. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceZendeskTalkConfigurationArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input[str],
                 subdomain: pulumi.Input[str],
                 credentials: Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsArgs']] = None):
        """
        :param pulumi.Input[str] start_date: The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        :param pulumi.Input[str] subdomain: This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY_SUBDOMAIN}.zendesk.com/, where MY_SUBDOMAIN is the value of your subdomain.
        :param pulumi.Input['SourceZendeskTalkConfigurationCredentialsArgs'] credentials: Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "subdomain", subdomain)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter
    def subdomain(self) -> pulumi.Input[str]:
        """
        This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY_SUBDOMAIN}.zendesk.com/, where MY_SUBDOMAIN is the value of your subdomain.
        """
        return pulumi.get(self, "subdomain")

    @subdomain.setter
    def subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "subdomain", value)

    @property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsArgs']]:
        """
        Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsArgs']]):
        pulumi.set(self, "credentials", value)


@pulumi.input_type
class SourceZendeskTalkConfigurationCredentialsArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsApiTokenArgs']] = None,
                 o_auth20: Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsOAuth20Args']] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsApiTokenArgs']]:
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsApiTokenArgs']]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsOAuth20Args']]:
        return pulumi.get(self, "o_auth20")

    @o_auth20.setter
    def o_auth20(self, value: Optional[pulumi.Input['SourceZendeskTalkConfigurationCredentialsOAuth20Args']]):
        pulumi.set(self, "o_auth20", value)


@pulumi.input_type
class SourceZendeskTalkConfigurationCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 email: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        :param pulumi.Input[str] email: The user email for your Zendesk account.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "email", email)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        The user email for your Zendesk account.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)


@pulumi.input_type
class SourceZendeskTalkConfigurationCredentialsOAuth20Args:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        :param pulumi.Input[str] additional_properties: Parsed as JSON.
        :param pulumi.Input[str] client_id: Client ID
        :param pulumi.Input[str] client_secret: Client Secret
        """
        pulumi.set(__self__, "access_token", access_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[str]]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Client ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)


@pulumi.input_type
class SourceZenloopConfigurationArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 date_from: Optional[pulumi.Input[str]] = None,
                 survey_group_id: Optional[pulumi.Input[str]] = None,
                 survey_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Zenloop API Token. You can get the API token in settings page <a href="https://app.zenloop.com/settings/api">here</a>
        :param pulumi.Input[str] date_from: Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
        :param pulumi.Input[str] survey_group_id: Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
        :param pulumi.Input[str] survey_id: Zenloop Survey ID. Can be found <a href="https://app.zenloop.com/settings/api">here</a>. Leave empty to pull answers from all surveys
        """
        pulumi.set(__self__, "api_token", api_token)
        if date_from is not None:
            pulumi.set(__self__, "date_from", date_from)
        if survey_group_id is not None:
            pulumi.set(__self__, "survey_group_id", survey_group_id)
        if survey_id is not None:
            pulumi.set(__self__, "survey_id", survey_id)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Zenloop API Token. You can get the API token in settings page <a href="https://app.zenloop.com/settings/api">here</a>
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="dateFrom")
    def date_from(self) -> Optional[pulumi.Input[str]]:
        """
        Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
        """
        return pulumi.get(self, "date_from")

    @date_from.setter
    def date_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_from", value)

    @property
    @pulumi.getter(name="surveyGroupId")
    def survey_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
        """
        return pulumi.get(self, "survey_group_id")

    @survey_group_id.setter
    def survey_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "survey_group_id", value)

    @property
    @pulumi.getter(name="surveyId")
    def survey_id(self) -> Optional[pulumi.Input[str]]:
        """
        Zenloop Survey ID. Can be found <a href="https://app.zenloop.com/settings/api">here</a>. Leave empty to pull answers from all surveys
        """
        return pulumi.get(self, "survey_id")

    @survey_id.setter
    def survey_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "survey_id", value)


@pulumi.input_type
class SourceZohoCrmConfigurationArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 dc_region: pulumi.Input[str],
                 environment: pulumi.Input[str],
                 refresh_token: pulumi.Input[str],
                 edition: Optional[pulumi.Input[str]] = None,
                 start_datetime: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: OAuth2.0 Client ID
        :param pulumi.Input[str] client_secret: OAuth2.0 Client Secret
        :param pulumi.Input[str] dc_region: Please choose the region of your Data Center location. More info by this <a href="https://www.zoho.com/crm/developer/docs/api/v2/multi-dc.html">Link</a>. must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
        :param pulumi.Input[str] environment: Please choose the environment. must be one of ["Production", "Developer", "Sandbox"]
        :param pulumi.Input[str] refresh_token: OAuth2.0 Refresh Token
        :param pulumi.Input[str] edition: Choose your Edition of Zoho CRM to determine API Concurrency Limits. must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]; Default: "Free"
        :param pulumi.Input[str] start_datetime: ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "dc_region", dc_region)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if start_datetime is not None:
            pulumi.set(__self__, "start_datetime", start_datetime)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        OAuth2.0 Client ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        OAuth2.0 Client Secret
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="dcRegion")
    def dc_region(self) -> pulumi.Input[str]:
        """
        Please choose the region of your Data Center location. More info by this <a href="https://www.zoho.com/crm/developer/docs/api/v2/multi-dc.html">Link</a>. must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
        """
        return pulumi.get(self, "dc_region")

    @dc_region.setter
    def dc_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "dc_region", value)

    @property
    @pulumi.getter
    def environment(self) -> pulumi.Input[str]:
        """
        Please choose the environment. must be one of ["Production", "Developer", "Sandbox"]
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: pulumi.Input[str]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> pulumi.Input[str]:
        """
        OAuth2.0 Refresh Token
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter
    def edition(self) -> Optional[pulumi.Input[str]]:
        """
        Choose your Edition of Zoho CRM to determine API Concurrency Limits. must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]; Default: "Free"
        """
        return pulumi.get(self, "edition")

    @edition.setter
    def edition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "edition", value)

    @property
    @pulumi.getter(name="startDatetime")
    def start_datetime(self) -> Optional[pulumi.Input[str]]:
        """
        ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
        """
        return pulumi.get(self, "start_datetime")

    @start_datetime.setter
    def start_datetime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_datetime", value)


@pulumi.input_type
class SourceZoomConfigurationArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 authorization_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] account_id: The account ID for your Zoom account. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        :param pulumi.Input[str] client_id: The client ID for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        :param pulumi.Input[str] client_secret: The client secret for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        :param pulumi.Input[str] authorization_endpoint: Default: "https://zoom.us/oauth/token"
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        The account ID for your Zoom account. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        The client ID for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        The client secret for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Default: "https://zoom.us/oauth/token"
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorization_endpoint", value)


