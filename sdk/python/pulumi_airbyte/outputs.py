# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ConnectionConfigurations',
    'ConnectionConfigurationsStream',
    'ConnectionSchedule',
    'DestinationAstraConfiguration',
    'DestinationAstraConfigurationEmbedding',
    'DestinationAstraConfigurationEmbeddingAzureOpenAi',
    'DestinationAstraConfigurationEmbeddingCohere',
    'DestinationAstraConfigurationEmbeddingFake',
    'DestinationAstraConfigurationEmbeddingOpenAi',
    'DestinationAstraConfigurationEmbeddingOpenAiCompatible',
    'DestinationAstraConfigurationIndexing',
    'DestinationAstraConfigurationProcessing',
    'DestinationAstraConfigurationProcessingFieldNameMapping',
    'DestinationAstraConfigurationProcessingTextSplitter',
    'DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader',
    'DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguage',
    'DestinationAstraConfigurationProcessingTextSplitterBySeparator',
    'DestinationAwsDatalakeConfiguration',
    'DestinationAwsDatalakeConfigurationCredentials',
    'DestinationAwsDatalakeConfigurationCredentialsIamRole',
    'DestinationAwsDatalakeConfigurationCredentialsIamUser',
    'DestinationAwsDatalakeConfigurationFormat',
    'DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson',
    'DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage',
    'DestinationAzureBlobStorageConfiguration',
    'DestinationAzureBlobStorageConfigurationFormat',
    'DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValues',
    'DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJson',
    'DestinationBigqueryConfiguration',
    'DestinationBigqueryConfigurationLoadingMethod',
    'DestinationBigqueryConfigurationLoadingMethodGcsStaging',
    'DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential',
    'DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey',
    'DestinationBigqueryConfigurationLoadingMethodStandardInserts',
    'DestinationClickhouseConfiguration',
    'DestinationClickhouseConfigurationTunnelMethod',
    'DestinationClickhouseConfigurationTunnelMethodNoTunnel',
    'DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication',
    'DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationConvexConfiguration',
    'DestinationDatabricksConfiguration',
    'DestinationDatabricksConfigurationDataSource',
    'DestinationDatabricksConfigurationDataSourceAmazonS3',
    'DestinationDatabricksConfigurationDataSourceAzureBlobStorage',
    'DestinationDatabricksConfigurationDataSourceRecommendedManagedTables',
    'DestinationDevNullConfiguration',
    'DestinationDevNullConfigurationTestDestination',
    'DestinationDevNullConfigurationTestDestinationSilent',
    'DestinationDuckdbConfiguration',
    'DestinationDynamodbConfiguration',
    'DestinationElasticsearchConfiguration',
    'DestinationElasticsearchConfigurationAuthenticationMethod',
    'DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret',
    'DestinationElasticsearchConfigurationAuthenticationMethodUsernamePassword',
    'DestinationFirestoreConfiguration',
    'DestinationGcsConfiguration',
    'DestinationGcsConfigurationCredential',
    'DestinationGcsConfigurationCredentialHmacKey',
    'DestinationGcsConfigurationFormat',
    'DestinationGcsConfigurationFormatAvroApacheAvro',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompression',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappy',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz',
    'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValues',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip',
    'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip',
    'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression',
    'DestinationGcsConfigurationFormatParquetColumnarStorage',
    'DestinationGoogleSheetsConfiguration',
    'DestinationGoogleSheetsConfigurationCredentials',
    'DestinationLangchainConfiguration',
    'DestinationLangchainConfigurationEmbedding',
    'DestinationLangchainConfigurationEmbeddingFake',
    'DestinationLangchainConfigurationEmbeddingOpenAi',
    'DestinationLangchainConfigurationIndexing',
    'DestinationLangchainConfigurationIndexingChromaLocalPersistance',
    'DestinationLangchainConfigurationIndexingDocArrayHnswSearch',
    'DestinationLangchainConfigurationIndexingPinecone',
    'DestinationLangchainConfigurationProcessing',
    'DestinationMilvusConfiguration',
    'DestinationMilvusConfigurationEmbedding',
    'DestinationMilvusConfigurationEmbeddingAzureOpenAi',
    'DestinationMilvusConfigurationEmbeddingCohere',
    'DestinationMilvusConfigurationEmbeddingFake',
    'DestinationMilvusConfigurationEmbeddingOpenAi',
    'DestinationMilvusConfigurationEmbeddingOpenAiCompatible',
    'DestinationMilvusConfigurationIndexing',
    'DestinationMilvusConfigurationIndexingAuth',
    'DestinationMilvusConfigurationIndexingAuthApiToken',
    'DestinationMilvusConfigurationIndexingAuthNoAuth',
    'DestinationMilvusConfigurationIndexingAuthUsernamePassword',
    'DestinationMilvusConfigurationProcessing',
    'DestinationMilvusConfigurationProcessingFieldNameMapping',
    'DestinationMilvusConfigurationProcessingTextSplitter',
    'DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader',
    'DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguage',
    'DestinationMilvusConfigurationProcessingTextSplitterBySeparator',
    'DestinationMongodbConfiguration',
    'DestinationMongodbConfigurationAuthType',
    'DestinationMongodbConfigurationAuthTypeLoginPassword',
    'DestinationMongodbConfigurationAuthTypeNone',
    'DestinationMongodbConfigurationInstanceType',
    'DestinationMongodbConfigurationInstanceTypeMongoDbAtlas',
    'DestinationMongodbConfigurationInstanceTypeReplicaSet',
    'DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstance',
    'DestinationMongodbConfigurationTunnelMethod',
    'DestinationMongodbConfigurationTunnelMethodNoTunnel',
    'DestinationMongodbConfigurationTunnelMethodPasswordAuthentication',
    'DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationMssqlConfiguration',
    'DestinationMssqlConfigurationSslMethod',
    'DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificate',
    'DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate',
    'DestinationMssqlConfigurationTunnelMethod',
    'DestinationMssqlConfigurationTunnelMethodNoTunnel',
    'DestinationMssqlConfigurationTunnelMethodPasswordAuthentication',
    'DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationMysqlConfiguration',
    'DestinationMysqlConfigurationTunnelMethod',
    'DestinationMysqlConfigurationTunnelMethodNoTunnel',
    'DestinationMysqlConfigurationTunnelMethodPasswordAuthentication',
    'DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationOracleConfiguration',
    'DestinationOracleConfigurationTunnelMethod',
    'DestinationOracleConfigurationTunnelMethodNoTunnel',
    'DestinationOracleConfigurationTunnelMethodPasswordAuthentication',
    'DestinationOracleConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationPineconeConfiguration',
    'DestinationPineconeConfigurationEmbedding',
    'DestinationPineconeConfigurationEmbeddingAzureOpenAi',
    'DestinationPineconeConfigurationEmbeddingCohere',
    'DestinationPineconeConfigurationEmbeddingFake',
    'DestinationPineconeConfigurationEmbeddingOpenAi',
    'DestinationPineconeConfigurationEmbeddingOpenAiCompatible',
    'DestinationPineconeConfigurationIndexing',
    'DestinationPineconeConfigurationProcessing',
    'DestinationPineconeConfigurationProcessingFieldNameMapping',
    'DestinationPineconeConfigurationProcessingTextSplitter',
    'DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader',
    'DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguage',
    'DestinationPineconeConfigurationProcessingTextSplitterBySeparator',
    'DestinationPostgresConfiguration',
    'DestinationPostgresConfigurationSslMode',
    'DestinationPostgresConfigurationSslModeAllow',
    'DestinationPostgresConfigurationSslModeDisable',
    'DestinationPostgresConfigurationSslModePrefer',
    'DestinationPostgresConfigurationSslModeRequire',
    'DestinationPostgresConfigurationSslModeVerifyCa',
    'DestinationPostgresConfigurationSslModeVerifyFull',
    'DestinationPostgresConfigurationTunnelMethod',
    'DestinationPostgresConfigurationTunnelMethodNoTunnel',
    'DestinationPostgresConfigurationTunnelMethodPasswordAuthentication',
    'DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationPubsubConfiguration',
    'DestinationQdrantConfiguration',
    'DestinationQdrantConfigurationEmbedding',
    'DestinationQdrantConfigurationEmbeddingAzureOpenAi',
    'DestinationQdrantConfigurationEmbeddingCohere',
    'DestinationQdrantConfigurationEmbeddingFake',
    'DestinationQdrantConfigurationEmbeddingOpenAi',
    'DestinationQdrantConfigurationEmbeddingOpenAiCompatible',
    'DestinationQdrantConfigurationIndexing',
    'DestinationQdrantConfigurationIndexingAuthMethod',
    'DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth',
    'DestinationQdrantConfigurationIndexingAuthMethodNoAuth',
    'DestinationQdrantConfigurationProcessing',
    'DestinationQdrantConfigurationProcessingFieldNameMapping',
    'DestinationQdrantConfigurationProcessingTextSplitter',
    'DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader',
    'DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguage',
    'DestinationQdrantConfigurationProcessingTextSplitterBySeparator',
    'DestinationRedisConfiguration',
    'DestinationRedisConfigurationSslMode',
    'DestinationRedisConfigurationSslModeDisable',
    'DestinationRedisConfigurationSslModeVerifyFull',
    'DestinationRedisConfigurationTunnelMethod',
    'DestinationRedisConfigurationTunnelMethodNoTunnel',
    'DestinationRedisConfigurationTunnelMethodPasswordAuthentication',
    'DestinationRedisConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationRedshiftConfiguration',
    'DestinationRedshiftConfigurationTunnelMethod',
    'DestinationRedshiftConfigurationTunnelMethodNoTunnel',
    'DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication',
    'DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication',
    'DestinationRedshiftConfigurationUploadingMethod',
    'DestinationRedshiftConfigurationUploadingMethodAwss3Staging',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption',
    'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryption',
    'DestinationRedshiftConfigurationUploadingMethodStandard',
    'DestinationS3Configuration',
    'DestinationS3ConfigurationFormat',
    'DestinationS3ConfigurationFormatAvroApacheAvro',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompression',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappy',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz',
    'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValues',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip',
    'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip',
    'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression',
    'DestinationS3ConfigurationFormatParquetColumnarStorage',
    'DestinationS3GlueConfiguration',
    'DestinationS3GlueConfigurationFormat',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip',
    'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression',
    'DestinationSftpJsonConfiguration',
    'DestinationSnowflakeConfiguration',
    'DestinationSnowflakeConfigurationCredentials',
    'DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication',
    'DestinationSnowflakeConfigurationCredentialsOAuth20',
    'DestinationSnowflakeConfigurationCredentialsUsernameAndPassword',
    'DestinationSnowflakeCortexConfiguration',
    'DestinationSnowflakeCortexConfigurationEmbedding',
    'DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi',
    'DestinationSnowflakeCortexConfigurationEmbeddingCohere',
    'DestinationSnowflakeCortexConfigurationEmbeddingFake',
    'DestinationSnowflakeCortexConfigurationEmbeddingOpenAi',
    'DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible',
    'DestinationSnowflakeCortexConfigurationIndexing',
    'DestinationSnowflakeCortexConfigurationIndexingCredentials',
    'DestinationSnowflakeCortexConfigurationProcessing',
    'DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitter',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguage',
    'DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator',
    'DestinationTeradataConfiguration',
    'DestinationTeradataConfigurationSslMode',
    'DestinationTeradataConfigurationSslModeAllow',
    'DestinationTeradataConfigurationSslModeDisable',
    'DestinationTeradataConfigurationSslModePrefer',
    'DestinationTeradataConfigurationSslModeRequire',
    'DestinationTeradataConfigurationSslModeVerifyCa',
    'DestinationTeradataConfigurationSslModeVerifyFull',
    'DestinationTypesenseConfiguration',
    'DestinationVectaraConfiguration',
    'DestinationVectaraConfigurationOauth2',
    'DestinationWeaviateConfiguration',
    'DestinationWeaviateConfigurationEmbedding',
    'DestinationWeaviateConfigurationEmbeddingAzureOpenAi',
    'DestinationWeaviateConfigurationEmbeddingCohere',
    'DestinationWeaviateConfigurationEmbeddingFake',
    'DestinationWeaviateConfigurationEmbeddingFromField',
    'DestinationWeaviateConfigurationEmbeddingNoExternalEmbedding',
    'DestinationWeaviateConfigurationEmbeddingOpenAi',
    'DestinationWeaviateConfigurationEmbeddingOpenAiCompatible',
    'DestinationWeaviateConfigurationIndexing',
    'DestinationWeaviateConfigurationIndexingAdditionalHeader',
    'DestinationWeaviateConfigurationIndexingAuth',
    'DestinationWeaviateConfigurationIndexingAuthApiToken',
    'DestinationWeaviateConfigurationIndexingAuthNoAuthentication',
    'DestinationWeaviateConfigurationIndexingAuthUsernamePassword',
    'DestinationWeaviateConfigurationProcessing',
    'DestinationWeaviateConfigurationProcessingFieldNameMapping',
    'DestinationWeaviateConfigurationProcessingTextSplitter',
    'DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader',
    'DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguage',
    'DestinationWeaviateConfigurationProcessingTextSplitterBySeparator',
    'DestinationYellowbrickConfiguration',
    'DestinationYellowbrickConfigurationSslMode',
    'DestinationYellowbrickConfigurationSslModeAllow',
    'DestinationYellowbrickConfigurationSslModeDisable',
    'DestinationYellowbrickConfigurationSslModePrefer',
    'DestinationYellowbrickConfigurationSslModeRequire',
    'DestinationYellowbrickConfigurationSslModeVerifyCa',
    'DestinationYellowbrickConfigurationSslModeVerifyFull',
    'DestinationYellowbrickConfigurationTunnelMethod',
    'DestinationYellowbrickConfigurationTunnelMethodNoTunnel',
    'DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication',
    'DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication',
    'SourceAhaConfiguration',
    'SourceAircallConfiguration',
    'SourceAirtableConfiguration',
    'SourceAirtableConfigurationCredentials',
    'SourceAirtableConfigurationCredentialsOAuth20',
    'SourceAirtableConfigurationCredentialsPersonalAccessToken',
    'SourceAmazonAdsConfiguration',
    'SourceAmazonSellerPartnerConfiguration',
    'SourceAmazonSellerPartnerConfigurationReportOptionsList',
    'SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList',
    'SourceAmazonSqsConfiguration',
    'SourceAmplitudeConfiguration',
    'SourceApifyDatasetConfiguration',
    'SourceAppfollowConfiguration',
    'SourceAsanaConfiguration',
    'SourceAsanaConfigurationCredentials',
    'SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth',
    'SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken',
    'SourceAuth0Configuration',
    'SourceAuth0ConfigurationCredentials',
    'SourceAuth0ConfigurationCredentialsOAuth2AccessToken',
    'SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication',
    'SourceAwsCloudtrailConfiguration',
    'SourceAzureBlobStorageConfiguration',
    'SourceAzureBlobStorageConfigurationCredentials',
    'SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2',
    'SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey',
    'SourceAzureBlobStorageConfigurationStream',
    'SourceAzureBlobStorageConfigurationStreamFormat',
    'SourceAzureBlobStorageConfigurationStreamFormatAvroFormat',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormat',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental',
    'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing',
    'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal',
    'SourceAzureBlobStorageConfigurationStreamFormatJsonlFormat',
    'SourceAzureBlobStorageConfigurationStreamFormatParquetFormat',
    'SourceAzureTableConfiguration',
    'SourceBambooHrConfiguration',
    'SourceBigqueryConfiguration',
    'SourceBingAdsConfiguration',
    'SourceBingAdsConfigurationAccountName',
    'SourceBingAdsConfigurationCustomReport',
    'SourceBraintreeConfiguration',
    'SourceBrazeConfiguration',
    'SourceCartConfiguration',
    'SourceCartConfigurationCredentials',
    'SourceCartConfigurationCredentialsCentralApiRouter',
    'SourceCartConfigurationCredentialsSingleStoreAccessToken',
    'SourceChargebeeConfiguration',
    'SourceChartmogulConfiguration',
    'SourceClickhouseConfiguration',
    'SourceClickhouseConfigurationTunnelMethod',
    'SourceClickhouseConfigurationTunnelMethodNoTunnel',
    'SourceClickhouseConfigurationTunnelMethodPasswordAuthentication',
    'SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication',
    'SourceClickupApiConfiguration',
    'SourceClockifyConfiguration',
    'SourceCloseComConfiguration',
    'SourceCodaConfiguration',
    'SourceCoinApiConfiguration',
    'SourceCoinmarketcapConfiguration',
    'SourceConfigcatConfiguration',
    'SourceConfluenceConfiguration',
    'SourceConvexConfiguration',
    'SourceDatascopeConfiguration',
    'SourceDelightedConfiguration',
    'SourceDixaConfiguration',
    'SourceDockerhubConfiguration',
    'SourceDremioConfiguration',
    'SourceDynamodbConfiguration',
    'SourceDynamodbConfigurationCredentials',
    'SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys',
    'SourceDynamodbConfigurationCredentialsRoleBasedAuthentication',
    'SourceEmailoctopusConfiguration',
    'SourceExchangeRatesConfiguration',
    'SourceFacebookMarketingConfiguration',
    'SourceFacebookMarketingConfigurationCustomInsight',
    'SourceFakerConfiguration',
    'SourceFaunaConfiguration',
    'SourceFaunaConfigurationCollection',
    'SourceFaunaConfigurationCollectionDeletions',
    'SourceFaunaConfigurationCollectionDeletionsDisabled',
    'SourceFaunaConfigurationCollectionDeletionsEnabled',
    'SourceFileConfiguration',
    'SourceFileConfigurationProvider',
    'SourceFileConfigurationProviderAzBlobAzureBlobStorage',
    'SourceFileConfigurationProviderGcsGoogleCloudStorage',
    'SourceFileConfigurationProviderHttpsPublicWeb',
    'SourceFileConfigurationProviderS3AmazonWebServices',
    'SourceFileConfigurationProviderScpSecureCopyProtocol',
    'SourceFileConfigurationProviderSftpSecureFileTransferProtocol',
    'SourceFileConfigurationProviderSshSecureShell',
    'SourceFireboltConfiguration',
    'SourceFreshcallerConfiguration',
    'SourceFreshdeskConfiguration',
    'SourceFreshsalesConfiguration',
    'SourceGainsightPxConfiguration',
    'SourceGcsConfiguration',
    'SourceGcsConfigurationStream',
    'SourceGcsConfigurationStreamFormat',
    'SourceGcsConfigurationStreamFormatCsvFormat',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceGetlagoConfiguration',
    'SourceGithubConfiguration',
    'SourceGithubConfigurationCredentials',
    'SourceGithubConfigurationCredentialsOAuth',
    'SourceGithubConfigurationCredentialsPersonalAccessToken',
    'SourceGitlabConfiguration',
    'SourceGitlabConfigurationCredentials',
    'SourceGitlabConfigurationCredentialsOAuth20',
    'SourceGitlabConfigurationCredentialsPrivateToken',
    'SourceGlassfrogConfiguration',
    'SourceGnewsConfiguration',
    'SourceGoogleAdsConfiguration',
    'SourceGoogleAdsConfigurationCredentials',
    'SourceGoogleAdsConfigurationCustomQueriesArray',
    'SourceGoogleAnalyticsDataApiConfiguration',
    'SourceGoogleAnalyticsDataApiConfigurationCredentials',
    'SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth',
    'SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpec',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabled',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettings',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroup',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroup',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroup',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroup',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilter',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValue',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64Value',
    'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter',
    'SourceGoogleAnalyticsV4ServiceAccountOnlyConfiguration',
    'SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials',
    'SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication',
    'SourceGoogleDirectoryConfiguration',
    'SourceGoogleDirectoryConfigurationCredentials',
    'SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey',
    'SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth',
    'SourceGoogleDriveConfiguration',
    'SourceGoogleDriveConfigurationCredentials',
    'SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth',
    'SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication',
    'SourceGoogleDriveConfigurationStream',
    'SourceGoogleDriveConfigurationStreamFormat',
    'SourceGoogleDriveConfigurationStreamFormatAvroFormat',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormat',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental',
    'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing',
    'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal',
    'SourceGoogleDriveConfigurationStreamFormatJsonlFormat',
    'SourceGoogleDriveConfigurationStreamFormatParquetFormat',
    'SourceGooglePagespeedInsightsConfiguration',
    'SourceGoogleSearchConsoleConfiguration',
    'SourceGoogleSearchConsoleConfigurationAuthorization',
    'SourceGoogleSearchConsoleConfigurationAuthorizationOAuth',
    'SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication',
    'SourceGoogleSearchConsoleConfigurationCustomReportsArray',
    'SourceGoogleSheetsConfiguration',
    'SourceGoogleSheetsConfigurationCredentials',
    'SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth',
    'SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication',
    'SourceGoogleWebfontsConfiguration',
    'SourceGreenhouseConfiguration',
    'SourceGridlyConfiguration',
    'SourceHarvestConfiguration',
    'SourceHarvestConfigurationCredentials',
    'SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth',
    'SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken',
    'SourceHubplannerConfiguration',
    'SourceHubspotConfiguration',
    'SourceHubspotConfigurationCredentials',
    'SourceHubspotConfigurationCredentialsOAuth',
    'SourceHubspotConfigurationCredentialsPrivateApp',
    'SourceInsightlyConfiguration',
    'SourceInstagramConfiguration',
    'SourceInstatusConfiguration',
    'SourceIntercomConfiguration',
    'SourceIp2whoisConfiguration',
    'SourceIterableConfiguration',
    'SourceJiraConfiguration',
    'SourceK6CloudConfiguration',
    'SourceKlarnaConfiguration',
    'SourceKlaviyoConfiguration',
    'SourceKyveConfiguration',
    'SourceLaunchdarklyConfiguration',
    'SourceLemlistConfiguration',
    'SourceLeverHiringConfiguration',
    'SourceLeverHiringConfigurationCredentials',
    'SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey',
    'SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth',
    'SourceLinkedinAdsConfiguration',
    'SourceLinkedinAdsConfigurationAdAnalyticsReport',
    'SourceLinkedinAdsConfigurationCredentials',
    'SourceLinkedinAdsConfigurationCredentialsAccessToken',
    'SourceLinkedinAdsConfigurationCredentialsOAuth20',
    'SourceLinkedinPagesConfiguration',
    'SourceLinkedinPagesConfigurationCredentials',
    'SourceLinkedinPagesConfigurationCredentialsAccessToken',
    'SourceLinkedinPagesConfigurationCredentialsOAuth20',
    'SourceLinnworksConfiguration',
    'SourceLokaliseConfiguration',
    'SourceMailchimpConfiguration',
    'SourceMailchimpConfigurationCredentials',
    'SourceMailchimpConfigurationCredentialsApiKey',
    'SourceMailchimpConfigurationCredentialsOAuth20',
    'SourceMailgunConfiguration',
    'SourceMailjetSmsConfiguration',
    'SourceMarketoConfiguration',
    'SourceMetabaseConfiguration',
    'SourceMicrosoftOnedriveConfiguration',
    'SourceMicrosoftOnedriveConfigurationCredentials',
    'SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth',
    'SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication',
    'SourceMicrosoftOnedriveConfigurationStream',
    'SourceMicrosoftOnedriveConfigurationStreamFormat',
    'SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental',
    'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing',
    'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal',
    'SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormat',
    'SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat',
    'SourceMicrosoftSharepointConfiguration',
    'SourceMicrosoftSharepointConfigurationCredentials',
    'SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth',
    'SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication',
    'SourceMicrosoftSharepointConfigurationStream',
    'SourceMicrosoftSharepointConfigurationStreamFormat',
    'SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental',
    'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing',
    'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal',
    'SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormat',
    'SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat',
    'SourceMicrosoftTeamsConfiguration',
    'SourceMicrosoftTeamsConfigurationCredentials',
    'SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft',
    'SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20',
    'SourceMixpanelConfiguration',
    'SourceMixpanelConfigurationCredentials',
    'SourceMixpanelConfigurationCredentialsProjectSecret',
    'SourceMixpanelConfigurationCredentialsServiceAccount',
    'SourceMondayConfiguration',
    'SourceMondayConfigurationCredentials',
    'SourceMondayConfigurationCredentialsApiToken',
    'SourceMondayConfigurationCredentialsOAuth20',
    'SourceMongodbInternalPocConfiguration',
    'SourceMongodbV2Configuration',
    'SourceMongodbV2ConfigurationDatabaseConfig',
    'SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet',
    'SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet',
    'SourceMssqlConfiguration',
    'SourceMssqlConfigurationReplicationMethod',
    'SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc',
    'SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor',
    'SourceMssqlConfigurationSslMethod',
    'SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificate',
    'SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate',
    'SourceMssqlConfigurationSslMethodUnencrypted',
    'SourceMssqlConfigurationTunnelMethod',
    'SourceMssqlConfigurationTunnelMethodNoTunnel',
    'SourceMssqlConfigurationTunnelMethodPasswordAuthentication',
    'SourceMssqlConfigurationTunnelMethodSshKeyAuthentication',
    'SourceMyHoursConfiguration',
    'SourceMysqlConfiguration',
    'SourceMysqlConfigurationReplicationMethod',
    'SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc',
    'SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor',
    'SourceMysqlConfigurationSslMode',
    'SourceMysqlConfigurationSslModePreferred',
    'SourceMysqlConfigurationSslModeRequired',
    'SourceMysqlConfigurationSslModeVerifyCa',
    'SourceMysqlConfigurationSslModeVerifyIdentity',
    'SourceMysqlConfigurationTunnelMethod',
    'SourceMysqlConfigurationTunnelMethodNoTunnel',
    'SourceMysqlConfigurationTunnelMethodPasswordAuthentication',
    'SourceMysqlConfigurationTunnelMethodSshKeyAuthentication',
    'SourceNetsuiteConfiguration',
    'SourceNotionConfiguration',
    'SourceNotionConfigurationCredentials',
    'SourceNotionConfigurationCredentialsAccessToken',
    'SourceNotionConfigurationCredentialsOAuth20',
    'SourceNytimesConfiguration',
    'SourceOktaConfiguration',
    'SourceOktaConfigurationCredentials',
    'SourceOktaConfigurationCredentialsApiToken',
    'SourceOktaConfigurationCredentialsOAuth20',
    'SourceOmnisendConfiguration',
    'SourceOnesignalConfiguration',
    'SourceOnesignalConfigurationApplication',
    'SourceOracleConfiguration',
    'SourceOracleConfigurationConnectionData',
    'SourceOracleConfigurationConnectionDataServiceName',
    'SourceOracleConfigurationConnectionDataSystemIdsid',
    'SourceOracleConfigurationEncryption',
    'SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne',
    'SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate',
    'SourceOracleConfigurationTunnelMethod',
    'SourceOracleConfigurationTunnelMethodNoTunnel',
    'SourceOracleConfigurationTunnelMethodPasswordAuthentication',
    'SourceOracleConfigurationTunnelMethodSshKeyAuthentication',
    'SourceOrbConfiguration',
    'SourceOrbitConfiguration',
    'SourceOutbrainAmplifyConfiguration',
    'SourceOutbrainAmplifyConfigurationCredentials',
    'SourceOutbrainAmplifyConfigurationCredentialsAccessToken',
    'SourceOutbrainAmplifyConfigurationCredentialsUsernamePassword',
    'SourceOutreachConfiguration',
    'SourcePaypalTransactionConfiguration',
    'SourcePaystackConfiguration',
    'SourcePendoConfiguration',
    'SourcePersistiqConfiguration',
    'SourcePexelsApiConfiguration',
    'SourcePinterestConfiguration',
    'SourcePinterestConfigurationCredentials',
    'SourcePinterestConfigurationCustomReport',
    'SourcePipedriveConfiguration',
    'SourcePocketConfiguration',
    'SourcePokeapiConfiguration',
    'SourcePolygonStockApiConfiguration',
    'SourcePostgresConfiguration',
    'SourcePostgresConfigurationReplicationMethod',
    'SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumn',
    'SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc',
    'SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursor',
    'SourcePostgresConfigurationSslMode',
    'SourcePostgresConfigurationSslModeAllow',
    'SourcePostgresConfigurationSslModeDisable',
    'SourcePostgresConfigurationSslModePrefer',
    'SourcePostgresConfigurationSslModeRequire',
    'SourcePostgresConfigurationSslModeVerifyCa',
    'SourcePostgresConfigurationSslModeVerifyFull',
    'SourcePostgresConfigurationTunnelMethod',
    'SourcePostgresConfigurationTunnelMethodNoTunnel',
    'SourcePostgresConfigurationTunnelMethodPasswordAuthentication',
    'SourcePostgresConfigurationTunnelMethodSshKeyAuthentication',
    'SourcePosthogConfiguration',
    'SourcePostmarkappConfiguration',
    'SourcePrestashopConfiguration',
    'SourcePunkApiConfiguration',
    'SourcePypiConfiguration',
    'SourceQualarooConfiguration',
    'SourceRailzConfiguration',
    'SourceRechargeConfiguration',
    'SourceRecreationConfiguration',
    'SourceRecruiteeConfiguration',
    'SourceRecurlyConfiguration',
    'SourceRedshiftConfiguration',
    'SourceRetentlyConfiguration',
    'SourceRetentlyConfigurationCredentials',
    'SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth',
    'SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken',
    'SourceRkiCovidConfiguration',
    'SourceRssConfiguration',
    'SourceS3Configuration',
    'SourceS3ConfigurationFormat',
    'SourceS3ConfigurationFormatAvro',
    'SourceS3ConfigurationFormatCsv',
    'SourceS3ConfigurationFormatJsonl',
    'SourceS3ConfigurationFormatParquet',
    'SourceS3ConfigurationProvider',
    'SourceS3ConfigurationStream',
    'SourceS3ConfigurationStreamFormat',
    'SourceS3ConfigurationStreamFormatAvroFormat',
    'SourceS3ConfigurationStreamFormatCsvFormat',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental',
    'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing',
    'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal',
    'SourceS3ConfigurationStreamFormatJsonlFormat',
    'SourceS3ConfigurationStreamFormatParquetFormat',
    'SourceSalesforceConfiguration',
    'SourceSalesforceConfigurationStreamsCriteria',
    'SourceSalesloftConfiguration',
    'SourceSalesloftConfigurationCredentials',
    'SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey',
    'SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth',
    'SourceSapFieldglassConfiguration',
    'SourceSecodaConfiguration',
    'SourceSendgridConfiguration',
    'SourceSendinblueConfiguration',
    'SourceSenseforceConfiguration',
    'SourceSentryConfiguration',
    'SourceSftpBulkConfiguration',
    'SourceSftpBulkConfigurationCredentials',
    'SourceSftpBulkConfigurationCredentialsAuthenticateViaPassword',
    'SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey',
    'SourceSftpBulkConfigurationStream',
    'SourceSftpBulkConfigurationStreamFormat',
    'SourceSftpBulkConfigurationStreamFormatAvroFormat',
    'SourceSftpBulkConfigurationStreamFormatCsvFormat',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv',
    'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi',
    'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameter',
    'SourceSftpBulkConfigurationStreamFormatJsonlFormat',
    'SourceSftpBulkConfigurationStreamFormatParquetFormat',
    'SourceSftpConfiguration',
    'SourceSftpConfigurationCredentials',
    'SourceSftpConfigurationCredentialsPasswordAuthentication',
    'SourceSftpConfigurationCredentialsSshKeyAuthentication',
    'SourceShopifyConfiguration',
    'SourceShopifyConfigurationCredentials',
    'SourceShopifyConfigurationCredentialsApiPassword',
    'SourceShopifyConfigurationCredentialsOAuth20',
    'SourceShortioConfiguration',
    'SourceSlackConfiguration',
    'SourceSlackConfigurationCredentials',
    'SourceSlackConfigurationCredentialsApiToken',
    'SourceSlackConfigurationCredentialsSignInViaSlackOAuth',
    'SourceSmailyConfiguration',
    'SourceSmartengageConfiguration',
    'SourceSmartsheetsConfiguration',
    'SourceSmartsheetsConfigurationCredentials',
    'SourceSmartsheetsConfigurationCredentialsApiAccessToken',
    'SourceSmartsheetsConfigurationCredentialsOAuth20',
    'SourceSnapchatMarketingConfiguration',
    'SourceSnowflakeConfiguration',
    'SourceSnowflakeConfigurationCredentials',
    'SourceSnowflakeConfigurationCredentialsOAuth20',
    'SourceSnowflakeConfigurationCredentialsUsernameAndPassword',
    'SourceSonarCloudConfiguration',
    'SourceSpacexApiConfiguration',
    'SourceSquareConfiguration',
    'SourceSquareConfigurationCredentials',
    'SourceSquareConfigurationCredentialsApiKey',
    'SourceSquareConfigurationCredentialsOauthAuthentication',
    'SourceStravaConfiguration',
    'SourceStripeConfiguration',
    'SourceSurveySparrowConfiguration',
    'SourceSurveySparrowConfigurationRegion',
    'SourceSurveySparrowConfigurationRegionEuBasedAccount',
    'SourceSurveySparrowConfigurationRegionGlobalAccount',
    'SourceSurveymonkeyConfiguration',
    'SourceSurveymonkeyConfigurationCredentials',
    'SourceTempoConfiguration',
    'SourceTheGuardianApiConfiguration',
    'SourceTiktokMarketingConfiguration',
    'SourceTiktokMarketingConfigurationCredentials',
    'SourceTiktokMarketingConfigurationCredentialsOAuth20',
    'SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken',
    'SourceTrelloConfiguration',
    'SourceTrustpilotConfiguration',
    'SourceTrustpilotConfigurationCredentials',
    'SourceTrustpilotConfigurationCredentialsApiKey',
    'SourceTrustpilotConfigurationCredentialsOAuth20',
    'SourceTvmazeScheduleConfiguration',
    'SourceTwilioConfiguration',
    'SourceTwilioTaskrouterConfiguration',
    'SourceTwitterConfiguration',
    'SourceTypeformConfiguration',
    'SourceTypeformConfigurationCredentials',
    'SourceTypeformConfigurationCredentialsOAuth20',
    'SourceTypeformConfigurationCredentialsPrivateToken',
    'SourceUsCensusConfiguration',
    'SourceVantageConfiguration',
    'SourceWebflowConfiguration',
    'SourceWhiskyHunterConfiguration',
    'SourceWikipediaPageviewsConfiguration',
    'SourceWoocommerceConfiguration',
    'SourceXkcdConfiguration',
    'SourceYandexMetricaConfiguration',
    'SourceYotpoConfiguration',
    'SourceYoutubeAnalyticsConfiguration',
    'SourceYoutubeAnalyticsConfigurationCredentials',
    'SourceZendeskChatConfiguration',
    'SourceZendeskChatConfigurationCredentials',
    'SourceZendeskChatConfigurationCredentialsAccessToken',
    'SourceZendeskChatConfigurationCredentialsOAuth20',
    'SourceZendeskSellConfiguration',
    'SourceZendeskSunshineConfiguration',
    'SourceZendeskSunshineConfigurationCredentials',
    'SourceZendeskSunshineConfigurationCredentialsApiToken',
    'SourceZendeskSunshineConfigurationCredentialsOAuth20',
    'SourceZendeskSupportConfiguration',
    'SourceZendeskSupportConfigurationCredentials',
    'SourceZendeskSupportConfigurationCredentialsApiToken',
    'SourceZendeskSupportConfigurationCredentialsOAuth20',
    'SourceZendeskTalkConfiguration',
    'SourceZendeskTalkConfigurationCredentials',
    'SourceZendeskTalkConfigurationCredentialsApiToken',
    'SourceZendeskTalkConfigurationCredentialsOAuth20',
    'SourceZenloopConfiguration',
    'SourceZohoCrmConfiguration',
    'SourceZoomConfiguration',
    'GetConnectionConfigurationsResult',
    'GetConnectionConfigurationsStreamResult',
    'GetConnectionScheduleResult',
]

@pulumi.output_type
class ConnectionConfigurations(dict):
    def __init__(__self__, *,
                 streams: Optional[Sequence['outputs.ConnectionConfigurationsStream']] = None):
        if streams is not None:
            pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def streams(self) -> Optional[Sequence['outputs.ConnectionConfigurationsStream']]:
        return pulumi.get(self, "streams")


@pulumi.output_type
class ConnectionConfigurationsStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cursorFields":
            suggest = "cursor_fields"
        elif key == "primaryKeys":
            suggest = "primary_keys"
        elif key == "syncMode":
            suggest = "sync_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfigurationsStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfigurationsStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfigurationsStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cursor_fields: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 primary_keys: Optional[Sequence[Sequence[str]]] = None,
                 sync_mode: Optional[str] = None):
        """
        :param Sequence[str] cursor_fields: Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
        :param str name: Not Null
        :param Sequence[Sequence[str]] primary_keys: Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
        :param str sync_mode: must be one of ["full_refresh_overwrite", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
        """
        if cursor_fields is not None:
            pulumi.set(__self__, "cursor_fields", cursor_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if sync_mode is not None:
            pulumi.set(__self__, "sync_mode", sync_mode)

    @property
    @pulumi.getter(name="cursorFields")
    def cursor_fields(self) -> Optional[Sequence[str]]:
        """
        Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
        """
        return pulumi.get(self, "cursor_fields")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Not Null
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[Sequence[Sequence[str]]]:
        """
        Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
        """
        return pulumi.get(self, "primary_keys")

    @property
    @pulumi.getter(name="syncMode")
    def sync_mode(self) -> Optional[str]:
        """
        must be one of ["full_refresh_overwrite", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
        """
        return pulumi.get(self, "sync_mode")


@pulumi.output_type
class ConnectionSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicTiming":
            suggest = "basic_timing"
        elif key == "cronExpression":
            suggest = "cron_expression"
        elif key == "scheduleType":
            suggest = "schedule_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_timing: Optional[str] = None,
                 cron_expression: Optional[str] = None,
                 schedule_type: Optional[str] = None):
        """
        :param str schedule_type: Not Null; must be one of ["manual", "cron"]
        """
        if basic_timing is not None:
            pulumi.set(__self__, "basic_timing", basic_timing)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if schedule_type is not None:
            pulumi.set(__self__, "schedule_type", schedule_type)

    @property
    @pulumi.getter(name="basicTiming")
    def basic_timing(self) -> Optional[str]:
        return pulumi.get(self, "basic_timing")

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[str]:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> Optional[str]:
        """
        Not Null; must be one of ["manual", "cron"]
        """
        return pulumi.get(self, "schedule_type")


@pulumi.output_type
class DestinationAstraConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "omitRawText":
            suggest = "omit_raw_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding: 'outputs.DestinationAstraConfigurationEmbedding',
                 indexing: 'outputs.DestinationAstraConfigurationIndexing',
                 processing: 'outputs.DestinationAstraConfigurationProcessing',
                 omit_raw_text: Optional[bool] = None):
        """
        :param 'DestinationAstraConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationAstraConfigurationIndexingArgs' indexing: Astra DB gives developers the APIs, real-time data and ecosystem integrations to put accurate RAG and Gen AI apps with fewer hallucinations in production.
        :param bool omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationAstraConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationAstraConfigurationIndexing':
        """
        Astra DB gives developers the APIs, real-time data and ecosystem integrations to put accurate RAG and Gen AI apps with fewer hallucinations in production.
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationAstraConfigurationProcessing':
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[bool]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")


@pulumi.output_type
class DestinationAstraConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureOpenAi":
            suggest = "azure_open_ai"
        elif key == "openAi":
            suggest = "open_ai"
        elif key == "openAiCompatible":
            suggest = "open_ai_compatible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_open_ai: Optional['outputs.DestinationAstraConfigurationEmbeddingAzureOpenAi'] = None,
                 cohere: Optional['outputs.DestinationAstraConfigurationEmbeddingCohere'] = None,
                 fake: Optional['outputs.DestinationAstraConfigurationEmbeddingFake'] = None,
                 open_ai: Optional['outputs.DestinationAstraConfigurationEmbeddingOpenAi'] = None,
                 open_ai_compatible: Optional['outputs.DestinationAstraConfigurationEmbeddingOpenAiCompatible'] = None):
        """
        :param 'DestinationAstraConfigurationEmbeddingAzureOpenAiArgs' azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationAstraConfigurationEmbeddingCohereArgs' cohere: Use the Cohere API to embed text.
        :param 'DestinationAstraConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationAstraConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationAstraConfigurationEmbeddingOpenAiCompatibleArgs' open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional['outputs.DestinationAstraConfigurationEmbeddingAzureOpenAi']:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @property
    @pulumi.getter
    def cohere(self) -> Optional['outputs.DestinationAstraConfigurationEmbeddingCohere']:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationAstraConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationAstraConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional['outputs.DestinationAstraConfigurationEmbeddingOpenAiCompatible']:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")


@pulumi.output_type
class DestinationAstraConfigurationEmbeddingAzureOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBase":
            suggest = "api_base"
        elif key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationEmbeddingAzureOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_base: str,
                 deployment: str,
                 openai_key: str):
        """
        :param str api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> str:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationAstraConfigurationEmbeddingCohere(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereKey":
            suggest = "cohere_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationEmbeddingCohere. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationEmbeddingCohere.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationEmbeddingCohere.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_key: str):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> str:
        return pulumi.get(self, "cohere_key")


@pulumi.output_type
class DestinationAstraConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationAstraConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationAstraConfigurationEmbeddingOpenAiCompatible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "modelName":
            suggest = "model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationEmbeddingOpenAiCompatible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 dimensions: int,
                 api_key: Optional[str] = None,
                 model_name: Optional[str] = None):
        """
        :param str base_url: The base URL for your OpenAI-compatible service
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str api_key: Default: ""
        :param str model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class DestinationAstraConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "astraDbAppToken":
            suggest = "astra_db_app_token"
        elif key == "astraDbEndpoint":
            suggest = "astra_db_endpoint"
        elif key == "astraDbKeyspace":
            suggest = "astra_db_keyspace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 astra_db_app_token: str,
                 astra_db_endpoint: str,
                 astra_db_keyspace: str,
                 collection: str):
        """
        :param str astra_db_app_token: The application token authorizes a user to connect to a specific Astra DB database. It is created when the user clicks the Generate Token button on the Overview tab of the Database page in the Astra UI.
        :param str astra_db_endpoint: The endpoint specifies which Astra DB database queries are sent to. It can be copied from the Database Details section of the Overview tab of the Database page in the Astra UI.
        :param str astra_db_keyspace: Keyspaces (or Namespaces) serve as containers for organizing data within a database. You can create a new keyspace uisng the Data Explorer tab in the Astra UI. The keyspace default_keyspace is created for you when you create a Vector Database in Astra DB.
        :param str collection: Collections hold data. They are analagous to tables in traditional Cassandra terminology. This tool will create the collection with the provided name automatically if it does not already exist. Alternatively, you can create one thorugh the Data Explorer tab in the Astra UI.
        """
        pulumi.set(__self__, "astra_db_app_token", astra_db_app_token)
        pulumi.set(__self__, "astra_db_endpoint", astra_db_endpoint)
        pulumi.set(__self__, "astra_db_keyspace", astra_db_keyspace)
        pulumi.set(__self__, "collection", collection)

    @property
    @pulumi.getter(name="astraDbAppToken")
    def astra_db_app_token(self) -> str:
        """
        The application token authorizes a user to connect to a specific Astra DB database. It is created when the user clicks the Generate Token button on the Overview tab of the Database page in the Astra UI.
        """
        return pulumi.get(self, "astra_db_app_token")

    @property
    @pulumi.getter(name="astraDbEndpoint")
    def astra_db_endpoint(self) -> str:
        """
        The endpoint specifies which Astra DB database queries are sent to. It can be copied from the Database Details section of the Overview tab of the Database page in the Astra UI.
        """
        return pulumi.get(self, "astra_db_endpoint")

    @property
    @pulumi.getter(name="astraDbKeyspace")
    def astra_db_keyspace(self) -> str:
        """
        Keyspaces (or Namespaces) serve as containers for organizing data within a database. You can create a new keyspace uisng the Data Explorer tab in the Astra UI. The keyspace default_keyspace is created for you when you create a Vector Database in Astra DB.
        """
        return pulumi.get(self, "astra_db_keyspace")

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        Collections hold data. They are analagous to tables in traditional Cassandra terminology. This tool will create the collection with the provided name automatically if it does not already exist. Alternatively, you can create one thorugh the Data Explorer tab in the Astra UI.
        """
        return pulumi.get(self, "collection")


@pulumi.output_type
class DestinationAstraConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"
        elif key == "fieldNameMappings":
            suggest = "field_name_mappings"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "textSplitter":
            suggest = "text_splitter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 chunk_overlap: Optional[int] = None,
                 field_name_mappings: Optional[Sequence['outputs.DestinationAstraConfigurationProcessingFieldNameMapping']] = None,
                 metadata_fields: Optional[Sequence[str]] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 text_splitter: Optional['outputs.DestinationAstraConfigurationProcessingTextSplitter'] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param Sequence['DestinationAstraConfigurationProcessingFieldNameMappingArgs'] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param 'DestinationAstraConfigurationProcessingTextSplitterArgs' text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[Sequence['outputs.DestinationAstraConfigurationProcessingFieldNameMapping']]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional['outputs.DestinationAstraConfigurationProcessingTextSplitter']:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")


@pulumi.output_type
class DestinationAstraConfigurationProcessingFieldNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromField":
            suggest = "from_field"
        elif key == "toField":
            suggest = "to_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationProcessingFieldNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_field: str,
                 to_field: str):
        """
        :param str from_field: The field name in the source
        :param str to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> str:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> str:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")


@pulumi.output_type
class DestinationAstraConfigurationProcessingTextSplitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byMarkdownHeader":
            suggest = "by_markdown_header"
        elif key == "byProgrammingLanguage":
            suggest = "by_programming_language"
        elif key == "bySeparator":
            suggest = "by_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationProcessingTextSplitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationProcessingTextSplitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationProcessingTextSplitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_markdown_header: Optional['outputs.DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader'] = None,
                 by_programming_language: Optional['outputs.DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguage'] = None,
                 by_separator: Optional['outputs.DestinationAstraConfigurationProcessingTextSplitterBySeparator'] = None):
        """
        :param 'DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeaderArgs' by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param 'DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguageArgs' by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param 'DestinationAstraConfigurationProcessingTextSplitterBySeparatorArgs' by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional['outputs.DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader']:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional['outputs.DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguage']:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional['outputs.DestinationAstraConfigurationProcessingTextSplitterBySeparator']:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")


@pulumi.output_type
class DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitLevel":
            suggest = "split_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_level: Optional[int] = None):
        """
        :param int split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[int]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")


@pulumi.output_type
class DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguage(dict):
    def __init__(__self__, *,
                 language: str):
        """
        :param str language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> str:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class DestinationAstraConfigurationProcessingTextSplitterBySeparator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepSeparator":
            suggest = "keep_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAstraConfigurationProcessingTextSplitterBySeparator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAstraConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAstraConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_separator: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param bool keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param Sequence[str] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[bool]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")


@pulumi.output_type
class DestinationAwsDatalakeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "lakeformationDatabaseName":
            suggest = "lakeformation_database_name"
        elif key == "awsAccountId":
            suggest = "aws_account_id"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"
        elif key == "glueCatalogFloatAsDecimal":
            suggest = "glue_catalog_float_as_decimal"
        elif key == "lakeformationDatabaseDefaultTagKey":
            suggest = "lakeformation_database_default_tag_key"
        elif key == "lakeformationDatabaseDefaultTagValues":
            suggest = "lakeformation_database_default_tag_values"
        elif key == "lakeformationGovernedTables":
            suggest = "lakeformation_governed_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 credentials: 'outputs.DestinationAwsDatalakeConfigurationCredentials',
                 lakeformation_database_name: str,
                 aws_account_id: Optional[str] = None,
                 bucket_prefix: Optional[str] = None,
                 format: Optional['outputs.DestinationAwsDatalakeConfigurationFormat'] = None,
                 glue_catalog_float_as_decimal: Optional[bool] = None,
                 lakeformation_database_default_tag_key: Optional[str] = None,
                 lakeformation_database_default_tag_values: Optional[str] = None,
                 lakeformation_governed_tables: Optional[bool] = None,
                 partitioning: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str bucket_name: The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        :param 'DestinationAwsDatalakeConfigurationCredentialsArgs' credentials: Choose How to Authenticate to AWS.
        :param str lakeformation_database_name: The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
        :param str aws_account_id: target aws account id
        :param str bucket_prefix: S3 prefix
        :param 'DestinationAwsDatalakeConfigurationFormatArgs' format: Format of the data output.
        :param bool glue_catalog_float_as_decimal: Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source. Default: false
        :param str lakeformation_database_default_tag_key: Add a default tag key to databases created by this destination
        :param str lakeformation_database_default_tag_values: Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
        :param bool lakeformation_governed_tables: Whether to create tables as LF governed tables. Default: false
        :param str partitioning: Partition data by cursor fields when a cursor field is a date. must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]; Default: "NO PARTITIONING"
        :param str region: The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "lakeformation_database_name", lakeformation_database_name)
        if aws_account_id is not None:
            pulumi.set(__self__, "aws_account_id", aws_account_id)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if glue_catalog_float_as_decimal is not None:
            pulumi.set(__self__, "glue_catalog_float_as_decimal", glue_catalog_float_as_decimal)
        if lakeformation_database_default_tag_key is not None:
            pulumi.set(__self__, "lakeformation_database_default_tag_key", lakeformation_database_default_tag_key)
        if lakeformation_database_default_tag_values is not None:
            pulumi.set(__self__, "lakeformation_database_default_tag_values", lakeformation_database_default_tag_values)
        if lakeformation_governed_tables is not None:
            pulumi.set(__self__, "lakeformation_governed_tables", lakeformation_governed_tables)
        if partitioning is not None:
            pulumi.set(__self__, "partitioning", partitioning)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.DestinationAwsDatalakeConfigurationCredentials':
        """
        Choose How to Authenticate to AWS.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="lakeformationDatabaseName")
    def lakeformation_database_name(self) -> str:
        """
        The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
        """
        return pulumi.get(self, "lakeformation_database_name")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> Optional[str]:
        """
        target aws account id
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        """
        S3 prefix
        """
        return pulumi.get(self, "bucket_prefix")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.DestinationAwsDatalakeConfigurationFormat']:
        """
        Format of the data output.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="glueCatalogFloatAsDecimal")
    def glue_catalog_float_as_decimal(self) -> Optional[bool]:
        """
        Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source. Default: false
        """
        return pulumi.get(self, "glue_catalog_float_as_decimal")

    @property
    @pulumi.getter(name="lakeformationDatabaseDefaultTagKey")
    def lakeformation_database_default_tag_key(self) -> Optional[str]:
        """
        Add a default tag key to databases created by this destination
        """
        return pulumi.get(self, "lakeformation_database_default_tag_key")

    @property
    @pulumi.getter(name="lakeformationDatabaseDefaultTagValues")
    def lakeformation_database_default_tag_values(self) -> Optional[str]:
        """
        Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
        """
        return pulumi.get(self, "lakeformation_database_default_tag_values")

    @property
    @pulumi.getter(name="lakeformationGovernedTables")
    def lakeformation_governed_tables(self) -> Optional[bool]:
        """
        Whether to create tables as LF governed tables. Default: false
        """
        return pulumi.get(self, "lakeformation_governed_tables")

    @property
    @pulumi.getter
    def partitioning(self) -> Optional[str]:
        """
        Partition data by cursor fields when a cursor field is a date. must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]; Default: "NO PARTITIONING"
        """
        return pulumi.get(self, "partitioning")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class DestinationAwsDatalakeConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamRole":
            suggest = "iam_role"
        elif key == "iamUser":
            suggest = "iam_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_role: Optional['outputs.DestinationAwsDatalakeConfigurationCredentialsIamRole'] = None,
                 iam_user: Optional['outputs.DestinationAwsDatalakeConfigurationCredentialsIamUser'] = None):
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if iam_user is not None:
            pulumi.set(__self__, "iam_user", iam_user)

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional['outputs.DestinationAwsDatalakeConfigurationCredentialsIamRole']:
        return pulumi.get(self, "iam_role")

    @property
    @pulumi.getter(name="iamUser")
    def iam_user(self) -> Optional['outputs.DestinationAwsDatalakeConfigurationCredentialsIamUser']:
        return pulumi.get(self, "iam_user")


@pulumi.output_type
class DestinationAwsDatalakeConfigurationCredentialsIamRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfigurationCredentialsIamRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfigurationCredentialsIamRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfigurationCredentialsIamRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        """
        :param str role_arn: Will assume this role to write data to s3
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        Will assume this role to write data to s3
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class DestinationAwsDatalakeConfigurationCredentialsIamUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfigurationCredentialsIamUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfigurationCredentialsIamUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfigurationCredentialsIamUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: str,
                 aws_secret_access_key: str):
        """
        :param str aws_access_key_id: AWS User Access Key Id
        :param str aws_secret_access_key: Secret Access Key
        """
        pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> str:
        """
        AWS User Access Key Id
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> str:
        """
        Secret Access Key
        """
        return pulumi.get(self, "aws_secret_access_key")


@pulumi.output_type
class DestinationAwsDatalakeConfigurationFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonLinesNewlineDelimitedJson":
            suggest = "json_lines_newline_delimited_json"
        elif key == "parquetColumnarStorage":
            suggest = "parquet_columnar_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfigurationFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfigurationFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfigurationFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_lines_newline_delimited_json: Optional['outputs.DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson'] = None,
                 parquet_columnar_storage: Optional['outputs.DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage'] = None):
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)
        if parquet_columnar_storage is not None:
            pulumi.set(__self__, "parquet_columnar_storage", parquet_columnar_storage)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional['outputs.DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson']:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @property
    @pulumi.getter(name="parquetColumnarStorage")
    def parquet_columnar_storage(self) -> Optional['outputs.DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage']:
        return pulumi.get(self, "parquet_columnar_storage")


@pulumi.output_type
class DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionCodec":
            suggest = "compression_codec"
        elif key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_codec: Optional[str] = None,
                 format_type: Optional[str] = None):
        """
        :param str compression_codec: The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "GZIP"]; Default: "UNCOMPRESSED"
        :param str format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[str]:
        """
        The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "GZIP"]; Default: "UNCOMPRESSED"
        """
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionCodec":
            suggest = "compression_codec"
        elif key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_codec: Optional[str] = None,
                 format_type: Optional[str] = None):
        """
        :param str compression_codec: The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "ZSTD"]; Default: "SNAPPY"
        :param str format_type: must be one of ["Parquet"]; Default: "Parquet"
        """
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[str]:
        """
        The compression algorithm used to compress data. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "ZSTD"]; Default: "SNAPPY"
        """
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["Parquet"]; Default: "Parquet"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationAzureBlobStorageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorageAccountKey":
            suggest = "azure_blob_storage_account_key"
        elif key == "azureBlobStorageAccountName":
            suggest = "azure_blob_storage_account_name"
        elif key == "azureBlobStorageContainerName":
            suggest = "azure_blob_storage_container_name"
        elif key == "azureBlobStorageEndpointDomainName":
            suggest = "azure_blob_storage_endpoint_domain_name"
        elif key == "azureBlobStorageOutputBufferSize":
            suggest = "azure_blob_storage_output_buffer_size"
        elif key == "azureBlobStorageSpillSize":
            suggest = "azure_blob_storage_spill_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAzureBlobStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAzureBlobStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAzureBlobStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage_account_key: str,
                 azure_blob_storage_account_name: str,
                 format: 'outputs.DestinationAzureBlobStorageConfigurationFormat',
                 azure_blob_storage_container_name: Optional[str] = None,
                 azure_blob_storage_endpoint_domain_name: Optional[str] = None,
                 azure_blob_storage_output_buffer_size: Optional[int] = None,
                 azure_blob_storage_spill_size: Optional[int] = None):
        """
        :param str azure_blob_storage_account_key: The Azure blob storage account key.
        :param str azure_blob_storage_account_name: The account's name of the Azure Blob Storage.
        :param 'DestinationAzureBlobStorageConfigurationFormatArgs' format: Output data format
        :param str azure_blob_storage_container_name: The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
        :param str azure_blob_storage_endpoint_domain_name: This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        :param int azure_blob_storage_output_buffer_size: The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure. Default: 5
        :param int azure_blob_storage_spill_size: The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable. Default: 500
        """
        pulumi.set(__self__, "azure_blob_storage_account_key", azure_blob_storage_account_key)
        pulumi.set(__self__, "azure_blob_storage_account_name", azure_blob_storage_account_name)
        pulumi.set(__self__, "format", format)
        if azure_blob_storage_container_name is not None:
            pulumi.set(__self__, "azure_blob_storage_container_name", azure_blob_storage_container_name)
        if azure_blob_storage_endpoint_domain_name is not None:
            pulumi.set(__self__, "azure_blob_storage_endpoint_domain_name", azure_blob_storage_endpoint_domain_name)
        if azure_blob_storage_output_buffer_size is not None:
            pulumi.set(__self__, "azure_blob_storage_output_buffer_size", azure_blob_storage_output_buffer_size)
        if azure_blob_storage_spill_size is not None:
            pulumi.set(__self__, "azure_blob_storage_spill_size", azure_blob_storage_spill_size)

    @property
    @pulumi.getter(name="azureBlobStorageAccountKey")
    def azure_blob_storage_account_key(self) -> str:
        """
        The Azure blob storage account key.
        """
        return pulumi.get(self, "azure_blob_storage_account_key")

    @property
    @pulumi.getter(name="azureBlobStorageAccountName")
    def azure_blob_storage_account_name(self) -> str:
        """
        The account's name of the Azure Blob Storage.
        """
        return pulumi.get(self, "azure_blob_storage_account_name")

    @property
    @pulumi.getter
    def format(self) -> 'outputs.DestinationAzureBlobStorageConfigurationFormat':
        """
        Output data format
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="azureBlobStorageContainerName")
    def azure_blob_storage_container_name(self) -> Optional[str]:
        """
        The name of the Azure blob storage container. If not exists - will be created automatically. May be empty, then will be created automatically airbytecontainer+timestamp
        """
        return pulumi.get(self, "azure_blob_storage_container_name")

    @property
    @pulumi.getter(name="azureBlobStorageEndpointDomainName")
    def azure_blob_storage_endpoint_domain_name(self) -> Optional[str]:
        """
        This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        """
        return pulumi.get(self, "azure_blob_storage_endpoint_domain_name")

    @property
    @pulumi.getter(name="azureBlobStorageOutputBufferSize")
    def azure_blob_storage_output_buffer_size(self) -> Optional[int]:
        """
        The amount of megabytes to buffer for the output stream to Azure. This will impact memory footprint on workers, but may need adjustment for performance and appropriate block size in Azure. Default: 5
        """
        return pulumi.get(self, "azure_blob_storage_output_buffer_size")

    @property
    @pulumi.getter(name="azureBlobStorageSpillSize")
    def azure_blob_storage_spill_size(self) -> Optional[int]:
        """
        The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable. Default: 500
        """
        return pulumi.get(self, "azure_blob_storage_spill_size")


@pulumi.output_type
class DestinationAzureBlobStorageConfigurationFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvCommaSeparatedValues":
            suggest = "csv_comma_separated_values"
        elif key == "jsonLinesNewlineDelimitedJson":
            suggest = "json_lines_newline_delimited_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationAzureBlobStorageConfigurationFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationAzureBlobStorageConfigurationFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationAzureBlobStorageConfigurationFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_comma_separated_values: Optional['outputs.DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValues'] = None,
                 json_lines_newline_delimited_json: Optional['outputs.DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJson'] = None):
        if csv_comma_separated_values is not None:
            pulumi.set(__self__, "csv_comma_separated_values", csv_comma_separated_values)
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)

    @property
    @pulumi.getter(name="csvCommaSeparatedValues")
    def csv_comma_separated_values(self) -> Optional['outputs.DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValues']:
        return pulumi.get(self, "csv_comma_separated_values")

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional['outputs.DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJson']:
        return pulumi.get(self, "json_lines_newline_delimited_json")


@pulumi.output_type
class DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValues(dict):
    def __init__(__self__, *,
                 flattening: Optional[str] = None):
        """
        :param str flattening: Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)

    @property
    @pulumi.getter
    def flattening(self) -> Optional[str]:
        """
        Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")


@pulumi.output_type
class DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJson(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationBigqueryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"
        elif key == "datasetLocation":
            suggest = "dataset_location"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "bigQueryClientBufferSizeMb":
            suggest = "big_query_client_buffer_size_mb"
        elif key == "credentialsJson":
            suggest = "credentials_json"
        elif key == "disableTypeDedupe":
            suggest = "disable_type_dedupe"
        elif key == "loadingMethod":
            suggest = "loading_method"
        elif key == "rawDataDataset":
            suggest = "raw_data_dataset"
        elif key == "transformationPriority":
            suggest = "transformation_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationBigqueryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationBigqueryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationBigqueryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: str,
                 dataset_location: str,
                 project_id: str,
                 big_query_client_buffer_size_mb: Optional[int] = None,
                 credentials_json: Optional[str] = None,
                 disable_type_dedupe: Optional[bool] = None,
                 loading_method: Optional['outputs.DestinationBigqueryConfigurationLoadingMethod'] = None,
                 raw_data_dataset: Optional[str] = None,
                 transformation_priority: Optional[str] = None):
        """
        :param str dataset_id: The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more <a href="https://cloud.google.com/bigquery/docs/datasets#create-dataset">here</a>.
        :param str dataset_location: The location of the dataset. Warning: Changes made after creation will not be applied. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>. must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "europe-west12", "me-central1", "me-central2", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-south1", "us-west1", "us-west2", "us-west3", "us-west4"]
        :param str project_id: The GCP project ID for the project containing the target BigQuery dataset. Read more <a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">here</a>.
        :param int big_query_client_buffer_size_mb: Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more <a href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html">here</a>. Default: 15
        :param str credentials_json: The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/bigquery#service-account-key">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        :param bool disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param 'DestinationBigqueryConfigurationLoadingMethodArgs' loading_method: The way data will be uploaded to BigQuery.
        :param str raw_data_dataset: The dataset to write raw tables into (default: airbyte_internal)
        :param str transformation_priority: Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type <a href="https://cloud.google.com/bigquery/docs/running-queries#queries">here</a>. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries don’t count towards your concurrent rate limit. Read more about batch queries <a href="https://cloud.google.com/bigquery/docs/running-queries#batch">here</a>. The default "interactive" value is used if not set explicitly. must be one of ["interactive", "batch"]; Default: "interactive"
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "dataset_location", dataset_location)
        pulumi.set(__self__, "project_id", project_id)
        if big_query_client_buffer_size_mb is not None:
            pulumi.set(__self__, "big_query_client_buffer_size_mb", big_query_client_buffer_size_mb)
        if credentials_json is not None:
            pulumi.set(__self__, "credentials_json", credentials_json)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if loading_method is not None:
            pulumi.set(__self__, "loading_method", loading_method)
        if raw_data_dataset is not None:
            pulumi.set(__self__, "raw_data_dataset", raw_data_dataset)
        if transformation_priority is not None:
            pulumi.set(__self__, "transformation_priority", transformation_priority)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more <a href="https://cloud.google.com/bigquery/docs/datasets#create-dataset">here</a>.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="datasetLocation")
    def dataset_location(self) -> str:
        """
        The location of the dataset. Warning: Changes made after creation will not be applied. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>. must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "europe-west12", "me-central1", "me-central2", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-south1", "us-west1", "us-west2", "us-west3", "us-west4"]
        """
        return pulumi.get(self, "dataset_location")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project ID for the project containing the target BigQuery dataset. Read more <a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">here</a>.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="bigQueryClientBufferSizeMb")
    def big_query_client_buffer_size_mb(self) -> Optional[int]:
        """
        Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more <a href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html">here</a>. Default: 15
        """
        return pulumi.get(self, "big_query_client_buffer_size_mb")

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> Optional[str]:
        """
        The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/bigquery#service-account-key">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        """
        return pulumi.get(self, "credentials_json")

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[bool]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @property
    @pulumi.getter(name="loadingMethod")
    def loading_method(self) -> Optional['outputs.DestinationBigqueryConfigurationLoadingMethod']:
        """
        The way data will be uploaded to BigQuery.
        """
        return pulumi.get(self, "loading_method")

    @property
    @pulumi.getter(name="rawDataDataset")
    def raw_data_dataset(self) -> Optional[str]:
        """
        The dataset to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_dataset")

    @property
    @pulumi.getter(name="transformationPriority")
    def transformation_priority(self) -> Optional[str]:
        """
        Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type <a href="https://cloud.google.com/bigquery/docs/running-queries#queries">here</a>. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries don’t count towards your concurrent rate limit. Read more about batch queries <a href="https://cloud.google.com/bigquery/docs/running-queries#batch">here</a>. The default "interactive" value is used if not set explicitly. must be one of ["interactive", "batch"]; Default: "interactive"
        """
        return pulumi.get(self, "transformation_priority")


@pulumi.output_type
class DestinationBigqueryConfigurationLoadingMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsStaging":
            suggest = "gcs_staging"
        elif key == "standardInserts":
            suggest = "standard_inserts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationBigqueryConfigurationLoadingMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationBigqueryConfigurationLoadingMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationBigqueryConfigurationLoadingMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcs_staging: Optional['outputs.DestinationBigqueryConfigurationLoadingMethodGcsStaging'] = None,
                 standard_inserts: Optional['outputs.DestinationBigqueryConfigurationLoadingMethodStandardInserts'] = None):
        """
        :param 'DestinationBigqueryConfigurationLoadingMethodGcsStagingArgs' gcs_staging: <i>(recommended)</i> Writes large batches of records to a file, uploads the file to GCS, then uses COPY INTO to load your data into BigQuery. Provides best-in-class speed, reliability and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.
        :param 'DestinationBigqueryConfigurationLoadingMethodStandardInsertsArgs' standard_inserts: <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use GCS staging.
        """
        if gcs_staging is not None:
            pulumi.set(__self__, "gcs_staging", gcs_staging)
        if standard_inserts is not None:
            pulumi.set(__self__, "standard_inserts", standard_inserts)

    @property
    @pulumi.getter(name="gcsStaging")
    def gcs_staging(self) -> Optional['outputs.DestinationBigqueryConfigurationLoadingMethodGcsStaging']:
        """
        <i>(recommended)</i> Writes large batches of records to a file, uploads the file to GCS, then uses COPY INTO to load your data into BigQuery. Provides best-in-class speed, reliability and scalability. Read more about GCS Staging <a href="https://docs.airbyte.com/integrations/destinations/bigquery#gcs-staging">here</a>.
        """
        return pulumi.get(self, "gcs_staging")

    @property
    @pulumi.getter(name="standardInserts")
    def standard_inserts(self) -> Optional['outputs.DestinationBigqueryConfigurationLoadingMethodStandardInserts']:
        """
        <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use GCS staging.
        """
        return pulumi.get(self, "standard_inserts")


@pulumi.output_type
class DestinationBigqueryConfigurationLoadingMethodGcsStaging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsBucketName":
            suggest = "gcs_bucket_name"
        elif key == "gcsBucketPath":
            suggest = "gcs_bucket_path"
        elif key == "keepFilesInGcsBucket":
            suggest = "keep_files_in_gcs_bucket"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationBigqueryConfigurationLoadingMethodGcsStaging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationBigqueryConfigurationLoadingMethodGcsStaging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationBigqueryConfigurationLoadingMethodGcsStaging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: 'outputs.DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential',
                 gcs_bucket_name: str,
                 gcs_bucket_path: str,
                 keep_files_in_gcs_bucket: Optional[str] = None):
        """
        :param 'DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialArgs' credential: An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        :param str gcs_bucket_name: The name of the GCS bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        :param str gcs_bucket_path: Directory under the GCS bucket where data will be written.
        :param str keep_files_in_gcs_bucket: This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly. must be one of ["Delete all tmp files from GCS", "Keep all tmp files in GCS"]; Default: "Delete all tmp files from GCS"
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "gcs_bucket_name", gcs_bucket_name)
        pulumi.set(__self__, "gcs_bucket_path", gcs_bucket_path)
        if keep_files_in_gcs_bucket is not None:
            pulumi.set(__self__, "keep_files_in_gcs_bucket", keep_files_in_gcs_bucket)

    @property
    @pulumi.getter
    def credential(self) -> 'outputs.DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential':
        """
        An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter(name="gcsBucketName")
    def gcs_bucket_name(self) -> str:
        """
        The name of the GCS bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        """
        return pulumi.get(self, "gcs_bucket_name")

    @property
    @pulumi.getter(name="gcsBucketPath")
    def gcs_bucket_path(self) -> str:
        """
        Directory under the GCS bucket where data will be written.
        """
        return pulumi.get(self, "gcs_bucket_path")

    @property
    @pulumi.getter(name="keepFilesInGcsBucket")
    def keep_files_in_gcs_bucket(self) -> Optional[str]:
        """
        This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly. must be one of ["Delete all tmp files from GCS", "Keep all tmp files in GCS"]; Default: "Delete all tmp files from GCS"
        """
        return pulumi.get(self, "keep_files_in_gcs_bucket")


@pulumi.output_type
class DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacKey":
            suggest = "hmac_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hmac_key: Optional['outputs.DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey'] = None):
        if hmac_key is not None:
            pulumi.set(__self__, "hmac_key", hmac_key)

    @property
    @pulumi.getter(name="hmacKey")
    def hmac_key(self) -> Optional['outputs.DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey']:
        return pulumi.get(self, "hmac_key")


@pulumi.output_type
class DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacKeyAccessId":
            suggest = "hmac_key_access_id"
        elif key == "hmacKeySecret":
            suggest = "hmac_key_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hmac_key_access_id: str,
                 hmac_key_secret: str):
        """
        :param str hmac_key_access_id: HMAC key access ID. When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long.
        :param str hmac_key_secret: The corresponding secret for the access ID. It is a 40-character base-64 encoded string.
        """
        pulumi.set(__self__, "hmac_key_access_id", hmac_key_access_id)
        pulumi.set(__self__, "hmac_key_secret", hmac_key_secret)

    @property
    @pulumi.getter(name="hmacKeyAccessId")
    def hmac_key_access_id(self) -> str:
        """
        HMAC key access ID. When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long.
        """
        return pulumi.get(self, "hmac_key_access_id")

    @property
    @pulumi.getter(name="hmacKeySecret")
    def hmac_key_secret(self) -> str:
        """
        The corresponding secret for the access ID. It is a 40-character base-64 encoded string.
        """
        return pulumi.get(self, "hmac_key_secret")


@pulumi.output_type
class DestinationBigqueryConfigurationLoadingMethodStandardInserts(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationClickhouseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationClickhouseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationClickhouseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationClickhouseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 raw_data_schema: Optional[str] = None,
                 tunnel_method: Optional['outputs.DestinationClickhouseConfigurationTunnelMethod'] = None):
        """
        :param str database: Name of the database.
        :param str host: Hostname of the database.
        :param str username: Username to use to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: Password associated with the username.
        :param int port: HTTP port of the database. Default: 8123
        :param str raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param 'DestinationClickhouseConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        HTTP port of the database. Default: 8123
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationClickhouseConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationClickhouseConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationClickhouseConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationClickhouseConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationClickhouseConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationClickhouseConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationClickhouseConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationClickhouseConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationConvexConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "deploymentUrl":
            suggest = "deployment_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationConvexConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationConvexConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationConvexConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 deployment_url: str):
        """
        :param str access_key: API access key used to send data to a Convex deployment.
        :param str deployment_url: URL of the Convex deployment that is the destination
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "deployment_url", deployment_url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        API access key used to send data to a Convex deployment.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="deploymentUrl")
    def deployment_url(self) -> str:
        """
        URL of the Convex deployment that is the destination
        """
        return pulumi.get(self, "deployment_url")


@pulumi.output_type
class DestinationDatabricksConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "databricksHttpPath":
            suggest = "databricks_http_path"
        elif key == "databricksPersonalAccessToken":
            suggest = "databricks_personal_access_token"
        elif key == "databricksServerHostname":
            suggest = "databricks_server_hostname"
        elif key == "acceptTerms":
            suggest = "accept_terms"
        elif key == "databricksPort":
            suggest = "databricks_port"
        elif key == "enableSchemaEvolution":
            suggest = "enable_schema_evolution"
        elif key == "purgeStagingData":
            suggest = "purge_staging_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDatabricksConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDatabricksConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDatabricksConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: 'outputs.DestinationDatabricksConfigurationDataSource',
                 databricks_http_path: str,
                 databricks_personal_access_token: str,
                 databricks_server_hostname: str,
                 accept_terms: Optional[bool] = None,
                 database: Optional[str] = None,
                 databricks_port: Optional[str] = None,
                 enable_schema_evolution: Optional[bool] = None,
                 purge_staging_data: Optional[bool] = None,
                 schema: Optional[str] = None):
        """
        :param 'DestinationDatabricksConfigurationDataSourceArgs' data_source: Storage on which the delta lake is built.
        :param str databricks_http_path: Databricks Cluster HTTP Path.
        :param str databricks_personal_access_token: Databricks Personal Access Token for making authenticated requests.
        :param str databricks_server_hostname: Databricks Cluster Server Hostname.
        :param bool accept_terms: You must agree to the Databricks JDBC Driver <a href="https://databricks.com/jdbc-odbc-driver-license">Terms & Conditions</a> to use this connector. Default: false
        :param str database: The name of the catalog. If not specified otherwise, the "hive_metastore" will be used.
        :param str databricks_port: Databricks Cluster Port. Default: "443"
        :param bool enable_schema_evolution: Support schema evolution for all streams. If "false", the connector might fail when a stream's schema changes. Default: false
        :param bool purge_staging_data: Default to 'true'. Switch it to 'false' for debugging purpose. Default: true
        :param str schema: The default schema tables are written. If not specified otherwise, the "default" will be used. Default: "default"
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "databricks_http_path", databricks_http_path)
        pulumi.set(__self__, "databricks_personal_access_token", databricks_personal_access_token)
        pulumi.set(__self__, "databricks_server_hostname", databricks_server_hostname)
        if accept_terms is not None:
            pulumi.set(__self__, "accept_terms", accept_terms)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if databricks_port is not None:
            pulumi.set(__self__, "databricks_port", databricks_port)
        if enable_schema_evolution is not None:
            pulumi.set(__self__, "enable_schema_evolution", enable_schema_evolution)
        if purge_staging_data is not None:
            pulumi.set(__self__, "purge_staging_data", purge_staging_data)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> 'outputs.DestinationDatabricksConfigurationDataSource':
        """
        Storage on which the delta lake is built.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="databricksHttpPath")
    def databricks_http_path(self) -> str:
        """
        Databricks Cluster HTTP Path.
        """
        return pulumi.get(self, "databricks_http_path")

    @property
    @pulumi.getter(name="databricksPersonalAccessToken")
    def databricks_personal_access_token(self) -> str:
        """
        Databricks Personal Access Token for making authenticated requests.
        """
        return pulumi.get(self, "databricks_personal_access_token")

    @property
    @pulumi.getter(name="databricksServerHostname")
    def databricks_server_hostname(self) -> str:
        """
        Databricks Cluster Server Hostname.
        """
        return pulumi.get(self, "databricks_server_hostname")

    @property
    @pulumi.getter(name="acceptTerms")
    def accept_terms(self) -> Optional[bool]:
        """
        You must agree to the Databricks JDBC Driver <a href="https://databricks.com/jdbc-odbc-driver-license">Terms & Conditions</a> to use this connector. Default: false
        """
        return pulumi.get(self, "accept_terms")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        """
        The name of the catalog. If not specified otherwise, the "hive_metastore" will be used.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databricksPort")
    def databricks_port(self) -> Optional[str]:
        """
        Databricks Cluster Port. Default: "443"
        """
        return pulumi.get(self, "databricks_port")

    @property
    @pulumi.getter(name="enableSchemaEvolution")
    def enable_schema_evolution(self) -> Optional[bool]:
        """
        Support schema evolution for all streams. If "false", the connector might fail when a stream's schema changes. Default: false
        """
        return pulumi.get(self, "enable_schema_evolution")

    @property
    @pulumi.getter(name="purgeStagingData")
    def purge_staging_data(self) -> Optional[bool]:
        """
        Default to 'true'. Switch it to 'false' for debugging purpose. Default: true
        """
        return pulumi.get(self, "purge_staging_data")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema tables are written. If not specified otherwise, the "default" will be used. Default: "default"
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class DestinationDatabricksConfigurationDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amazonS3":
            suggest = "amazon_s3"
        elif key == "azureBlobStorage":
            suggest = "azure_blob_storage"
        elif key == "recommendedManagedTables":
            suggest = "recommended_managed_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDatabricksConfigurationDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDatabricksConfigurationDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDatabricksConfigurationDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amazon_s3: Optional['outputs.DestinationDatabricksConfigurationDataSourceAmazonS3'] = None,
                 azure_blob_storage: Optional['outputs.DestinationDatabricksConfigurationDataSourceAzureBlobStorage'] = None,
                 recommended_managed_tables: Optional['outputs.DestinationDatabricksConfigurationDataSourceRecommendedManagedTables'] = None):
        if amazon_s3 is not None:
            pulumi.set(__self__, "amazon_s3", amazon_s3)
        if azure_blob_storage is not None:
            pulumi.set(__self__, "azure_blob_storage", azure_blob_storage)
        if recommended_managed_tables is not None:
            pulumi.set(__self__, "recommended_managed_tables", recommended_managed_tables)

    @property
    @pulumi.getter(name="amazonS3")
    def amazon_s3(self) -> Optional['outputs.DestinationDatabricksConfigurationDataSourceAmazonS3']:
        return pulumi.get(self, "amazon_s3")

    @property
    @pulumi.getter(name="azureBlobStorage")
    def azure_blob_storage(self) -> Optional['outputs.DestinationDatabricksConfigurationDataSourceAzureBlobStorage']:
        return pulumi.get(self, "azure_blob_storage")

    @property
    @pulumi.getter(name="recommendedManagedTables")
    def recommended_managed_tables(self) -> Optional['outputs.DestinationDatabricksConfigurationDataSourceRecommendedManagedTables']:
        return pulumi.get(self, "recommended_managed_tables")


@pulumi.output_type
class DestinationDatabricksConfigurationDataSourceAmazonS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3AccessKeyId":
            suggest = "s3_access_key_id"
        elif key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3BucketPath":
            suggest = "s3_bucket_path"
        elif key == "s3SecretAccessKey":
            suggest = "s3_secret_access_key"
        elif key == "fileNamePattern":
            suggest = "file_name_pattern"
        elif key == "s3BucketRegion":
            suggest = "s3_bucket_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDatabricksConfigurationDataSourceAmazonS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDatabricksConfigurationDataSourceAmazonS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDatabricksConfigurationDataSourceAmazonS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_access_key_id: str,
                 s3_bucket_name: str,
                 s3_bucket_path: str,
                 s3_secret_access_key: str,
                 file_name_pattern: Optional[str] = None,
                 s3_bucket_region: Optional[str] = None):
        """
        :param str s3_access_key_id: The Access Key Id granting allow one to access the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket.
        :param str s3_bucket_name: The name of the S3 bucket to use for intermittent staging of the data.
        :param str s3_bucket_path: The directory under the S3 bucket where data will be written.
        :param str s3_secret_access_key: The corresponding secret to the above access key id.
        :param str file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param str s3_bucket_region: The region of the S3 staging bucket to use if utilising a copy strategy. must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]; Default: ""
        """
        pulumi.set(__self__, "s3_access_key_id", s3_access_key_id)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        pulumi.set(__self__, "s3_secret_access_key", s3_secret_access_key)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)

    @property
    @pulumi.getter(name="s3AccessKeyId")
    def s3_access_key_id(self) -> str:
        """
        The Access Key Id granting allow one to access the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket.
        """
        return pulumi.get(self, "s3_access_key_id")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> str:
        """
        The name of the S3 bucket to use for intermittent staging of the data.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> str:
        """
        The directory under the S3 bucket where data will be written.
        """
        return pulumi.get(self, "s3_bucket_path")

    @property
    @pulumi.getter(name="s3SecretAccessKey")
    def s3_secret_access_key(self) -> str:
        """
        The corresponding secret to the above access key id.
        """
        return pulumi.get(self, "s3_secret_access_key")

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[str]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[str]:
        """
        The region of the S3 staging bucket to use if utilising a copy strategy. must be one of ["", "us-east-1", "us-east-2", "us-west-1", "us-west-2", "af-south-1", "ap-east-1", "ap-south-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-southeast-1", "ap-southeast-2", "ca-central-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-north-1", "eu-south-1", "eu-west-1", "eu-west-2", "eu-west-3", "sa-east-1", "me-south-1", "us-gov-east-1", "us-gov-west-1"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")


@pulumi.output_type
class DestinationDatabricksConfigurationDataSourceAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorageAccountName":
            suggest = "azure_blob_storage_account_name"
        elif key == "azureBlobStorageContainerName":
            suggest = "azure_blob_storage_container_name"
        elif key == "azureBlobStorageSasToken":
            suggest = "azure_blob_storage_sas_token"
        elif key == "azureBlobStorageEndpointDomainName":
            suggest = "azure_blob_storage_endpoint_domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDatabricksConfigurationDataSourceAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDatabricksConfigurationDataSourceAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDatabricksConfigurationDataSourceAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage_account_name: str,
                 azure_blob_storage_container_name: str,
                 azure_blob_storage_sas_token: str,
                 azure_blob_storage_endpoint_domain_name: Optional[str] = None):
        """
        :param str azure_blob_storage_account_name: The account's name of the Azure Blob Storage.
        :param str azure_blob_storage_container_name: The name of the Azure blob storage container.
        :param str azure_blob_storage_sas_token: Shared access signature (SAS) token to grant limited access to objects in your storage account.
        :param str azure_blob_storage_endpoint_domain_name: This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        """
        pulumi.set(__self__, "azure_blob_storage_account_name", azure_blob_storage_account_name)
        pulumi.set(__self__, "azure_blob_storage_container_name", azure_blob_storage_container_name)
        pulumi.set(__self__, "azure_blob_storage_sas_token", azure_blob_storage_sas_token)
        if azure_blob_storage_endpoint_domain_name is not None:
            pulumi.set(__self__, "azure_blob_storage_endpoint_domain_name", azure_blob_storage_endpoint_domain_name)

    @property
    @pulumi.getter(name="azureBlobStorageAccountName")
    def azure_blob_storage_account_name(self) -> str:
        """
        The account's name of the Azure Blob Storage.
        """
        return pulumi.get(self, "azure_blob_storage_account_name")

    @property
    @pulumi.getter(name="azureBlobStorageContainerName")
    def azure_blob_storage_container_name(self) -> str:
        """
        The name of the Azure blob storage container.
        """
        return pulumi.get(self, "azure_blob_storage_container_name")

    @property
    @pulumi.getter(name="azureBlobStorageSasToken")
    def azure_blob_storage_sas_token(self) -> str:
        """
        Shared access signature (SAS) token to grant limited access to objects in your storage account.
        """
        return pulumi.get(self, "azure_blob_storage_sas_token")

    @property
    @pulumi.getter(name="azureBlobStorageEndpointDomainName")
    def azure_blob_storage_endpoint_domain_name(self) -> Optional[str]:
        """
        This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example. Default: "blob.core.windows.net"
        """
        return pulumi.get(self, "azure_blob_storage_endpoint_domain_name")


@pulumi.output_type
class DestinationDatabricksConfigurationDataSourceRecommendedManagedTables(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationDevNullConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testDestination":
            suggest = "test_destination"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDevNullConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDevNullConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDevNullConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 test_destination: 'outputs.DestinationDevNullConfigurationTestDestination'):
        """
        :param 'DestinationDevNullConfigurationTestDestinationArgs' test_destination: The type of destination to be used
        """
        pulumi.set(__self__, "test_destination", test_destination)

    @property
    @pulumi.getter(name="testDestination")
    def test_destination(self) -> 'outputs.DestinationDevNullConfigurationTestDestination':
        """
        The type of destination to be used
        """
        return pulumi.get(self, "test_destination")


@pulumi.output_type
class DestinationDevNullConfigurationTestDestination(dict):
    def __init__(__self__, *,
                 silent: Optional['outputs.DestinationDevNullConfigurationTestDestinationSilent'] = None):
        if silent is not None:
            pulumi.set(__self__, "silent", silent)

    @property
    @pulumi.getter
    def silent(self) -> Optional['outputs.DestinationDevNullConfigurationTestDestinationSilent']:
        return pulumi.get(self, "silent")


@pulumi.output_type
class DestinationDevNullConfigurationTestDestinationSilent(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationDuckdbConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPath":
            suggest = "destination_path"
        elif key == "motherduckApiKey":
            suggest = "motherduck_api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDuckdbConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDuckdbConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDuckdbConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_path: str,
                 motherduck_api_key: Optional[str] = None,
                 schema: Optional[str] = None):
        """
        :param str destination_path: Path to the .duckdb file, or the text 'md:' to connect to MotherDuck. The file will be placed inside that local mount. For more information check out our <a href="https://docs.airbyte.io/integrations/destinations/duckdb">docs</a>
        :param str motherduck_api_key: API key to use for authentication to a MotherDuck database.
        :param str schema: Database schema name, default for duckdb is 'main'.
        """
        pulumi.set(__self__, "destination_path", destination_path)
        if motherduck_api_key is not None:
            pulumi.set(__self__, "motherduck_api_key", motherduck_api_key)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> str:
        """
        Path to the .duckdb file, or the text 'md:' to connect to MotherDuck. The file will be placed inside that local mount. For more information check out our <a href="https://docs.airbyte.io/integrations/destinations/duckdb">docs</a>
        """
        return pulumi.get(self, "destination_path")

    @property
    @pulumi.getter(name="motherduckApiKey")
    def motherduck_api_key(self) -> Optional[str]:
        """
        API key to use for authentication to a MotherDuck database.
        """
        return pulumi.get(self, "motherduck_api_key")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        Database schema name, default for duckdb is 'main'.
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class DestinationDynamodbConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "dynamodbTableNamePrefix":
            suggest = "dynamodb_table_name_prefix"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "dynamodbEndpoint":
            suggest = "dynamodb_endpoint"
        elif key == "dynamodbRegion":
            suggest = "dynamodb_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationDynamodbConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationDynamodbConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationDynamodbConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: str,
                 dynamodb_table_name_prefix: str,
                 secret_access_key: str,
                 dynamodb_endpoint: Optional[str] = None,
                 dynamodb_region: Optional[str] = None):
        """
        :param str access_key_id: The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
        :param str dynamodb_table_name_prefix: The prefix to use when naming DynamoDB tables.
        :param str secret_access_key: The corresponding secret to the access key id.
        :param str dynamodb_endpoint: This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty). Default: ""
        :param str dynamodb_region: The region of the DynamoDB. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "dynamodb_table_name_prefix", dynamodb_table_name_prefix)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if dynamodb_endpoint is not None:
            pulumi.set(__self__, "dynamodb_endpoint", dynamodb_endpoint)
        if dynamodb_region is not None:
            pulumi.set(__self__, "dynamodb_region", dynamodb_region)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="dynamodbTableNamePrefix")
    def dynamodb_table_name_prefix(self) -> str:
        """
        The prefix to use when naming DynamoDB tables.
        """
        return pulumi.get(self, "dynamodb_table_name_prefix")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        The corresponding secret to the access key id.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="dynamodbEndpoint")
    def dynamodb_endpoint(self) -> Optional[str]:
        """
        This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty). Default: ""
        """
        return pulumi.get(self, "dynamodb_endpoint")

    @property
    @pulumi.getter(name="dynamodbRegion")
    def dynamodb_region(self) -> Optional[str]:
        """
        The region of the DynamoDB. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "dynamodb_region")


@pulumi.output_type
class DestinationElasticsearchConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticationMethod":
            suggest = "authentication_method"
        elif key == "caCertificate":
            suggest = "ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationElasticsearchConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationElasticsearchConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationElasticsearchConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 authentication_method: Optional['outputs.DestinationElasticsearchConfigurationAuthenticationMethod'] = None,
                 ca_certificate: Optional[str] = None,
                 upsert: Optional[bool] = None):
        """
        :param str endpoint: The full url of the Elasticsearch server
        :param 'DestinationElasticsearchConfigurationAuthenticationMethodArgs' authentication_method: The type of authentication to be used
        :param str ca_certificate: CA certificate
        :param bool upsert: If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys. Default: true
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if authentication_method is not None:
            pulumi.set(__self__, "authentication_method", authentication_method)
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The full url of the Elasticsearch server
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="authenticationMethod")
    def authentication_method(self) -> Optional['outputs.DestinationElasticsearchConfigurationAuthenticationMethod']:
        """
        The type of authentication to be used
        """
        return pulumi.get(self, "authentication_method")

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[str]:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys. Default: true
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class DestinationElasticsearchConfigurationAuthenticationMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeySecret":
            suggest = "api_key_secret"
        elif key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationElasticsearchConfigurationAuthenticationMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationElasticsearchConfigurationAuthenticationMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationElasticsearchConfigurationAuthenticationMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_secret: Optional['outputs.DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret'] = None,
                 username_password: Optional['outputs.DestinationElasticsearchConfigurationAuthenticationMethodUsernamePassword'] = None):
        """
        :param 'DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecretArgs' api_key_secret: Use a api key and secret combination to authenticate
        :param 'DestinationElasticsearchConfigurationAuthenticationMethodUsernamePasswordArgs' username_password: Basic auth header with a username and password
        """
        if api_key_secret is not None:
            pulumi.set(__self__, "api_key_secret", api_key_secret)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="apiKeySecret")
    def api_key_secret(self) -> Optional['outputs.DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret']:
        """
        Use a api key and secret combination to authenticate
        """
        return pulumi.get(self, "api_key_secret")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.DestinationElasticsearchConfigurationAuthenticationMethodUsernamePassword']:
        """
        Basic auth header with a username and password
        """
        return pulumi.get(self, "username_password")


@pulumi.output_type
class DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyId":
            suggest = "api_key_id"
        elif key == "apiKeySecret":
            suggest = "api_key_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_id: str,
                 api_key_secret: str):
        """
        :param str api_key_id: The Key ID to used when accessing an enterprise Elasticsearch instance.
        :param str api_key_secret: The secret associated with the API Key ID.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "api_key_secret", api_key_secret)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        """
        The Key ID to used when accessing an enterprise Elasticsearch instance.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter(name="apiKeySecret")
    def api_key_secret(self) -> str:
        """
        The secret associated with the API Key ID.
        """
        return pulumi.get(self, "api_key_secret")


@pulumi.output_type
class DestinationElasticsearchConfigurationAuthenticationMethodUsernamePassword(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Basic auth password to access a secure Elasticsearch server
        :param str username: Basic auth username to access a secure Elasticsearch server
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Basic auth password to access a secure Elasticsearch server
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Basic auth username to access a secure Elasticsearch server
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DestinationFirestoreConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "credentialsJson":
            suggest = "credentials_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationFirestoreConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationFirestoreConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationFirestoreConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 credentials_json: Optional[str] = None):
        """
        :param str project_id: The GCP project ID for the project containing the target BigQuery dataset.
        :param str credentials_json: The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.io/integrations/destinations/firestore">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        """
        pulumi.set(__self__, "project_id", project_id)
        if credentials_json is not None:
            pulumi.set(__self__, "credentials_json", credentials_json)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project ID for the project containing the target BigQuery dataset.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> Optional[str]:
        """
        The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.io/integrations/destinations/firestore">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
        """
        return pulumi.get(self, "credentials_json")


@pulumi.output_type
class DestinationGcsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsBucketName":
            suggest = "gcs_bucket_name"
        elif key == "gcsBucketPath":
            suggest = "gcs_bucket_path"
        elif key == "gcsBucketRegion":
            suggest = "gcs_bucket_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential: 'outputs.DestinationGcsConfigurationCredential',
                 format: 'outputs.DestinationGcsConfigurationFormat',
                 gcs_bucket_name: str,
                 gcs_bucket_path: str,
                 gcs_bucket_region: Optional[str] = None):
        """
        :param 'DestinationGcsConfigurationCredentialArgs' credential: An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        :param 'DestinationGcsConfigurationFormatArgs' format: Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
        :param str gcs_bucket_name: You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        :param str gcs_bucket_path: GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
        :param str gcs_bucket_region: Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>. must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]; Default: "us"
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "gcs_bucket_name", gcs_bucket_name)
        pulumi.set(__self__, "gcs_bucket_path", gcs_bucket_path)
        if gcs_bucket_region is not None:
            pulumi.set(__self__, "gcs_bucket_region", gcs_bucket_region)

    @property
    @pulumi.getter
    def credential(self) -> 'outputs.DestinationGcsConfigurationCredential':
        """
        An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
        """
        return pulumi.get(self, "credential")

    @property
    @pulumi.getter
    def format(self) -> 'outputs.DestinationGcsConfigurationFormat':
        """
        Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="gcsBucketName")
    def gcs_bucket_name(self) -> str:
        """
        You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
        """
        return pulumi.get(self, "gcs_bucket_name")

    @property
    @pulumi.getter(name="gcsBucketPath")
    def gcs_bucket_path(self) -> str:
        """
        GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
        """
        return pulumi.get(self, "gcs_bucket_path")

    @property
    @pulumi.getter(name="gcsBucketRegion")
    def gcs_bucket_region(self) -> Optional[str]:
        """
        Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>. must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]; Default: "us"
        """
        return pulumi.get(self, "gcs_bucket_region")


@pulumi.output_type
class DestinationGcsConfigurationCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacKey":
            suggest = "hmac_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hmac_key: Optional['outputs.DestinationGcsConfigurationCredentialHmacKey'] = None):
        if hmac_key is not None:
            pulumi.set(__self__, "hmac_key", hmac_key)

    @property
    @pulumi.getter(name="hmacKey")
    def hmac_key(self) -> Optional['outputs.DestinationGcsConfigurationCredentialHmacKey']:
        return pulumi.get(self, "hmac_key")


@pulumi.output_type
class DestinationGcsConfigurationCredentialHmacKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacKeyAccessId":
            suggest = "hmac_key_access_id"
        elif key == "hmacKeySecret":
            suggest = "hmac_key_secret"
        elif key == "credentialType":
            suggest = "credential_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationCredentialHmacKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationCredentialHmacKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationCredentialHmacKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hmac_key_access_id: str,
                 hmac_key_secret: str,
                 credential_type: Optional[str] = None):
        """
        :param str hmac_key_access_id: When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
        :param str hmac_key_secret: The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
        :param str credential_type: must be one of ["HMAC_KEY"]; Default: "HMAC_KEY"
        """
        pulumi.set(__self__, "hmac_key_access_id", hmac_key_access_id)
        pulumi.set(__self__, "hmac_key_secret", hmac_key_secret)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)

    @property
    @pulumi.getter(name="hmacKeyAccessId")
    def hmac_key_access_id(self) -> str:
        """
        When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
        """
        return pulumi.get(self, "hmac_key_access_id")

    @property
    @pulumi.getter(name="hmacKeySecret")
    def hmac_key_secret(self) -> str:
        """
        The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
        """
        return pulumi.get(self, "hmac_key_secret")

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[str]:
        """
        must be one of ["HMAC_KEY"]; Default: "HMAC_KEY"
        """
        return pulumi.get(self, "credential_type")


@pulumi.output_type
class DestinationGcsConfigurationFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroApacheAvro":
            suggest = "avro_apache_avro"
        elif key == "csvCommaSeparatedValues":
            suggest = "csv_comma_separated_values"
        elif key == "jsonLinesNewlineDelimitedJson":
            suggest = "json_lines_newline_delimited_json"
        elif key == "parquetColumnarStorage":
            suggest = "parquet_columnar_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_apache_avro: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvro'] = None,
                 csv_comma_separated_values: Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValues'] = None,
                 json_lines_newline_delimited_json: Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson'] = None,
                 parquet_columnar_storage: Optional['outputs.DestinationGcsConfigurationFormatParquetColumnarStorage'] = None):
        if avro_apache_avro is not None:
            pulumi.set(__self__, "avro_apache_avro", avro_apache_avro)
        if csv_comma_separated_values is not None:
            pulumi.set(__self__, "csv_comma_separated_values", csv_comma_separated_values)
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)
        if parquet_columnar_storage is not None:
            pulumi.set(__self__, "parquet_columnar_storage", parquet_columnar_storage)

    @property
    @pulumi.getter(name="avroApacheAvro")
    def avro_apache_avro(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvro']:
        return pulumi.get(self, "avro_apache_avro")

    @property
    @pulumi.getter(name="csvCommaSeparatedValues")
    def csv_comma_separated_values(self) -> Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValues']:
        return pulumi.get(self, "csv_comma_separated_values")

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson']:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @property
    @pulumi.getter(name="parquetColumnarStorage")
    def parquet_columnar_storage(self) -> Optional['outputs.DestinationGcsConfigurationFormatParquetColumnarStorage']:
        return pulumi.get(self, "parquet_columnar_storage")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionCodec":
            suggest = "compression_codec"
        elif key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatAvroApacheAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_codec: 'outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec',
                 format_type: Optional[str] = None):
        """
        :param 'DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecArgs' compression_codec: The compression algorithm used to compress data. Default to no compression.
        :param str format_type: must be one of ["Avro"]; Default: "Avro"
        """
        pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> 'outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec':
        """
        The compression algorithm used to compress data. Default to no compression.
        """
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["Avro"]; Default: "Avro"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bzip2: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2'] = None,
                 deflate: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate'] = None,
                 no_compression: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompression'] = None,
                 snappy: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappy'] = None,
                 xz: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz'] = None,
                 zstandard: Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard'] = None):
        if bzip2 is not None:
            pulumi.set(__self__, "bzip2", bzip2)
        if deflate is not None:
            pulumi.set(__self__, "deflate", deflate)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)
        if snappy is not None:
            pulumi.set(__self__, "snappy", snappy)
        if xz is not None:
            pulumi.set(__self__, "xz", xz)
        if zstandard is not None:
            pulumi.set(__self__, "zstandard", zstandard)

    @property
    @pulumi.getter
    def bzip2(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2']:
        return pulumi.get(self, "bzip2")

    @property
    @pulumi.getter
    def deflate(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate']:
        return pulumi.get(self, "deflate")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompression']:
        return pulumi.get(self, "no_compression")

    @property
    @pulumi.getter
    def snappy(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappy']:
        return pulumi.get(self, "snappy")

    @property
    @pulumi.getter
    def xz(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz']:
        return pulumi.get(self, "xz")

    @property
    @pulumi.getter
    def zstandard(self) -> Optional['outputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard']:
        return pulumi.get(self, "zstandard")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2(dict):
    def __init__(__self__, *,
                 codec: Optional[str] = None):
        """
        :param str codec: must be one of ["bzip2"]; Default: "bzip2"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["bzip2"]; Default: "bzip2"
        """
        return pulumi.get(self, "codec")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 compression_level: Optional[int] = None):
        """
        :param str codec: must be one of ["Deflate"]; Default: "Deflate"
        :param int compression_level: 0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["Deflate"]; Default: "Deflate"
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        return pulumi.get(self, "compression_level")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompression(dict):
    def __init__(__self__, *,
                 codec: Optional[str] = None):
        """
        :param str codec: must be one of ["no compression"]; Default: "no compression"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["no compression"]; Default: "no compression"
        """
        return pulumi.get(self, "codec")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappy(dict):
    def __init__(__self__, *,
                 codec: Optional[str] = None):
        """
        :param str codec: must be one of ["snappy"]; Default: "snappy"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["snappy"]; Default: "snappy"
        """
        return pulumi.get(self, "codec")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 compression_level: Optional[int] = None):
        """
        :param str codec: must be one of ["xz"]; Default: "xz"
        :param int compression_level: The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["xz"]; Default: "xz"
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        return pulumi.get(self, "compression_level")


@pulumi.output_type
class DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "includeChecksum":
            suggest = "include_checksum"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 compression_level: Optional[int] = None,
                 include_checksum: Optional[bool] = None):
        """
        :param str codec: must be one of ["zstandard"]; Default: "zstandard"
        :param int compression_level: Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        :param bool include_checksum: If true, include a checksum with each data block. Default: false
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if include_checksum is not None:
            pulumi.set(__self__, "include_checksum", include_checksum)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["zstandard"]; Default: "zstandard"
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter(name="includeChecksum")
    def include_checksum(self) -> Optional[bool]:
        """
        If true, include a checksum with each data block. Default: false
        """
        return pulumi.get(self, "include_checksum")


@pulumi.output_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatCsvCommaSeparatedValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression: Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression'] = None,
                 flattening: Optional[str] = None,
                 format_type: Optional[str] = None):
        """
        :param 'DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionArgs' compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        :param str flattening: Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        :param str format_type: must be one of ["CSV"]; Default: "CSV"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression']:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def flattening(self) -> Optional[str]:
        """
        Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["CSV"]; Default: "CSV"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gzip: Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip'] = None,
                 no_compression: Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression'] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip']:
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression']:
        return pulumi.get(self, "no_compression")


@pulumi.output_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression: Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression'] = None,
                 format_type: Optional[str] = None):
        """
        :param 'DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs' compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        :param str format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression']:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gzip: Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip'] = None,
                 no_compression: Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression'] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip']:
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression']:
        return pulumi.get(self, "no_compression")


@pulumi.output_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationGcsConfigurationFormatParquetColumnarStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSizeMb":
            suggest = "block_size_mb"
        elif key == "compressionCodec":
            suggest = "compression_codec"
        elif key == "dictionaryEncoding":
            suggest = "dictionary_encoding"
        elif key == "dictionaryPageSizeKb":
            suggest = "dictionary_page_size_kb"
        elif key == "formatType":
            suggest = "format_type"
        elif key == "maxPaddingSizeMb":
            suggest = "max_padding_size_mb"
        elif key == "pageSizeKb":
            suggest = "page_size_kb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGcsConfigurationFormatParquetColumnarStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGcsConfigurationFormatParquetColumnarStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGcsConfigurationFormatParquetColumnarStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size_mb: Optional[int] = None,
                 compression_codec: Optional[str] = None,
                 dictionary_encoding: Optional[bool] = None,
                 dictionary_page_size_kb: Optional[int] = None,
                 format_type: Optional[str] = None,
                 max_padding_size_mb: Optional[int] = None,
                 page_size_kb: Optional[int] = None):
        """
        :param int block_size_mb: This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        :param str compression_codec: The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        :param bool dictionary_encoding: Default: true. Default: true
        :param int dictionary_page_size_kb: There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        :param str format_type: must be one of ["Parquet"]; Default: "Parquet"
        :param int max_padding_size_mb: Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        :param int page_size_kb: The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        if block_size_mb is not None:
            pulumi.set(__self__, "block_size_mb", block_size_mb)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if dictionary_encoding is not None:
            pulumi.set(__self__, "dictionary_encoding", dictionary_encoding)
        if dictionary_page_size_kb is not None:
            pulumi.set(__self__, "dictionary_page_size_kb", dictionary_page_size_kb)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)
        if max_padding_size_mb is not None:
            pulumi.set(__self__, "max_padding_size_mb", max_padding_size_mb)
        if page_size_kb is not None:
            pulumi.set(__self__, "page_size_kb", page_size_kb)

    @property
    @pulumi.getter(name="blockSizeMb")
    def block_size_mb(self) -> Optional[int]:
        """
        This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        """
        return pulumi.get(self, "block_size_mb")

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[str]:
        """
        The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        """
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="dictionaryEncoding")
    def dictionary_encoding(self) -> Optional[bool]:
        """
        Default: true. Default: true
        """
        return pulumi.get(self, "dictionary_encoding")

    @property
    @pulumi.getter(name="dictionaryPageSizeKb")
    def dictionary_page_size_kb(self) -> Optional[int]:
        """
        There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "dictionary_page_size_kb")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["Parquet"]; Default: "Parquet"
        """
        return pulumi.get(self, "format_type")

    @property
    @pulumi.getter(name="maxPaddingSizeMb")
    def max_padding_size_mb(self) -> Optional[int]:
        """
        Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        """
        return pulumi.get(self, "max_padding_size_mb")

    @property
    @pulumi.getter(name="pageSizeKb")
    def page_size_kb(self) -> Optional[int]:
        """
        The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "page_size_kb")


@pulumi.output_type
class DestinationGoogleSheetsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spreadsheetId":
            suggest = "spreadsheet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGoogleSheetsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGoogleSheetsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGoogleSheetsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.DestinationGoogleSheetsConfigurationCredentials',
                 spreadsheet_id: str):
        """
        :param 'DestinationGoogleSheetsConfigurationCredentialsArgs' credentials: Google API Credentials for connecting to Google Sheets and Google Drive APIs
        :param str spreadsheet_id: The link to your spreadsheet. See <a href='https://docs.airbyte.com/integrations/destinations/google-sheets#sheetlink'>this guide</a> for more details.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "spreadsheet_id", spreadsheet_id)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.DestinationGoogleSheetsConfigurationCredentials':
        """
        Google API Credentials for connecting to Google Sheets and Google Drive APIs
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="spreadsheetId")
    def spreadsheet_id(self) -> str:
        """
        The link to your spreadsheet. See <a href='https://docs.airbyte.com/integrations/destinations/google-sheets#sheetlink'>this guide</a> for more details.
        """
        return pulumi.get(self, "spreadsheet_id")


@pulumi.output_type
class DestinationGoogleSheetsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationGoogleSheetsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationGoogleSheetsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationGoogleSheetsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The Client ID of your Google Sheets developer application.
        :param str client_secret: The Client Secret of your Google Sheets developer application.
        :param str refresh_token: The token for obtaining new access token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Google Sheets developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Google Sheets developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token for obtaining new access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class DestinationLangchainConfiguration(dict):
    def __init__(__self__, *,
                 embedding: 'outputs.DestinationLangchainConfigurationEmbedding',
                 indexing: 'outputs.DestinationLangchainConfigurationIndexing',
                 processing: 'outputs.DestinationLangchainConfigurationProcessing'):
        """
        :param 'DestinationLangchainConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationLangchainConfigurationIndexingArgs' indexing: Indexing configuration
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationLangchainConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationLangchainConfigurationIndexing':
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationLangchainConfigurationProcessing':
        return pulumi.get(self, "processing")


@pulumi.output_type
class DestinationLangchainConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openAi":
            suggest = "open_ai"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fake: Optional['outputs.DestinationLangchainConfigurationEmbeddingFake'] = None,
                 open_ai: Optional['outputs.DestinationLangchainConfigurationEmbeddingOpenAi'] = None):
        """
        :param 'DestinationLangchainConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationLangchainConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationLangchainConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationLangchainConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")


@pulumi.output_type
class DestinationLangchainConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationLangchainConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationLangchainConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chromaLocalPersistance":
            suggest = "chroma_local_persistance"
        elif key == "docArrayHnswSearch":
            suggest = "doc_array_hnsw_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chroma_local_persistance: Optional['outputs.DestinationLangchainConfigurationIndexingChromaLocalPersistance'] = None,
                 doc_array_hnsw_search: Optional['outputs.DestinationLangchainConfigurationIndexingDocArrayHnswSearch'] = None,
                 pinecone: Optional['outputs.DestinationLangchainConfigurationIndexingPinecone'] = None):
        """
        :param 'DestinationLangchainConfigurationIndexingChromaLocalPersistanceArgs' chroma_local_persistance: Chroma is a popular vector store that can be used to store and retrieve embeddings. It will build its index in memory and persist it to disk by the end of the sync.
        :param 'DestinationLangchainConfigurationIndexingDocArrayHnswSearchArgs' doc_array_hnsw_search: DocArrayHnswSearch is a lightweight Document Index implementation provided by Docarray that runs fully locally and is best suited for small- to medium-sized datasets. It stores vectors on disk in hnswlib, and stores all other data in SQLite.
        :param 'DestinationLangchainConfigurationIndexingPineconeArgs' pinecone: Pinecone is a popular vector store that can be used to store and retrieve embeddings. It is a managed service and can also be queried from outside of langchain.
        """
        if chroma_local_persistance is not None:
            pulumi.set(__self__, "chroma_local_persistance", chroma_local_persistance)
        if doc_array_hnsw_search is not None:
            pulumi.set(__self__, "doc_array_hnsw_search", doc_array_hnsw_search)
        if pinecone is not None:
            pulumi.set(__self__, "pinecone", pinecone)

    @property
    @pulumi.getter(name="chromaLocalPersistance")
    def chroma_local_persistance(self) -> Optional['outputs.DestinationLangchainConfigurationIndexingChromaLocalPersistance']:
        """
        Chroma is a popular vector store that can be used to store and retrieve embeddings. It will build its index in memory and persist it to disk by the end of the sync.
        """
        return pulumi.get(self, "chroma_local_persistance")

    @property
    @pulumi.getter(name="docArrayHnswSearch")
    def doc_array_hnsw_search(self) -> Optional['outputs.DestinationLangchainConfigurationIndexingDocArrayHnswSearch']:
        """
        DocArrayHnswSearch is a lightweight Document Index implementation provided by Docarray that runs fully locally and is best suited for small- to medium-sized datasets. It stores vectors on disk in hnswlib, and stores all other data in SQLite.
        """
        return pulumi.get(self, "doc_array_hnsw_search")

    @property
    @pulumi.getter
    def pinecone(self) -> Optional['outputs.DestinationLangchainConfigurationIndexingPinecone']:
        """
        Pinecone is a popular vector store that can be used to store and retrieve embeddings. It is a managed service and can also be queried from outside of langchain.
        """
        return pulumi.get(self, "pinecone")


@pulumi.output_type
class DestinationLangchainConfigurationIndexingChromaLocalPersistance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPath":
            suggest = "destination_path"
        elif key == "collectionName":
            suggest = "collection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationIndexingChromaLocalPersistance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationIndexingChromaLocalPersistance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationIndexingChromaLocalPersistance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_path: str,
                 collection_name: Optional[str] = None):
        """
        :param str destination_path: Path to the directory where chroma files will be written. The files will be placed inside that local mount.
        :param str collection_name: Name of the collection to use. Default: "langchain"
        """
        pulumi.set(__self__, "destination_path", destination_path)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> str:
        """
        Path to the directory where chroma files will be written. The files will be placed inside that local mount.
        """
        return pulumi.get(self, "destination_path")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Name of the collection to use. Default: "langchain"
        """
        return pulumi.get(self, "collection_name")


@pulumi.output_type
class DestinationLangchainConfigurationIndexingDocArrayHnswSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPath":
            suggest = "destination_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationIndexingDocArrayHnswSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationIndexingDocArrayHnswSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationIndexingDocArrayHnswSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_path: str):
        """
        :param str destination_path: Path to the directory where hnswlib and meta data files will be written. The files will be placed inside that local mount. All files in the specified destination directory will be deleted on each run.
        """
        pulumi.set(__self__, "destination_path", destination_path)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> str:
        """
        Path to the directory where hnswlib and meta data files will be written. The files will be placed inside that local mount. All files in the specified destination directory will be deleted on each run.
        """
        return pulumi.get(self, "destination_path")


@pulumi.output_type
class DestinationLangchainConfigurationIndexingPinecone(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pineconeEnvironment":
            suggest = "pinecone_environment"
        elif key == "pineconeKey":
            suggest = "pinecone_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationIndexingPinecone. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationIndexingPinecone.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationIndexingPinecone.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 pinecone_environment: str,
                 pinecone_key: str):
        """
        :param str index: Pinecone index to use
        :param str pinecone_environment: Pinecone environment to use
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "pinecone_environment", pinecone_environment)
        pulumi.set(__self__, "pinecone_key", pinecone_key)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Pinecone index to use
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="pineconeEnvironment")
    def pinecone_environment(self) -> str:
        """
        Pinecone environment to use
        """
        return pulumi.get(self, "pinecone_environment")

    @property
    @pulumi.getter(name="pineconeKey")
    def pinecone_key(self) -> str:
        return pulumi.get(self, "pinecone_key")


@pulumi.output_type
class DestinationLangchainConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationLangchainConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationLangchainConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationLangchainConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 text_fields: Sequence[str],
                 chunk_overlap: Optional[int] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. All other fields are passed along as meta fields. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        pulumi.set(__self__, "text_fields", text_fields)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Sequence[str]:
        """
        List of fields in the record that should be used to calculate the embedding. All other fields are passed along as meta fields. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")


@pulumi.output_type
class DestinationMilvusConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "omitRawText":
            suggest = "omit_raw_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding: 'outputs.DestinationMilvusConfigurationEmbedding',
                 indexing: 'outputs.DestinationMilvusConfigurationIndexing',
                 processing: 'outputs.DestinationMilvusConfigurationProcessing',
                 omit_raw_text: Optional[bool] = None):
        """
        :param 'DestinationMilvusConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationMilvusConfigurationIndexingArgs' indexing: Indexing configuration
        :param bool omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationMilvusConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationMilvusConfigurationIndexing':
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationMilvusConfigurationProcessing':
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[bool]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")


@pulumi.output_type
class DestinationMilvusConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureOpenAi":
            suggest = "azure_open_ai"
        elif key == "openAi":
            suggest = "open_ai"
        elif key == "openAiCompatible":
            suggest = "open_ai_compatible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_open_ai: Optional['outputs.DestinationMilvusConfigurationEmbeddingAzureOpenAi'] = None,
                 cohere: Optional['outputs.DestinationMilvusConfigurationEmbeddingCohere'] = None,
                 fake: Optional['outputs.DestinationMilvusConfigurationEmbeddingFake'] = None,
                 open_ai: Optional['outputs.DestinationMilvusConfigurationEmbeddingOpenAi'] = None,
                 open_ai_compatible: Optional['outputs.DestinationMilvusConfigurationEmbeddingOpenAiCompatible'] = None):
        """
        :param 'DestinationMilvusConfigurationEmbeddingAzureOpenAiArgs' azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationMilvusConfigurationEmbeddingCohereArgs' cohere: Use the Cohere API to embed text.
        :param 'DestinationMilvusConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationMilvusConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationMilvusConfigurationEmbeddingOpenAiCompatibleArgs' open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional['outputs.DestinationMilvusConfigurationEmbeddingAzureOpenAi']:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @property
    @pulumi.getter
    def cohere(self) -> Optional['outputs.DestinationMilvusConfigurationEmbeddingCohere']:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationMilvusConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationMilvusConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional['outputs.DestinationMilvusConfigurationEmbeddingOpenAiCompatible']:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")


@pulumi.output_type
class DestinationMilvusConfigurationEmbeddingAzureOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBase":
            suggest = "api_base"
        elif key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationEmbeddingAzureOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_base: str,
                 deployment: str,
                 openai_key: str):
        """
        :param str api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> str:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationMilvusConfigurationEmbeddingCohere(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereKey":
            suggest = "cohere_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationEmbeddingCohere. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationEmbeddingCohere.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationEmbeddingCohere.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_key: str):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> str:
        return pulumi.get(self, "cohere_key")


@pulumi.output_type
class DestinationMilvusConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMilvusConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationMilvusConfigurationEmbeddingOpenAiCompatible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "modelName":
            suggest = "model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationEmbeddingOpenAiCompatible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 dimensions: int,
                 api_key: Optional[str] = None,
                 model_name: Optional[str] = None):
        """
        :param str base_url: The base URL for your OpenAI-compatible service
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str api_key: Default: ""
        :param str model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class DestinationMilvusConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: 'outputs.DestinationMilvusConfigurationIndexingAuth',
                 collection: str,
                 host: str,
                 db: Optional[str] = None,
                 text_field: Optional[str] = None,
                 vector_field: Optional[str] = None):
        """
        :param 'DestinationMilvusConfigurationIndexingAuthArgs' auth: Authentication method
        :param str collection: The collection to load data into
        :param str host: The public endpoint of the Milvus instance.
        :param str db: The database to connect to. Default: ""
        :param str text_field: The field in the entity that contains the embedded text. Default: "text"
        :param str vector_field: The field in the entity that contains the vector. Default: "vector"
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "host", host)
        if db is not None:
            pulumi.set(__self__, "db", db)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)
        if vector_field is not None:
            pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.DestinationMilvusConfigurationIndexingAuth':
        """
        Authentication method
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        The collection to load data into
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The public endpoint of the Milvus instance.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def db(self) -> Optional[str]:
        """
        The database to connect to. Default: ""
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[str]:
        """
        The field in the entity that contains the embedded text. Default: "text"
        """
        return pulumi.get(self, "text_field")

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> Optional[str]:
        """
        The field in the entity that contains the vector. Default: "vector"
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class DestinationMilvusConfigurationIndexingAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "noAuth":
            suggest = "no_auth"
        elif key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationIndexingAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationIndexingAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationIndexingAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.DestinationMilvusConfigurationIndexingAuthApiToken'] = None,
                 no_auth: Optional['outputs.DestinationMilvusConfigurationIndexingAuthNoAuth'] = None,
                 username_password: Optional['outputs.DestinationMilvusConfigurationIndexingAuthUsernamePassword'] = None):
        """
        :param 'DestinationMilvusConfigurationIndexingAuthApiTokenArgs' api_token: Authenticate using an API token (suitable for Zilliz Cloud)
        :param 'DestinationMilvusConfigurationIndexingAuthNoAuthArgs' no_auth: Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        :param 'DestinationMilvusConfigurationIndexingAuthUsernamePasswordArgs' username_password: Authenticate using username and password (suitable for self-managed Milvus clusters)
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.DestinationMilvusConfigurationIndexingAuthApiToken']:
        """
        Authenticate using an API token (suitable for Zilliz Cloud)
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional['outputs.DestinationMilvusConfigurationIndexingAuthNoAuth']:
        """
        Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        """
        return pulumi.get(self, "no_auth")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.DestinationMilvusConfigurationIndexingAuthUsernamePassword']:
        """
        Authenticate using username and password (suitable for self-managed Milvus clusters)
        """
        return pulumi.get(self, "username_password")


@pulumi.output_type
class DestinationMilvusConfigurationIndexingAuthApiToken(dict):
    def __init__(__self__, *,
                 token: str):
        """
        :param str token: API Token for the Milvus instance
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        API Token for the Milvus instance
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class DestinationMilvusConfigurationIndexingAuthNoAuth(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMilvusConfigurationIndexingAuthUsernamePassword(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password for the Milvus instance
        :param str username: Username for the Milvus instance
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for the Milvus instance
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for the Milvus instance
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DestinationMilvusConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"
        elif key == "fieldNameMappings":
            suggest = "field_name_mappings"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "textSplitter":
            suggest = "text_splitter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 chunk_overlap: Optional[int] = None,
                 field_name_mappings: Optional[Sequence['outputs.DestinationMilvusConfigurationProcessingFieldNameMapping']] = None,
                 metadata_fields: Optional[Sequence[str]] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 text_splitter: Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitter'] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param Sequence['DestinationMilvusConfigurationProcessingFieldNameMappingArgs'] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param 'DestinationMilvusConfigurationProcessingTextSplitterArgs' text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[Sequence['outputs.DestinationMilvusConfigurationProcessingFieldNameMapping']]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitter']:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")


@pulumi.output_type
class DestinationMilvusConfigurationProcessingFieldNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromField":
            suggest = "from_field"
        elif key == "toField":
            suggest = "to_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationProcessingFieldNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_field: str,
                 to_field: str):
        """
        :param str from_field: The field name in the source
        :param str to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> str:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> str:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")


@pulumi.output_type
class DestinationMilvusConfigurationProcessingTextSplitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byMarkdownHeader":
            suggest = "by_markdown_header"
        elif key == "byProgrammingLanguage":
            suggest = "by_programming_language"
        elif key == "bySeparator":
            suggest = "by_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationProcessingTextSplitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationProcessingTextSplitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationProcessingTextSplitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_markdown_header: Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader'] = None,
                 by_programming_language: Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguage'] = None,
                 by_separator: Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitterBySeparator'] = None):
        """
        :param 'DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeaderArgs' by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param 'DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguageArgs' by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param 'DestinationMilvusConfigurationProcessingTextSplitterBySeparatorArgs' by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader']:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguage']:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional['outputs.DestinationMilvusConfigurationProcessingTextSplitterBySeparator']:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")


@pulumi.output_type
class DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitLevel":
            suggest = "split_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_level: Optional[int] = None):
        """
        :param int split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[int]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")


@pulumi.output_type
class DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguage(dict):
    def __init__(__self__, *,
                 language: str):
        """
        :param str language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> str:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class DestinationMilvusConfigurationProcessingTextSplitterBySeparator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepSeparator":
            suggest = "keep_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMilvusConfigurationProcessingTextSplitterBySeparator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMilvusConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMilvusConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_separator: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param bool keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param Sequence[str] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[bool]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")


@pulumi.output_type
class DestinationMongodbConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: 'outputs.DestinationMongodbConfigurationAuthType',
                 database: str,
                 instance_type: Optional['outputs.DestinationMongodbConfigurationInstanceType'] = None,
                 tunnel_method: Optional['outputs.DestinationMongodbConfigurationTunnelMethod'] = None):
        """
        :param 'DestinationMongodbConfigurationAuthTypeArgs' auth_type: Authorization type.
        :param str database: Name of the database.
        :param 'DestinationMongodbConfigurationInstanceTypeArgs' instance_type: MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
        :param 'DestinationMongodbConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "database", database)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> 'outputs.DestinationMongodbConfigurationAuthType':
        """
        Authorization type.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional['outputs.DestinationMongodbConfigurationInstanceType']:
        """
        MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationMongodbConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationMongodbConfigurationAuthType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginPassword":
            suggest = "login_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationAuthType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationAuthType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationAuthType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_password: Optional['outputs.DestinationMongodbConfigurationAuthTypeLoginPassword'] = None,
                 none: Optional['outputs.DestinationMongodbConfigurationAuthTypeNone'] = None):
        """
        :param 'DestinationMongodbConfigurationAuthTypeLoginPasswordArgs' login_password: Login/Password.
        :param 'DestinationMongodbConfigurationAuthTypeNoneArgs' none: None.
        """
        if login_password is not None:
            pulumi.set(__self__, "login_password", login_password)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @property
    @pulumi.getter(name="loginPassword")
    def login_password(self) -> Optional['outputs.DestinationMongodbConfigurationAuthTypeLoginPassword']:
        """
        Login/Password.
        """
        return pulumi.get(self, "login_password")

    @property
    @pulumi.getter
    def none(self) -> Optional['outputs.DestinationMongodbConfigurationAuthTypeNone']:
        """
        None.
        """
        return pulumi.get(self, "none")


@pulumi.output_type
class DestinationMongodbConfigurationAuthTypeLoginPassword(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password associated with the username.
        :param str username: Username to use to access the database.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DestinationMongodbConfigurationAuthTypeNone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMongodbConfigurationInstanceType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mongoDbAtlas":
            suggest = "mongo_db_atlas"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "standaloneMongoDbInstance":
            suggest = "standalone_mongo_db_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationInstanceType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationInstanceType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationInstanceType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mongo_db_atlas: Optional['outputs.DestinationMongodbConfigurationInstanceTypeMongoDbAtlas'] = None,
                 replica_set: Optional['outputs.DestinationMongodbConfigurationInstanceTypeReplicaSet'] = None,
                 standalone_mongo_db_instance: Optional['outputs.DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstance'] = None):
        if mongo_db_atlas is not None:
            pulumi.set(__self__, "mongo_db_atlas", mongo_db_atlas)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if standalone_mongo_db_instance is not None:
            pulumi.set(__self__, "standalone_mongo_db_instance", standalone_mongo_db_instance)

    @property
    @pulumi.getter(name="mongoDbAtlas")
    def mongo_db_atlas(self) -> Optional['outputs.DestinationMongodbConfigurationInstanceTypeMongoDbAtlas']:
        return pulumi.get(self, "mongo_db_atlas")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional['outputs.DestinationMongodbConfigurationInstanceTypeReplicaSet']:
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter(name="standaloneMongoDbInstance")
    def standalone_mongo_db_instance(self) -> Optional['outputs.DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstance']:
        return pulumi.get(self, "standalone_mongo_db_instance")


@pulumi.output_type
class DestinationMongodbConfigurationInstanceTypeMongoDbAtlas(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterUrl":
            suggest = "cluster_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationInstanceTypeMongoDbAtlas. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationInstanceTypeMongoDbAtlas.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationInstanceTypeMongoDbAtlas.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_url: str,
                 instance: Optional[str] = None):
        """
        :param str cluster_url: URL of a cluster to connect to.
        :param str instance: must be one of ["atlas"]; Default: "atlas"
        """
        pulumi.set(__self__, "cluster_url", cluster_url)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)

    @property
    @pulumi.getter(name="clusterUrl")
    def cluster_url(self) -> str:
        """
        URL of a cluster to connect to.
        """
        return pulumi.get(self, "cluster_url")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        must be one of ["atlas"]; Default: "atlas"
        """
        return pulumi.get(self, "instance")


@pulumi.output_type
class DestinationMongodbConfigurationInstanceTypeReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverAddresses":
            suggest = "server_addresses"
        elif key == "replicaSet":
            suggest = "replica_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationInstanceTypeReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationInstanceTypeReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationInstanceTypeReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_addresses: str,
                 instance: Optional[str] = None,
                 replica_set: Optional[str] = None):
        """
        :param str server_addresses: The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
        :param str instance: must be one of ["replica"]; Default: "replica"
        :param str replica_set: A replica set name.
        """
        pulumi.set(__self__, "server_addresses", server_addresses)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)

    @property
    @pulumi.getter(name="serverAddresses")
    def server_addresses(self) -> str:
        """
        The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
        """
        return pulumi.get(self, "server_addresses")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        must be one of ["replica"]; Default: "replica"
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[str]:
        """
        A replica set name.
        """
        return pulumi.get(self, "replica_set")


@pulumi.output_type
class DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstance(dict):
    def __init__(__self__, *,
                 host: str,
                 instance: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: The Host of a Mongo database to be replicated.
        :param str instance: must be one of ["standalone"]; Default: "standalone"
        :param int port: The Port of a Mongo database to be replicated. Default: 27017
        """
        pulumi.set(__self__, "host", host)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The Host of a Mongo database to be replicated.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def instance(self) -> Optional[str]:
        """
        must be one of ["standalone"]; Default: "standalone"
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The Port of a Mongo database to be replicated. Default: 27017
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DestinationMongodbConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationMongodbConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationMongodbConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationMongodbConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationMongodbConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationMongodbConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMongodbConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationMssqlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "sslMethod":
            suggest = "ssl_method"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMssqlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMssqlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMssqlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 raw_data_schema: Optional[str] = None,
                 schema: Optional[str] = None,
                 ssl_method: Optional['outputs.DestinationMssqlConfigurationSslMethod'] = None,
                 tunnel_method: Optional['outputs.DestinationMssqlConfigurationTunnelMethod'] = None):
        """
        :param str database: The name of the MSSQL database.
        :param str host: The host name of the MSSQL database.
        :param str username: The username which is used to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: The password associated with this username.
        :param int port: The port of the MSSQL database. Default: 1433
        :param str raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param str schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        :param 'DestinationMssqlConfigurationSslMethodArgs' ssl_method: The encryption method which is used to communicate with the database.
        :param 'DestinationMssqlConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl_method is not None:
            pulumi.set(__self__, "ssl_method", ssl_method)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the MSSQL database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host name of the MSSQL database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of the MSSQL database. Default: 1433
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="sslMethod")
    def ssl_method(self) -> Optional['outputs.DestinationMssqlConfigurationSslMethod']:
        """
        The encryption method which is used to communicate with the database.
        """
        return pulumi.get(self, "ssl_method")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationMssqlConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationMssqlConfigurationSslMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedTrustServerCertificate":
            suggest = "encrypted_trust_server_certificate"
        elif key == "encryptedVerifyCertificate":
            suggest = "encrypted_verify_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMssqlConfigurationSslMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMssqlConfigurationSslMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMssqlConfigurationSslMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_trust_server_certificate: Optional['outputs.DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificate'] = None,
                 encrypted_verify_certificate: Optional['outputs.DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate'] = None):
        """
        :param 'DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs' encrypted_trust_server_certificate: Use the certificate provided by the server without verification. (For testing purposes only!)
        :param 'DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs' encrypted_verify_certificate: Verify and use the certificate provided by the server.
        """
        if encrypted_trust_server_certificate is not None:
            pulumi.set(__self__, "encrypted_trust_server_certificate", encrypted_trust_server_certificate)
        if encrypted_verify_certificate is not None:
            pulumi.set(__self__, "encrypted_verify_certificate", encrypted_verify_certificate)

    @property
    @pulumi.getter(name="encryptedTrustServerCertificate")
    def encrypted_trust_server_certificate(self) -> Optional['outputs.DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificate']:
        """
        Use the certificate provided by the server without verification. (For testing purposes only!)
        """
        return pulumi.get(self, "encrypted_trust_server_certificate")

    @property
    @pulumi.getter(name="encryptedVerifyCertificate")
    def encrypted_verify_certificate(self) -> Optional['outputs.DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate']:
        """
        Verify and use the certificate provided by the server.
        """
        return pulumi.get(self, "encrypted_verify_certificate")


@pulumi.output_type
class DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostNameInCertificate":
            suggest = "host_name_in_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name_in_certificate: Optional[str] = None):
        """
        :param str host_name_in_certificate: Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        if host_name_in_certificate is not None:
            pulumi.set(__self__, "host_name_in_certificate", host_name_in_certificate)

    @property
    @pulumi.getter(name="hostNameInCertificate")
    def host_name_in_certificate(self) -> Optional[str]:
        """
        Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        return pulumi.get(self, "host_name_in_certificate")


@pulumi.output_type
class DestinationMssqlConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMssqlConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMssqlConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMssqlConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationMssqlConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationMssqlConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationMssqlConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationMssqlConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationMssqlConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMssqlConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMssqlConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMssqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMssqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMssqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationMysqlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeDedupe":
            suggest = "disable_type_dedupe"
        elif key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMysqlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMysqlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMysqlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 disable_type_dedupe: Optional[bool] = None,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 raw_data_schema: Optional[str] = None,
                 tunnel_method: Optional['outputs.DestinationMysqlConfigurationTunnelMethod'] = None):
        """
        :param str database: Name of the database.
        :param str host: Hostname of the database.
        :param str username: Username to use to access the database.
        :param bool disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: Password associated with the username.
        :param int port: Port of the database. Default: 3306
        :param str raw_data_schema: The database to write raw tables into
        :param 'DestinationMysqlConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[bool]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database. Default: 3306
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The database to write raw tables into
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationMysqlConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationMysqlConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMysqlConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMysqlConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMysqlConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationMysqlConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationMysqlConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationMysqlConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationMysqlConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationMysqlConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationMysqlConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMysqlConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMysqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMysqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationOracleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOracleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOracleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOracleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 sid: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 raw_data_schema: Optional[str] = None,
                 schema: Optional[str] = None,
                 tunnel_method: Optional['outputs.DestinationOracleConfigurationTunnelMethod'] = None):
        """
        :param str host: The hostname of the database.
        :param str sid: The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
        :param str username: The username to access the database. This user must have CREATE USER privileges in the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: The password associated with the username.
        :param int port: The port of the database. Default: 1521
        :param str raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param str schema: The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema. Default: "airbyte"
        :param 'DestinationOracleConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "sid", sid)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def sid(self) -> str:
        """
        The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
        """
        return pulumi.get(self, "sid")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to access the database. This user must have CREATE USER privileges in the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of the database. Default: 1521
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema. Default: "airbyte"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationOracleConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationOracleConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOracleConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOracleConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOracleConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationOracleConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationOracleConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationOracleConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationOracleConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationOracleConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationOracleConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationOracleConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationOracleConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOracleConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOracleConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOracleConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationOracleConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOracleConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOracleConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOracleConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationPineconeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "omitRawText":
            suggest = "omit_raw_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding: 'outputs.DestinationPineconeConfigurationEmbedding',
                 indexing: 'outputs.DestinationPineconeConfigurationIndexing',
                 processing: 'outputs.DestinationPineconeConfigurationProcessing',
                 omit_raw_text: Optional[bool] = None):
        """
        :param 'DestinationPineconeConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationPineconeConfigurationIndexingArgs' indexing: Pinecone is a popular vector store that can be used to store and retrieve embeddings.
        :param bool omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationPineconeConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationPineconeConfigurationIndexing':
        """
        Pinecone is a popular vector store that can be used to store and retrieve embeddings.
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationPineconeConfigurationProcessing':
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[bool]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")


@pulumi.output_type
class DestinationPineconeConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureOpenAi":
            suggest = "azure_open_ai"
        elif key == "openAi":
            suggest = "open_ai"
        elif key == "openAiCompatible":
            suggest = "open_ai_compatible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_open_ai: Optional['outputs.DestinationPineconeConfigurationEmbeddingAzureOpenAi'] = None,
                 cohere: Optional['outputs.DestinationPineconeConfigurationEmbeddingCohere'] = None,
                 fake: Optional['outputs.DestinationPineconeConfigurationEmbeddingFake'] = None,
                 open_ai: Optional['outputs.DestinationPineconeConfigurationEmbeddingOpenAi'] = None,
                 open_ai_compatible: Optional['outputs.DestinationPineconeConfigurationEmbeddingOpenAiCompatible'] = None):
        """
        :param 'DestinationPineconeConfigurationEmbeddingAzureOpenAiArgs' azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationPineconeConfigurationEmbeddingCohereArgs' cohere: Use the Cohere API to embed text.
        :param 'DestinationPineconeConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationPineconeConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationPineconeConfigurationEmbeddingOpenAiCompatibleArgs' open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional['outputs.DestinationPineconeConfigurationEmbeddingAzureOpenAi']:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @property
    @pulumi.getter
    def cohere(self) -> Optional['outputs.DestinationPineconeConfigurationEmbeddingCohere']:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationPineconeConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationPineconeConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional['outputs.DestinationPineconeConfigurationEmbeddingOpenAiCompatible']:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")


@pulumi.output_type
class DestinationPineconeConfigurationEmbeddingAzureOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBase":
            suggest = "api_base"
        elif key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationEmbeddingAzureOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_base: str,
                 deployment: str,
                 openai_key: str):
        """
        :param str api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> str:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationPineconeConfigurationEmbeddingCohere(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereKey":
            suggest = "cohere_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationEmbeddingCohere. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationEmbeddingCohere.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationEmbeddingCohere.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_key: str):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> str:
        return pulumi.get(self, "cohere_key")


@pulumi.output_type
class DestinationPineconeConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationPineconeConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationPineconeConfigurationEmbeddingOpenAiCompatible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "modelName":
            suggest = "model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationEmbeddingOpenAiCompatible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 dimensions: int,
                 api_key: Optional[str] = None,
                 model_name: Optional[str] = None):
        """
        :param str base_url: The base URL for your OpenAI-compatible service
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str api_key: Default: ""
        :param str model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class DestinationPineconeConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pineconeEnvironment":
            suggest = "pinecone_environment"
        elif key == "pineconeKey":
            suggest = "pinecone_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 pinecone_environment: str,
                 pinecone_key: str):
        """
        :param str index: Pinecone index in your project to load data into
        :param str pinecone_environment: Pinecone Cloud environment to use
        :param str pinecone_key: The Pinecone API key to use matching the environment (copy from Pinecone console)
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "pinecone_environment", pinecone_environment)
        pulumi.set(__self__, "pinecone_key", pinecone_key)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        Pinecone index in your project to load data into
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="pineconeEnvironment")
    def pinecone_environment(self) -> str:
        """
        Pinecone Cloud environment to use
        """
        return pulumi.get(self, "pinecone_environment")

    @property
    @pulumi.getter(name="pineconeKey")
    def pinecone_key(self) -> str:
        """
        The Pinecone API key to use matching the environment (copy from Pinecone console)
        """
        return pulumi.get(self, "pinecone_key")


@pulumi.output_type
class DestinationPineconeConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"
        elif key == "fieldNameMappings":
            suggest = "field_name_mappings"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "textSplitter":
            suggest = "text_splitter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 chunk_overlap: Optional[int] = None,
                 field_name_mappings: Optional[Sequence['outputs.DestinationPineconeConfigurationProcessingFieldNameMapping']] = None,
                 metadata_fields: Optional[Sequence[str]] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 text_splitter: Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitter'] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param Sequence['DestinationPineconeConfigurationProcessingFieldNameMappingArgs'] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param 'DestinationPineconeConfigurationProcessingTextSplitterArgs' text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[Sequence['outputs.DestinationPineconeConfigurationProcessingFieldNameMapping']]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitter']:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")


@pulumi.output_type
class DestinationPineconeConfigurationProcessingFieldNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromField":
            suggest = "from_field"
        elif key == "toField":
            suggest = "to_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationProcessingFieldNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_field: str,
                 to_field: str):
        """
        :param str from_field: The field name in the source
        :param str to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> str:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> str:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")


@pulumi.output_type
class DestinationPineconeConfigurationProcessingTextSplitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byMarkdownHeader":
            suggest = "by_markdown_header"
        elif key == "byProgrammingLanguage":
            suggest = "by_programming_language"
        elif key == "bySeparator":
            suggest = "by_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationProcessingTextSplitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationProcessingTextSplitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationProcessingTextSplitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_markdown_header: Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader'] = None,
                 by_programming_language: Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguage'] = None,
                 by_separator: Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitterBySeparator'] = None):
        """
        :param 'DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeaderArgs' by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param 'DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguageArgs' by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param 'DestinationPineconeConfigurationProcessingTextSplitterBySeparatorArgs' by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader']:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguage']:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional['outputs.DestinationPineconeConfigurationProcessingTextSplitterBySeparator']:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")


@pulumi.output_type
class DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitLevel":
            suggest = "split_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_level: Optional[int] = None):
        """
        :param int split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[int]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")


@pulumi.output_type
class DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguage(dict):
    def __init__(__self__, *,
                 language: str):
        """
        :param str language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> str:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class DestinationPineconeConfigurationProcessingTextSplitterBySeparator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepSeparator":
            suggest = "keep_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPineconeConfigurationProcessingTextSplitterBySeparator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPineconeConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPineconeConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_separator: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param bool keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param Sequence[str] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[bool]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")


@pulumi.output_type
class DestinationPostgresConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeDedupe":
            suggest = "disable_type_dedupe"
        elif key == "dropCascade":
            suggest = "drop_cascade"
        elif key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 disable_type_dedupe: Optional[bool] = None,
                 drop_cascade: Optional[bool] = None,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 raw_data_schema: Optional[str] = None,
                 schema: Optional[str] = None,
                 ssl_mode: Optional['outputs.DestinationPostgresConfigurationSslMode'] = None,
                 tunnel_method: Optional['outputs.DestinationPostgresConfigurationTunnelMethod'] = None):
        """
        :param str database: Name of the database.
        :param str host: Hostname of the database.
        :param str username: Username to use to access the database.
        :param bool disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param bool drop_cascade: Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: Password associated with the username.
        :param int port: Port of the database. Default: 5432
        :param str raw_data_schema: The schema to write raw tables into
        :param str schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        :param 'DestinationPostgresConfigurationSslModeArgs' ssl_mode: SSL connection modes. 
                <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
                <b>allow</b> - Chose this mode to enable encryption only when required by the source database
                <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
                <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
                 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
                 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
                See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        :param 'DestinationPostgresConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if drop_cascade is not None:
            pulumi.set(__self__, "drop_cascade", drop_cascade)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[bool]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @property
    @pulumi.getter(name="dropCascade")
    def drop_cascade(self) -> Optional[bool]:
        """
        Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        """
        return pulumi.get(self, "drop_cascade")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database. Default: 5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The schema to write raw tables into
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional['outputs.DestinationPostgresConfigurationSslMode']:
        """
        SSL connection modes. 
         <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
         <b>allow</b> - Chose this mode to enable encryption only when required by the source database
         <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
         <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
          <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
          <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
         See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationPostgresConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationPostgresConfigurationSslMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCa":
            suggest = "verify_ca"
        elif key == "verifyFull":
            suggest = "verify_full"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfigurationSslMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfigurationSslMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfigurationSslMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: Optional['outputs.DestinationPostgresConfigurationSslModeAllow'] = None,
                 disable: Optional['outputs.DestinationPostgresConfigurationSslModeDisable'] = None,
                 prefer: Optional['outputs.DestinationPostgresConfigurationSslModePrefer'] = None,
                 require: Optional['outputs.DestinationPostgresConfigurationSslModeRequire'] = None,
                 verify_ca: Optional['outputs.DestinationPostgresConfigurationSslModeVerifyCa'] = None,
                 verify_full: Optional['outputs.DestinationPostgresConfigurationSslModeVerifyFull'] = None):
        """
        :param 'DestinationPostgresConfigurationSslModeAllowArgs' allow: Allow SSL mode.
        :param 'DestinationPostgresConfigurationSslModeDisableArgs' disable: Disable SSL.
        :param 'DestinationPostgresConfigurationSslModePreferArgs' prefer: Prefer SSL mode.
        :param 'DestinationPostgresConfigurationSslModeRequireArgs' require: Require SSL mode.
        :param 'DestinationPostgresConfigurationSslModeVerifyCaArgs' verify_ca: Verify-ca SSL mode.
        :param 'DestinationPostgresConfigurationSslModeVerifyFullArgs' verify_full: Verify-full SSL mode.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.DestinationPostgresConfigurationSslModeAllow']:
        """
        Allow SSL mode.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def disable(self) -> Optional['outputs.DestinationPostgresConfigurationSslModeDisable']:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def prefer(self) -> Optional['outputs.DestinationPostgresConfigurationSslModePrefer']:
        """
        Prefer SSL mode.
        """
        return pulumi.get(self, "prefer")

    @property
    @pulumi.getter
    def require(self) -> Optional['outputs.DestinationPostgresConfigurationSslModeRequire']:
        """
        Require SSL mode.
        """
        return pulumi.get(self, "require")

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional['outputs.DestinationPostgresConfigurationSslModeVerifyCa']:
        """
        Verify-ca SSL mode.
        """
        return pulumi.get(self, "verify_ca")

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional['outputs.DestinationPostgresConfigurationSslModeVerifyFull']:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")


@pulumi.output_type
class DestinationPostgresConfigurationSslModeAllow(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationPostgresConfigurationSslModeDisable(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationPostgresConfigurationSslModePrefer(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationPostgresConfigurationSslModeRequire(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationPostgresConfigurationSslModeVerifyCa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfigurationSslModeVerifyCa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfigurationSslModeVerifyCa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfigurationSslModeVerifyCa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class DestinationPostgresConfigurationSslModeVerifyFull(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfigurationSslModeVerifyFull. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfigurationSslModeVerifyFull.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfigurationSslModeVerifyFull.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_certificate: str,
                 client_key: str,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_certificate: Client certificate
        :param str client_key: Client key
        :param str client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class DestinationPostgresConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationPostgresConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationPostgresConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationPostgresConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationPostgresConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationPostgresConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationPostgresConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationPubsubConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsJson":
            suggest = "credentials_json"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "topicId":
            suggest = "topic_id"
        elif key == "batchingDelayThreshold":
            suggest = "batching_delay_threshold"
        elif key == "batchingElementCountThreshold":
            suggest = "batching_element_count_threshold"
        elif key == "batchingEnabled":
            suggest = "batching_enabled"
        elif key == "batchingRequestBytesThreshold":
            suggest = "batching_request_bytes_threshold"
        elif key == "orderingEnabled":
            suggest = "ordering_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationPubsubConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationPubsubConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationPubsubConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_json: str,
                 project_id: str,
                 topic_id: str,
                 batching_delay_threshold: Optional[int] = None,
                 batching_element_count_threshold: Optional[int] = None,
                 batching_enabled: Optional[bool] = None,
                 batching_request_bytes_threshold: Optional[int] = None,
                 ordering_enabled: Optional[bool] = None):
        """
        :param str credentials_json: The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/pubsub">docs</a> if you need help generating this key.
        :param str project_id: The GCP project ID for the project containing the target PubSub.
        :param str topic_id: The PubSub topic ID in the given GCP project ID.
        :param int batching_delay_threshold: Number of ms before the buffer is flushed. Default: 1
        :param int batching_element_count_threshold: Number of messages before the buffer is flushed. Default: 1
        :param bool batching_enabled: If TRUE messages will be buffered instead of sending them one by one. Default: false
        :param int batching_request_bytes_threshold: Number of bytes before the buffer is flushed. Default: 1
        :param bool ordering_enabled: If TRUE PubSub publisher will have <a href="https://cloud.google.com/pubsub/docs/ordering">message ordering</a> enabled. Every message will have an ordering key of stream. Default: false
        """
        pulumi.set(__self__, "credentials_json", credentials_json)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "topic_id", topic_id)
        if batching_delay_threshold is not None:
            pulumi.set(__self__, "batching_delay_threshold", batching_delay_threshold)
        if batching_element_count_threshold is not None:
            pulumi.set(__self__, "batching_element_count_threshold", batching_element_count_threshold)
        if batching_enabled is not None:
            pulumi.set(__self__, "batching_enabled", batching_enabled)
        if batching_request_bytes_threshold is not None:
            pulumi.set(__self__, "batching_request_bytes_threshold", batching_request_bytes_threshold)
        if ordering_enabled is not None:
            pulumi.set(__self__, "ordering_enabled", ordering_enabled)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> str:
        """
        The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/pubsub">docs</a> if you need help generating this key.
        """
        return pulumi.get(self, "credentials_json")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project ID for the project containing the target PubSub.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> str:
        """
        The PubSub topic ID in the given GCP project ID.
        """
        return pulumi.get(self, "topic_id")

    @property
    @pulumi.getter(name="batchingDelayThreshold")
    def batching_delay_threshold(self) -> Optional[int]:
        """
        Number of ms before the buffer is flushed. Default: 1
        """
        return pulumi.get(self, "batching_delay_threshold")

    @property
    @pulumi.getter(name="batchingElementCountThreshold")
    def batching_element_count_threshold(self) -> Optional[int]:
        """
        Number of messages before the buffer is flushed. Default: 1
        """
        return pulumi.get(self, "batching_element_count_threshold")

    @property
    @pulumi.getter(name="batchingEnabled")
    def batching_enabled(self) -> Optional[bool]:
        """
        If TRUE messages will be buffered instead of sending them one by one. Default: false
        """
        return pulumi.get(self, "batching_enabled")

    @property
    @pulumi.getter(name="batchingRequestBytesThreshold")
    def batching_request_bytes_threshold(self) -> Optional[int]:
        """
        Number of bytes before the buffer is flushed. Default: 1
        """
        return pulumi.get(self, "batching_request_bytes_threshold")

    @property
    @pulumi.getter(name="orderingEnabled")
    def ordering_enabled(self) -> Optional[bool]:
        """
        If TRUE PubSub publisher will have <a href="https://cloud.google.com/pubsub/docs/ordering">message ordering</a> enabled. Every message will have an ordering key of stream. Default: false
        """
        return pulumi.get(self, "ordering_enabled")


@pulumi.output_type
class DestinationQdrantConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "omitRawText":
            suggest = "omit_raw_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding: 'outputs.DestinationQdrantConfigurationEmbedding',
                 indexing: 'outputs.DestinationQdrantConfigurationIndexing',
                 processing: 'outputs.DestinationQdrantConfigurationProcessing',
                 omit_raw_text: Optional[bool] = None):
        """
        :param 'DestinationQdrantConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationQdrantConfigurationIndexingArgs' indexing: Indexing configuration
        :param bool omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationQdrantConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationQdrantConfigurationIndexing':
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationQdrantConfigurationProcessing':
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[bool]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")


@pulumi.output_type
class DestinationQdrantConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureOpenAi":
            suggest = "azure_open_ai"
        elif key == "openAi":
            suggest = "open_ai"
        elif key == "openAiCompatible":
            suggest = "open_ai_compatible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_open_ai: Optional['outputs.DestinationQdrantConfigurationEmbeddingAzureOpenAi'] = None,
                 cohere: Optional['outputs.DestinationQdrantConfigurationEmbeddingCohere'] = None,
                 fake: Optional['outputs.DestinationQdrantConfigurationEmbeddingFake'] = None,
                 open_ai: Optional['outputs.DestinationQdrantConfigurationEmbeddingOpenAi'] = None,
                 open_ai_compatible: Optional['outputs.DestinationQdrantConfigurationEmbeddingOpenAiCompatible'] = None):
        """
        :param 'DestinationQdrantConfigurationEmbeddingAzureOpenAiArgs' azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationQdrantConfigurationEmbeddingCohereArgs' cohere: Use the Cohere API to embed text.
        :param 'DestinationQdrantConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationQdrantConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationQdrantConfigurationEmbeddingOpenAiCompatibleArgs' open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional['outputs.DestinationQdrantConfigurationEmbeddingAzureOpenAi']:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @property
    @pulumi.getter
    def cohere(self) -> Optional['outputs.DestinationQdrantConfigurationEmbeddingCohere']:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationQdrantConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationQdrantConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional['outputs.DestinationQdrantConfigurationEmbeddingOpenAiCompatible']:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")


@pulumi.output_type
class DestinationQdrantConfigurationEmbeddingAzureOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBase":
            suggest = "api_base"
        elif key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationEmbeddingAzureOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_base: str,
                 deployment: str,
                 openai_key: str):
        """
        :param str api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> str:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationQdrantConfigurationEmbeddingCohere(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereKey":
            suggest = "cohere_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationEmbeddingCohere. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationEmbeddingCohere.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationEmbeddingCohere.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_key: str):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> str:
        return pulumi.get(self, "cohere_key")


@pulumi.output_type
class DestinationQdrantConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationQdrantConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationQdrantConfigurationEmbeddingOpenAiCompatible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "modelName":
            suggest = "model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationEmbeddingOpenAiCompatible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 dimensions: int,
                 api_key: Optional[str] = None,
                 model_name: Optional[str] = None):
        """
        :param str base_url: The base URL for your OpenAI-compatible service
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str api_key: Default: ""
        :param str model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class DestinationQdrantConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authMethod":
            suggest = "auth_method"
        elif key == "distanceMetric":
            suggest = "distance_metric"
        elif key == "preferGrpc":
            suggest = "prefer_grpc"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: str,
                 url: str,
                 auth_method: Optional['outputs.DestinationQdrantConfigurationIndexingAuthMethod'] = None,
                 distance_metric: Optional[str] = None,
                 prefer_grpc: Optional[bool] = None,
                 text_field: Optional[str] = None):
        """
        :param str collection: The collection to load data into
        :param str url: Public Endpoint of the Qdrant cluser
        :param 'DestinationQdrantConfigurationIndexingAuthMethodArgs' auth_method: Method to authenticate with the Qdrant Instance
        :param str distance_metric: The Distance metric used to measure similarities among vectors. This field is only used if the collection defined in the does not exist yet and is created automatically by the connector. must be one of ["dot", "cos", "euc"]; Default: "cos"
        :param bool prefer_grpc: Whether to prefer gRPC over HTTP. Set to true for Qdrant cloud clusters. Default: true
        :param str text_field: The field in the payload that contains the embedded text. Default: "text"
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "url", url)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if distance_metric is not None:
            pulumi.set(__self__, "distance_metric", distance_metric)
        if prefer_grpc is not None:
            pulumi.set(__self__, "prefer_grpc", prefer_grpc)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        The collection to load data into
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Public Endpoint of the Qdrant cluser
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional['outputs.DestinationQdrantConfigurationIndexingAuthMethod']:
        """
        Method to authenticate with the Qdrant Instance
        """
        return pulumi.get(self, "auth_method")

    @property
    @pulumi.getter(name="distanceMetric")
    def distance_metric(self) -> Optional[str]:
        """
        The Distance metric used to measure similarities among vectors. This field is only used if the collection defined in the does not exist yet and is created automatically by the connector. must be one of ["dot", "cos", "euc"]; Default: "cos"
        """
        return pulumi.get(self, "distance_metric")

    @property
    @pulumi.getter(name="preferGrpc")
    def prefer_grpc(self) -> Optional[bool]:
        """
        Whether to prefer gRPC over HTTP. Set to true for Qdrant cloud clusters. Default: true
        """
        return pulumi.get(self, "prefer_grpc")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[str]:
        """
        The field in the payload that contains the embedded text. Default: "text"
        """
        return pulumi.get(self, "text_field")


@pulumi.output_type
class DestinationQdrantConfigurationIndexingAuthMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyAuth":
            suggest = "api_key_auth"
        elif key == "noAuth":
            suggest = "no_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationIndexingAuthMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationIndexingAuthMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationIndexingAuthMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_auth: Optional['outputs.DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth'] = None,
                 no_auth: Optional['outputs.DestinationQdrantConfigurationIndexingAuthMethodNoAuth'] = None):
        if api_key_auth is not None:
            pulumi.set(__self__, "api_key_auth", api_key_auth)
        if no_auth is not None:
            pulumi.set(__self__, "no_auth", no_auth)

    @property
    @pulumi.getter(name="apiKeyAuth")
    def api_key_auth(self) -> Optional['outputs.DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth']:
        return pulumi.get(self, "api_key_auth")

    @property
    @pulumi.getter(name="noAuth")
    def no_auth(self) -> Optional['outputs.DestinationQdrantConfigurationIndexingAuthMethodNoAuth']:
        return pulumi.get(self, "no_auth")


@pulumi.output_type
class DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: API Key for the Qdrant instance
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key for the Qdrant instance
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class DestinationQdrantConfigurationIndexingAuthMethodNoAuth(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationQdrantConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"
        elif key == "fieldNameMappings":
            suggest = "field_name_mappings"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "textSplitter":
            suggest = "text_splitter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 chunk_overlap: Optional[int] = None,
                 field_name_mappings: Optional[Sequence['outputs.DestinationQdrantConfigurationProcessingFieldNameMapping']] = None,
                 metadata_fields: Optional[Sequence[str]] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 text_splitter: Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitter'] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param Sequence['DestinationQdrantConfigurationProcessingFieldNameMappingArgs'] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param 'DestinationQdrantConfigurationProcessingTextSplitterArgs' text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[Sequence['outputs.DestinationQdrantConfigurationProcessingFieldNameMapping']]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitter']:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")


@pulumi.output_type
class DestinationQdrantConfigurationProcessingFieldNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromField":
            suggest = "from_field"
        elif key == "toField":
            suggest = "to_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationProcessingFieldNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_field: str,
                 to_field: str):
        """
        :param str from_field: The field name in the source
        :param str to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> str:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> str:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")


@pulumi.output_type
class DestinationQdrantConfigurationProcessingTextSplitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byMarkdownHeader":
            suggest = "by_markdown_header"
        elif key == "byProgrammingLanguage":
            suggest = "by_programming_language"
        elif key == "bySeparator":
            suggest = "by_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationProcessingTextSplitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationProcessingTextSplitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationProcessingTextSplitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_markdown_header: Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader'] = None,
                 by_programming_language: Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguage'] = None,
                 by_separator: Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitterBySeparator'] = None):
        """
        :param 'DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeaderArgs' by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param 'DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguageArgs' by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param 'DestinationQdrantConfigurationProcessingTextSplitterBySeparatorArgs' by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader']:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguage']:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional['outputs.DestinationQdrantConfigurationProcessingTextSplitterBySeparator']:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")


@pulumi.output_type
class DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitLevel":
            suggest = "split_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_level: Optional[int] = None):
        """
        :param int split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[int]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")


@pulumi.output_type
class DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguage(dict):
    def __init__(__self__, *,
                 language: str):
        """
        :param str language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> str:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class DestinationQdrantConfigurationProcessingTextSplitterBySeparator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepSeparator":
            suggest = "keep_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationQdrantConfigurationProcessingTextSplitterBySeparator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationQdrantConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationQdrantConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_separator: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param bool keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param Sequence[str] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[bool]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")


@pulumi.output_type
class DestinationRedisConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cacheType":
            suggest = "cache_type"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedisConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedisConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedisConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 username: str,
                 cache_type: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 ssl: Optional[bool] = None,
                 ssl_mode: Optional['outputs.DestinationRedisConfigurationSslMode'] = None,
                 tunnel_method: Optional['outputs.DestinationRedisConfigurationTunnelMethod'] = None):
        """
        :param str host: Redis host to connect to.
        :param str username: Username associated with Redis.
        :param str cache_type: Redis cache type to store data in. must be one of ["hash"]; Default: "hash"
        :param str password: Password associated with Redis.
        :param int port: Port of Redis. Default: 6379
        :param bool ssl: Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible. Default: false
        :param 'DestinationRedisConfigurationSslModeArgs' ssl_mode: SSL connection modes. 
                 <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
        :param 'DestinationRedisConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if cache_type is not None:
            pulumi.set(__self__, "cache_type", cache_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Redis host to connect to.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username associated with Redis.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="cacheType")
    def cache_type(self) -> Optional[str]:
        """
        Redis cache type to store data in. must be one of ["hash"]; Default: "hash"
        """
        return pulumi.get(self, "cache_type")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with Redis.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of Redis. Default: 6379
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible. Default: false
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional['outputs.DestinationRedisConfigurationSslMode']:
        """
        SSL connection modes. 
          <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationRedisConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationRedisConfigurationSslMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyFull":
            suggest = "verify_full"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedisConfigurationSslMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedisConfigurationSslMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedisConfigurationSslMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable: Optional['outputs.DestinationRedisConfigurationSslModeDisable'] = None,
                 verify_full: Optional['outputs.DestinationRedisConfigurationSslModeVerifyFull'] = None):
        """
        :param 'DestinationRedisConfigurationSslModeDisableArgs' disable: Disable SSL.
        :param 'DestinationRedisConfigurationSslModeVerifyFullArgs' verify_full: Verify-full SSL mode.
        """
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def disable(self) -> Optional['outputs.DestinationRedisConfigurationSslModeDisable']:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional['outputs.DestinationRedisConfigurationSslModeVerifyFull']:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")


@pulumi.output_type
class DestinationRedisConfigurationSslModeDisable(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationRedisConfigurationSslModeVerifyFull(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedisConfigurationSslModeVerifyFull. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedisConfigurationSslModeVerifyFull.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedisConfigurationSslModeVerifyFull.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_certificate: str,
                 client_key: str,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_certificate: Client certificate
        :param str client_key: Client key
        :param str client_key_password: Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class DestinationRedisConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedisConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedisConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedisConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationRedisConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationRedisConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationRedisConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationRedisConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationRedisConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationRedisConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationRedisConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationRedisConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedisConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedisConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedisConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationRedisConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedisConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedisConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedisConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationRedshiftConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeDedupe":
            suggest = "disable_type_dedupe"
        elif key == "dropCascade":
            suggest = "drop_cascade"
        elif key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"
        elif key == "uploadingMethod":
            suggest = "uploading_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 password: str,
                 username: str,
                 disable_type_dedupe: Optional[bool] = None,
                 drop_cascade: Optional[bool] = None,
                 jdbc_url_params: Optional[str] = None,
                 port: Optional[int] = None,
                 raw_data_schema: Optional[str] = None,
                 schema: Optional[str] = None,
                 tunnel_method: Optional['outputs.DestinationRedshiftConfigurationTunnelMethod'] = None,
                 uploading_method: Optional['outputs.DestinationRedshiftConfigurationUploadingMethod'] = None):
        """
        :param str database: Name of the database.
        :param str host: Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
        :param str password: Password associated with the username.
        :param str username: Username to use to access the database.
        :param bool disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param bool drop_cascade: Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param int port: Port of the database. Default: 5439
        :param str raw_data_schema: The schema to write raw tables into (default: airbyte_internal).
        :param str schema: The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public". Default: "public"
        :param 'DestinationRedshiftConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        :param 'DestinationRedshiftConfigurationUploadingMethodArgs' uploading_method: The way data will be uploaded to Redshift.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if drop_cascade is not None:
            pulumi.set(__self__, "drop_cascade", drop_cascade)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)
        if uploading_method is not None:
            pulumi.set(__self__, "uploading_method", uploading_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[bool]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @property
    @pulumi.getter(name="dropCascade")
    def drop_cascade(self) -> Optional[bool]:
        """
        Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
        """
        return pulumi.get(self, "drop_cascade")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database. Default: 5439
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The schema to write raw tables into (default: airbyte_internal).
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationRedshiftConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")

    @property
    @pulumi.getter(name="uploadingMethod")
    def uploading_method(self) -> Optional['outputs.DestinationRedshiftConfigurationUploadingMethod']:
        """
        The way data will be uploaded to Redshift.
        """
        return pulumi.get(self, "uploading_method")


@pulumi.output_type
class DestinationRedshiftConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationRedshiftConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationRedshiftConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationRedshiftConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationRedshiftConfigurationUploadingMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awss3Staging":
            suggest = "awss3_staging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationUploadingMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationUploadingMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationUploadingMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 awss3_staging: Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3Staging'] = None,
                 standard: Optional['outputs.DestinationRedshiftConfigurationUploadingMethodStandard'] = None):
        """
        :param 'DestinationRedshiftConfigurationUploadingMethodAwss3StagingArgs' awss3_staging: <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
        :param 'DestinationRedshiftConfigurationUploadingMethodStandardArgs' standard: <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use S3 uploading.
        """
        if awss3_staging is not None:
            pulumi.set(__self__, "awss3_staging", awss3_staging)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)

    @property
    @pulumi.getter(name="awss3Staging")
    def awss3_staging(self) -> Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3Staging']:
        """
        <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
        """
        return pulumi.get(self, "awss3_staging")

    @property
    @pulumi.getter
    def standard(self) -> Optional['outputs.DestinationRedshiftConfigurationUploadingMethodStandard']:
        """
        <i>(not recommended)</i> Direct loading using SQL INSERT statements. This method is extremely inefficient and provided only for quick testing. In all other cases, you should use S3 uploading.
        """
        return pulumi.get(self, "standard")


@pulumi.output_type
class DestinationRedshiftConfigurationUploadingMethodAwss3Staging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "fileNamePattern":
            suggest = "file_name_pattern"
        elif key == "purgeStagingData":
            suggest = "purge_staging_data"
        elif key == "s3BucketPath":
            suggest = "s3_bucket_path"
        elif key == "s3BucketRegion":
            suggest = "s3_bucket_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationUploadingMethodAwss3Staging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationUploadingMethodAwss3Staging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationUploadingMethodAwss3Staging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: str,
                 s3_bucket_name: str,
                 secret_access_key: str,
                 encryption: Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption'] = None,
                 file_name_pattern: Optional[str] = None,
                 purge_staging_data: Optional[bool] = None,
                 s3_bucket_path: Optional[str] = None,
                 s3_bucket_region: Optional[str] = None):
        """
        :param str access_key_id: This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        :param str s3_bucket_name: The name of the staging S3 bucket.
        :param str secret_access_key: The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        :param 'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionArgs' encryption: How to encrypt the staging data
        :param str file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param bool purge_staging_data: Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details. Default: true
        :param str s3_bucket_path: The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
        :param str s3_bucket_region: The region of the S3 staging bucket. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if encryption is not None:
            pulumi.set(__self__, "encryption", encryption)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if purge_staging_data is not None:
            pulumi.set(__self__, "purge_staging_data", purge_staging_data)
        if s3_bucket_path is not None:
            pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> str:
        """
        The name of the staging S3 bucket.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter
    def encryption(self) -> Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption']:
        """
        How to encrypt the staging data
        """
        return pulumi.get(self, "encryption")

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[str]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @property
    @pulumi.getter(name="purgeStagingData")
    def purge_staging_data(self) -> Optional[bool]:
        """
        Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details. Default: true
        """
        return pulumi.get(self, "purge_staging_data")

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> Optional[str]:
        """
        The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
        """
        return pulumi.get(self, "s3_bucket_path")

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[str]:
        """
        The region of the S3 staging bucket. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")


@pulumi.output_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aescbcEnvelopeEncryption":
            suggest = "aescbc_envelope_encryption"
        elif key == "noEncryption":
            suggest = "no_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aescbc_envelope_encryption: Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption'] = None,
                 no_encryption: Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryption'] = None):
        """
        :param 'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryptionArgs' aescbc_envelope_encryption: Staging data will be encrypted using AES-CBC envelope encryption.
        :param 'DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryptionArgs' no_encryption: Staging data will be stored in plaintext.
        """
        if aescbc_envelope_encryption is not None:
            pulumi.set(__self__, "aescbc_envelope_encryption", aescbc_envelope_encryption)
        if no_encryption is not None:
            pulumi.set(__self__, "no_encryption", no_encryption)

    @property
    @pulumi.getter(name="aescbcEnvelopeEncryption")
    def aescbc_envelope_encryption(self) -> Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption']:
        """
        Staging data will be encrypted using AES-CBC envelope encryption.
        """
        return pulumi.get(self, "aescbc_envelope_encryption")

    @property
    @pulumi.getter(name="noEncryption")
    def no_encryption(self) -> Optional['outputs.DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryption']:
        """
        Staging data will be stored in plaintext.
        """
        return pulumi.get(self, "no_encryption")


@pulumi.output_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyEncryptingKey":
            suggest = "key_encrypting_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionAescbcEnvelopeEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_encrypting_key: Optional[str] = None):
        """
        :param str key_encrypting_key: The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
        """
        if key_encrypting_key is not None:
            pulumi.set(__self__, "key_encrypting_key", key_encrypting_key)

    @property
    @pulumi.getter(name="keyEncryptingKey")
    def key_encrypting_key(self) -> Optional[str]:
        """
        The key, base64-encoded. Must be either 128, 192, or 256 bits. Leave blank to have Airbyte generate an ephemeral key for each sync.
        """
        return pulumi.get(self, "key_encrypting_key")


@pulumi.output_type
class DestinationRedshiftConfigurationUploadingMethodAwss3StagingEncryptionNoEncryption(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationRedshiftConfigurationUploadingMethodStandard(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3BucketPath":
            suggest = "s3_bucket_path"
        elif key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "fileNamePattern":
            suggest = "file_name_pattern"
        elif key == "s3BucketRegion":
            suggest = "s3_bucket_region"
        elif key == "s3Endpoint":
            suggest = "s3_endpoint"
        elif key == "s3PathFormat":
            suggest = "s3_path_format"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.DestinationS3ConfigurationFormat',
                 s3_bucket_name: str,
                 s3_bucket_path: str,
                 access_key_id: Optional[str] = None,
                 file_name_pattern: Optional[str] = None,
                 s3_bucket_region: Optional[str] = None,
                 s3_endpoint: Optional[str] = None,
                 s3_path_format: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param 'DestinationS3ConfigurationFormatArgs' format: Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        :param str s3_bucket_name: The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        :param str s3_bucket_path: Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        :param str access_key_id: The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        :param str file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param str s3_bucket_region: The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        :param str s3_endpoint: Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        :param str s3_path_format: Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        :param str secret_access_key: The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)
        if s3_endpoint is not None:
            pulumi.set(__self__, "s3_endpoint", s3_endpoint)
        if s3_path_format is not None:
            pulumi.set(__self__, "s3_path_format", s3_path_format)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.DestinationS3ConfigurationFormat':
        """
        Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> str:
        """
        The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> str:
        """
        Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        """
        return pulumi.get(self, "s3_bucket_path")

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[str]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[str]:
        """
        The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")

    @property
    @pulumi.getter(name="s3Endpoint")
    def s3_endpoint(self) -> Optional[str]:
        """
        Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        """
        return pulumi.get(self, "s3_endpoint")

    @property
    @pulumi.getter(name="s3PathFormat")
    def s3_path_format(self) -> Optional[str]:
        """
        Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        """
        return pulumi.get(self, "s3_path_format")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class DestinationS3ConfigurationFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroApacheAvro":
            suggest = "avro_apache_avro"
        elif key == "csvCommaSeparatedValues":
            suggest = "csv_comma_separated_values"
        elif key == "jsonLinesNewlineDelimitedJson":
            suggest = "json_lines_newline_delimited_json"
        elif key == "parquetColumnarStorage":
            suggest = "parquet_columnar_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_apache_avro: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvro'] = None,
                 csv_comma_separated_values: Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValues'] = None,
                 json_lines_newline_delimited_json: Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson'] = None,
                 parquet_columnar_storage: Optional['outputs.DestinationS3ConfigurationFormatParquetColumnarStorage'] = None):
        if avro_apache_avro is not None:
            pulumi.set(__self__, "avro_apache_avro", avro_apache_avro)
        if csv_comma_separated_values is not None:
            pulumi.set(__self__, "csv_comma_separated_values", csv_comma_separated_values)
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)
        if parquet_columnar_storage is not None:
            pulumi.set(__self__, "parquet_columnar_storage", parquet_columnar_storage)

    @property
    @pulumi.getter(name="avroApacheAvro")
    def avro_apache_avro(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvro']:
        return pulumi.get(self, "avro_apache_avro")

    @property
    @pulumi.getter(name="csvCommaSeparatedValues")
    def csv_comma_separated_values(self) -> Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValues']:
        return pulumi.get(self, "csv_comma_separated_values")

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson']:
        return pulumi.get(self, "json_lines_newline_delimited_json")

    @property
    @pulumi.getter(name="parquetColumnarStorage")
    def parquet_columnar_storage(self) -> Optional['outputs.DestinationS3ConfigurationFormatParquetColumnarStorage']:
        return pulumi.get(self, "parquet_columnar_storage")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionCodec":
            suggest = "compression_codec"
        elif key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatAvroApacheAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_codec: 'outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec',
                 format_type: Optional[str] = None):
        """
        :param 'DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecArgs' compression_codec: The compression algorithm used to compress data. Default to no compression.
        :param str format_type: must be one of ["Avro"]; Default: "Avro"
        """
        pulumi.set(__self__, "compression_codec", compression_codec)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> 'outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec':
        """
        The compression algorithm used to compress data. Default to no compression.
        """
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["Avro"]; Default: "Avro"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bzip2: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2'] = None,
                 deflate: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate'] = None,
                 no_compression: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompression'] = None,
                 snappy: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappy'] = None,
                 xz: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz'] = None,
                 zstandard: Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard'] = None):
        if bzip2 is not None:
            pulumi.set(__self__, "bzip2", bzip2)
        if deflate is not None:
            pulumi.set(__self__, "deflate", deflate)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)
        if snappy is not None:
            pulumi.set(__self__, "snappy", snappy)
        if xz is not None:
            pulumi.set(__self__, "xz", xz)
        if zstandard is not None:
            pulumi.set(__self__, "zstandard", zstandard)

    @property
    @pulumi.getter
    def bzip2(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2']:
        return pulumi.get(self, "bzip2")

    @property
    @pulumi.getter
    def deflate(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate']:
        return pulumi.get(self, "deflate")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompression']:
        return pulumi.get(self, "no_compression")

    @property
    @pulumi.getter
    def snappy(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappy']:
        return pulumi.get(self, "snappy")

    @property
    @pulumi.getter
    def xz(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz']:
        return pulumi.get(self, "xz")

    @property
    @pulumi.getter
    def zstandard(self) -> Optional['outputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard']:
        return pulumi.get(self, "zstandard")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2(dict):
    def __init__(__self__, *,
                 codec: Optional[str] = None):
        """
        :param str codec: must be one of ["bzip2"]; Default: "bzip2"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["bzip2"]; Default: "bzip2"
        """
        return pulumi.get(self, "codec")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 compression_level: Optional[int] = None):
        """
        :param str codec: must be one of ["Deflate"]; Default: "Deflate"
        :param int compression_level: 0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["Deflate"]; Default: "Deflate"
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        0: no compression & fastest, 9: best compression & slowest. Default: 0
        """
        return pulumi.get(self, "compression_level")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompression(dict):
    def __init__(__self__, *,
                 codec: Optional[str] = None):
        """
        :param str codec: must be one of ["no compression"]; Default: "no compression"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["no compression"]; Default: "no compression"
        """
        return pulumi.get(self, "codec")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappy(dict):
    def __init__(__self__, *,
                 codec: Optional[str] = None):
        """
        :param str codec: must be one of ["snappy"]; Default: "snappy"
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["snappy"]; Default: "snappy"
        """
        return pulumi.get(self, "codec")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 compression_level: Optional[int] = None):
        """
        :param str codec: must be one of ["xz"]; Default: "xz"
        :param int compression_level: See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["xz"]; Default: "xz"
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        See <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
        """
        return pulumi.get(self, "compression_level")


@pulumi.output_type
class DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionLevel":
            suggest = "compression_level"
        elif key == "includeChecksum":
            suggest = "include_checksum"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 codec: Optional[str] = None,
                 compression_level: Optional[int] = None,
                 include_checksum: Optional[bool] = None):
        """
        :param str codec: must be one of ["zstandard"]; Default: "zstandard"
        :param int compression_level: Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        :param bool include_checksum: If true, include a checksum with each data block. Default: false
        """
        if codec is not None:
            pulumi.set(__self__, "codec", codec)
        if compression_level is not None:
            pulumi.set(__self__, "compression_level", compression_level)
        if include_checksum is not None:
            pulumi.set(__self__, "include_checksum", include_checksum)

    @property
    @pulumi.getter
    def codec(self) -> Optional[str]:
        """
        must be one of ["zstandard"]; Default: "zstandard"
        """
        return pulumi.get(self, "codec")

    @property
    @pulumi.getter(name="compressionLevel")
    def compression_level(self) -> Optional[int]:
        """
        Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
        """
        return pulumi.get(self, "compression_level")

    @property
    @pulumi.getter(name="includeChecksum")
    def include_checksum(self) -> Optional[bool]:
        """
        If true, include a checksum with each data block. Default: false
        """
        return pulumi.get(self, "include_checksum")


@pulumi.output_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValues(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatCsvCommaSeparatedValues. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValues.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValues.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression: Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression'] = None,
                 flattening: Optional[str] = None,
                 format_type: Optional[str] = None):
        """
        :param 'DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionArgs' compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        :param str flattening: Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        :param str format_type: must be one of ["CSV"]; Default: "CSV"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression']:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def flattening(self) -> Optional[str]:
        """
        Whether the input json data should be normalized (flattened) in the output CSV. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["CSV"]; Default: "CSV"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gzip: Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip'] = None,
                 no_compression: Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression'] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip']:
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression']:
        return pulumi.get(self, "no_compression")


@pulumi.output_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression: Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression'] = None,
                 flattening: Optional[str] = None,
                 format_type: Optional[str] = None):
        """
        :param 'DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs' compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        :param str flattening: Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        :param str format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression']:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def flattening(self) -> Optional[str]:
        """
        Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "No flattening"
        """
        return pulumi.get(self, "flattening")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gzip: Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip'] = None,
                 no_compression: Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression'] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip']:
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression']:
        return pulumi.get(self, "no_compression")


@pulumi.output_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationS3ConfigurationFormatParquetColumnarStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSizeMb":
            suggest = "block_size_mb"
        elif key == "compressionCodec":
            suggest = "compression_codec"
        elif key == "dictionaryEncoding":
            suggest = "dictionary_encoding"
        elif key == "dictionaryPageSizeKb":
            suggest = "dictionary_page_size_kb"
        elif key == "formatType":
            suggest = "format_type"
        elif key == "maxPaddingSizeMb":
            suggest = "max_padding_size_mb"
        elif key == "pageSizeKb":
            suggest = "page_size_kb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3ConfigurationFormatParquetColumnarStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3ConfigurationFormatParquetColumnarStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3ConfigurationFormatParquetColumnarStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size_mb: Optional[int] = None,
                 compression_codec: Optional[str] = None,
                 dictionary_encoding: Optional[bool] = None,
                 dictionary_page_size_kb: Optional[int] = None,
                 format_type: Optional[str] = None,
                 max_padding_size_mb: Optional[int] = None,
                 page_size_kb: Optional[int] = None):
        """
        :param int block_size_mb: This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        :param str compression_codec: The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        :param bool dictionary_encoding: Default: true. Default: true
        :param int dictionary_page_size_kb: There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        :param str format_type: must be one of ["Parquet"]; Default: "Parquet"
        :param int max_padding_size_mb: Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        :param int page_size_kb: The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        if block_size_mb is not None:
            pulumi.set(__self__, "block_size_mb", block_size_mb)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if dictionary_encoding is not None:
            pulumi.set(__self__, "dictionary_encoding", dictionary_encoding)
        if dictionary_page_size_kb is not None:
            pulumi.set(__self__, "dictionary_page_size_kb", dictionary_page_size_kb)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)
        if max_padding_size_mb is not None:
            pulumi.set(__self__, "max_padding_size_mb", max_padding_size_mb)
        if page_size_kb is not None:
            pulumi.set(__self__, "page_size_kb", page_size_kb)

    @property
    @pulumi.getter(name="blockSizeMb")
    def block_size_mb(self) -> Optional[int]:
        """
        This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
        """
        return pulumi.get(self, "block_size_mb")

    @property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[str]:
        """
        The compression algorithm used to compress data pages. must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]; Default: "UNCOMPRESSED"
        """
        return pulumi.get(self, "compression_codec")

    @property
    @pulumi.getter(name="dictionaryEncoding")
    def dictionary_encoding(self) -> Optional[bool]:
        """
        Default: true. Default: true
        """
        return pulumi.get(self, "dictionary_encoding")

    @property
    @pulumi.getter(name="dictionaryPageSizeKb")
    def dictionary_page_size_kb(self) -> Optional[int]:
        """
        There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "dictionary_page_size_kb")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["Parquet"]; Default: "Parquet"
        """
        return pulumi.get(self, "format_type")

    @property
    @pulumi.getter(name="maxPaddingSizeMb")
    def max_padding_size_mb(self) -> Optional[int]:
        """
        Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
        """
        return pulumi.get(self, "max_padding_size_mb")

    @property
    @pulumi.getter(name="pageSizeKb")
    def page_size_kb(self) -> Optional[int]:
        """
        The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
        """
        return pulumi.get(self, "page_size_kb")


@pulumi.output_type
class DestinationS3GlueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "glueDatabase":
            suggest = "glue_database"
        elif key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3BucketPath":
            suggest = "s3_bucket_path"
        elif key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "fileNamePattern":
            suggest = "file_name_pattern"
        elif key == "glueSerializationLibrary":
            suggest = "glue_serialization_library"
        elif key == "s3BucketRegion":
            suggest = "s3_bucket_region"
        elif key == "s3Endpoint":
            suggest = "s3_endpoint"
        elif key == "s3PathFormat":
            suggest = "s3_path_format"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3GlueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3GlueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3GlueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.DestinationS3GlueConfigurationFormat',
                 glue_database: str,
                 s3_bucket_name: str,
                 s3_bucket_path: str,
                 access_key_id: Optional[str] = None,
                 file_name_pattern: Optional[str] = None,
                 glue_serialization_library: Optional[str] = None,
                 s3_bucket_region: Optional[str] = None,
                 s3_endpoint: Optional[str] = None,
                 s3_path_format: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param 'DestinationS3GlueConfigurationFormatArgs' format: Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        :param str glue_database: Name of the glue database for creating the tables, leave blank if no integration
        :param str s3_bucket_name: The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        :param str s3_bucket_path: Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        :param str access_key_id: The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        :param str file_name_pattern: The pattern allows you to set the file-name format for the S3 staging file(s)
        :param str glue_serialization_library: The library that your query engine will use for reading and writing data in your lake. must be one of ["org.openx.data.jsonserde.JsonSerDe", "org.apache.hive.hcatalog.data.JsonSerDe"]; Default: "org.openx.data.jsonserde.JsonSerDe"
        :param str s3_bucket_region: The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        :param str s3_endpoint: Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        :param str s3_path_format: Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        :param str secret_access_key: The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "glue_database", glue_database)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_bucket_path", s3_bucket_path)
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if file_name_pattern is not None:
            pulumi.set(__self__, "file_name_pattern", file_name_pattern)
        if glue_serialization_library is not None:
            pulumi.set(__self__, "glue_serialization_library", glue_serialization_library)
        if s3_bucket_region is not None:
            pulumi.set(__self__, "s3_bucket_region", s3_bucket_region)
        if s3_endpoint is not None:
            pulumi.set(__self__, "s3_endpoint", s3_endpoint)
        if s3_path_format is not None:
            pulumi.set(__self__, "s3_path_format", s3_path_format)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.DestinationS3GlueConfigurationFormat':
        """
        Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="glueDatabase")
    def glue_database(self) -> str:
        """
        Name of the glue database for creating the tables, leave blank if no integration
        """
        return pulumi.get(self, "glue_database")

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> str:
        """
        The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3BucketPath")
    def s3_bucket_path(self) -> str:
        """
        Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
        """
        return pulumi.get(self, "s3_bucket_path")

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="fileNamePattern")
    def file_name_pattern(self) -> Optional[str]:
        """
        The pattern allows you to set the file-name format for the S3 staging file(s)
        """
        return pulumi.get(self, "file_name_pattern")

    @property
    @pulumi.getter(name="glueSerializationLibrary")
    def glue_serialization_library(self) -> Optional[str]:
        """
        The library that your query engine will use for reading and writing data in your lake. must be one of ["org.openx.data.jsonserde.JsonSerDe", "org.apache.hive.hcatalog.data.JsonSerDe"]; Default: "org.openx.data.jsonserde.JsonSerDe"
        """
        return pulumi.get(self, "glue_serialization_library")

    @property
    @pulumi.getter(name="s3BucketRegion")
    def s3_bucket_region(self) -> Optional[str]:
        """
        The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "s3_bucket_region")

    @property
    @pulumi.getter(name="s3Endpoint")
    def s3_endpoint(self) -> Optional[str]:
        """
        Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>. Default: ""
        """
        return pulumi.get(self, "s3_endpoint")

    @property
    @pulumi.getter(name="s3PathFormat")
    def s3_path_format(self) -> Optional[str]:
        """
        Format string on how data will be organized inside the S3 bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
        """
        return pulumi.get(self, "s3_path_format")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
        """
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class DestinationS3GlueConfigurationFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonLinesNewlineDelimitedJson":
            suggest = "json_lines_newline_delimited_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3GlueConfigurationFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3GlueConfigurationFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3GlueConfigurationFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_lines_newline_delimited_json: Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson'] = None):
        if json_lines_newline_delimited_json is not None:
            pulumi.set(__self__, "json_lines_newline_delimited_json", json_lines_newline_delimited_json)

    @property
    @pulumi.getter(name="jsonLinesNewlineDelimitedJson")
    def json_lines_newline_delimited_json(self) -> Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson']:
        return pulumi.get(self, "json_lines_newline_delimited_json")


@pulumi.output_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formatType":
            suggest = "format_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJson.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression: Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression'] = None,
                 flattening: Optional[str] = None,
                 format_type: Optional[str] = None):
        """
        :param 'DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionArgs' compression: Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        :param str flattening: Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "Root level flattening"
        :param str format_type: must be one of ["JSONL"]; Default: "JSONL"
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if flattening is not None:
            pulumi.set(__self__, "flattening", flattening)
        if format_type is not None:
            pulumi.set(__self__, "format_type", format_type)

    @property
    @pulumi.getter
    def compression(self) -> Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression']:
        """
        Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
        """
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter
    def flattening(self) -> Optional[str]:
        """
        Whether the input json data should be normalized (flattened) in the output JSON Lines. Please refer to docs for details. must be one of ["No flattening", "Root level flattening"]; Default: "Root level flattening"
        """
        return pulumi.get(self, "flattening")

    @property
    @pulumi.getter(name="formatType")
    def format_type(self) -> Optional[str]:
        """
        must be one of ["JSONL"]; Default: "JSONL"
        """
        return pulumi.get(self, "format_type")


@pulumi.output_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noCompression":
            suggest = "no_compression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gzip: Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip'] = None,
                 no_compression: Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression'] = None):
        if gzip is not None:
            pulumi.set(__self__, "gzip", gzip)
        if no_compression is not None:
            pulumi.set(__self__, "no_compression", no_compression)

    @property
    @pulumi.getter
    def gzip(self) -> Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip']:
        return pulumi.get(self, "gzip")

    @property
    @pulumi.getter(name="noCompression")
    def no_compression(self) -> Optional['outputs.DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression']:
        return pulumi.get(self, "no_compression")


@pulumi.output_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["GZIP"]; Default: "GZIP"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["GZIP"]; Default: "GZIP"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compressionType":
            suggest = "compression_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationS3GlueConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression_type: Optional[str] = None):
        """
        :param str compression_type: must be one of ["No Compression"]; Default: "No Compression"
        """
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[str]:
        """
        must be one of ["No Compression"]; Default: "No Compression"
        """
        return pulumi.get(self, "compression_type")


@pulumi.output_type
class DestinationSftpJsonConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationPath":
            suggest = "destination_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSftpJsonConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSftpJsonConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSftpJsonConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_path: str,
                 host: str,
                 password: str,
                 username: str,
                 port: Optional[int] = None):
        """
        :param str destination_path: Path to the directory where json files will be written.
        :param str host: Hostname of the SFTP server.
        :param str password: Password associated with the username.
        :param str username: Username to use to access the SFTP server.
        :param int port: Port of the SFTP server. Default: 22
        """
        pulumi.set(__self__, "destination_path", destination_path)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> str:
        """
        Path to the directory where json files will be written.
        """
        return pulumi.get(self, "destination_path")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the SFTP server.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the SFTP server.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the SFTP server. Default: 22
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DestinationSnowflakeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableTypeDedupe":
            suggest = "disable_type_dedupe"
        elif key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "rawDataSchema":
            suggest = "raw_data_schema"
        elif key == "retentionPeriodDays":
            suggest = "retention_period_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 role: str,
                 schema: str,
                 username: str,
                 warehouse: str,
                 credentials: Optional['outputs.DestinationSnowflakeConfigurationCredentials'] = None,
                 disable_type_dedupe: Optional[bool] = None,
                 jdbc_url_params: Optional[str] = None,
                 raw_data_schema: Optional[str] = None,
                 retention_period_days: Optional[int] = None):
        """
        :param str database: Enter the name of the <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">database</a> you want to sync data into
        :param str host: Enter your Snowflake account's <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier">locator</a> (in the format <account_locator>.<region>.<cloud>.snowflakecomputing.com)
        :param str role: Enter the <a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#roles">role</a> that you want to use to access Snowflake
        :param str schema: Enter the name of the default <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">schema</a>
        :param str username: Enter the name of the user you want to use to access the database
        :param str warehouse: Enter the name of the <a href="https://docs.snowflake.com/en/user-guide/warehouses-overview.html#overview-of-warehouses">warehouse</a> that you want to sync data into
        :param bool disable_type_dedupe: Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        :param str jdbc_url_params: Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
        :param str raw_data_schema: The schema to write raw tables into (default: airbyte_internal)
        :param int retention_period_days: The number of days of Snowflake Time Travel to enable on the tables. See <a href="https://docs.snowflake.com/en/user-guide/data-time-travel#data-retention-period">Snowflake's documentation</a> for more information. Setting a nonzero value will incur increased storage costs in your Snowflake instance. Default: 1
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "schema", schema)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "warehouse", warehouse)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if disable_type_dedupe is not None:
            pulumi.set(__self__, "disable_type_dedupe", disable_type_dedupe)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if raw_data_schema is not None:
            pulumi.set(__self__, "raw_data_schema", raw_data_schema)
        if retention_period_days is not None:
            pulumi.set(__self__, "retention_period_days", retention_period_days)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Enter the name of the <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">database</a> you want to sync data into
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Enter your Snowflake account's <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier">locator</a> (in the format <account_locator>.<region>.<cloud>.snowflakecomputing.com)
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Enter the <a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#roles">role</a> that you want to use to access Snowflake
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def schema(self) -> str:
        """
        Enter the name of the default <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">schema</a>
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Enter the name of the user you want to use to access the database
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        Enter the name of the <a href="https://docs.snowflake.com/en/user-guide/warehouses-overview.html#overview-of-warehouses">warehouse</a> that you want to sync data into
        """
        return pulumi.get(self, "warehouse")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.DestinationSnowflakeConfigurationCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="disableTypeDedupe")
    def disable_type_dedupe(self) -> Optional[bool]:
        """
        Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
        """
        return pulumi.get(self, "disable_type_dedupe")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter(name="rawDataSchema")
    def raw_data_schema(self) -> Optional[str]:
        """
        The schema to write raw tables into (default: airbyte_internal)
        """
        return pulumi.get(self, "raw_data_schema")

    @property
    @pulumi.getter(name="retentionPeriodDays")
    def retention_period_days(self) -> Optional[int]:
        """
        The number of days of Snowflake Time Travel to enable on the tables. See <a href="https://docs.snowflake.com/en/user-guide/data-time-travel#data-retention-period">Snowflake's documentation</a> for more information. Setting a nonzero value will incur increased storage costs in your Snowflake instance. Default: 1
        """
        return pulumi.get(self, "retention_period_days")


@pulumi.output_type
class DestinationSnowflakeConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPairAuthentication":
            suggest = "key_pair_authentication"
        elif key == "oAuth20":
            suggest = "o_auth20"
        elif key == "usernameAndPassword":
            suggest = "username_and_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_pair_authentication: Optional['outputs.DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication'] = None,
                 o_auth20: Optional['outputs.DestinationSnowflakeConfigurationCredentialsOAuth20'] = None,
                 username_and_password: Optional['outputs.DestinationSnowflakeConfigurationCredentialsUsernameAndPassword'] = None):
        if key_pair_authentication is not None:
            pulumi.set(__self__, "key_pair_authentication", key_pair_authentication)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if username_and_password is not None:
            pulumi.set(__self__, "username_and_password", username_and_password)

    @property
    @pulumi.getter(name="keyPairAuthentication")
    def key_pair_authentication(self) -> Optional['outputs.DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication']:
        return pulumi.get(self, "key_pair_authentication")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.DestinationSnowflakeConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")

    @property
    @pulumi.getter(name="usernameAndPassword")
    def username_and_password(self) -> Optional['outputs.DestinationSnowflakeConfigurationCredentialsUsernameAndPassword']:
        return pulumi.get(self, "username_and_password")


@pulumi.output_type
class DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyPassword":
            suggest = "private_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key: str,
                 private_key_password: Optional[str] = None):
        """
        :param str private_key: RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/destinations/snowflake">docs</a> for more information on how to obtain this key.
        :param str private_key_password: Passphrase for private key
        """
        pulumi.set(__self__, "private_key", private_key)
        if private_key_password is not None:
            pulumi.set(__self__, "private_key_password", private_key_password)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/destinations/snowflake">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyPassword")
    def private_key_password(self) -> Optional[str]:
        """
        Passphrase for private key
        """
        return pulumi.get(self, "private_key_password")


@pulumi.output_type
class DestinationSnowflakeConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 refresh_token: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: Enter you application's Access Token
        :param str refresh_token: Enter your application's Refresh Token
        :param str client_id: Enter your application's Client ID
        :param str client_secret: Enter your application's Client secret
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Enter you application's Access Token
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Enter your application's Refresh Token
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Enter your application's Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Enter your application's Client secret
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class DestinationSnowflakeConfigurationCredentialsUsernameAndPassword(dict):
    def __init__(__self__, *,
                 password: str):
        """
        :param str password: Enter the password associated with the username.
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Enter the password associated with the username.
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class DestinationSnowflakeCortexConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "omitRawText":
            suggest = "omit_raw_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding: 'outputs.DestinationSnowflakeCortexConfigurationEmbedding',
                 indexing: 'outputs.DestinationSnowflakeCortexConfigurationIndexing',
                 processing: 'outputs.DestinationSnowflakeCortexConfigurationProcessing',
                 omit_raw_text: Optional[bool] = None):
        """
        :param 'DestinationSnowflakeCortexConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationSnowflakeCortexConfigurationIndexingArgs' indexing: Snowflake can be used to store vector data and retrieve embeddings.
        :param bool omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationSnowflakeCortexConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationSnowflakeCortexConfigurationIndexing':
        """
        Snowflake can be used to store vector data and retrieve embeddings.
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationSnowflakeCortexConfigurationProcessing':
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[bool]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureOpenAi":
            suggest = "azure_open_ai"
        elif key == "openAi":
            suggest = "open_ai"
        elif key == "openAiCompatible":
            suggest = "open_ai_compatible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_open_ai: Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi'] = None,
                 cohere: Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingCohere'] = None,
                 fake: Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingFake'] = None,
                 open_ai: Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingOpenAi'] = None,
                 open_ai_compatible: Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible'] = None):
        """
        :param 'DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAiArgs' azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationSnowflakeCortexConfigurationEmbeddingCohereArgs' cohere: Use the Cohere API to embed text.
        :param 'DestinationSnowflakeCortexConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationSnowflakeCortexConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatibleArgs' open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi']:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @property
    @pulumi.getter
    def cohere(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingCohere']:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible']:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBase":
            suggest = "api_base"
        elif key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_base: str,
                 deployment: str,
                 openai_key: str):
        """
        :param str api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> str:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationEmbeddingCohere(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereKey":
            suggest = "cohere_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationEmbeddingCohere. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingCohere.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingCohere.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_key: str):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> str:
        return pulumi.get(self, "cohere_key")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "modelName":
            suggest = "model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 dimensions: int,
                 api_key: Optional[str] = None,
                 model_name: Optional[str] = None):
        """
        :param str base_url: The base URL for your OpenAI-compatible service
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str api_key: Default: ""
        :param str model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSchema":
            suggest = "default_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.DestinationSnowflakeCortexConfigurationIndexingCredentials',
                 database: str,
                 default_schema: str,
                 host: str,
                 role: str,
                 username: str,
                 warehouse: str):
        """
        :param str database: Enter the name of the database that you want to sync data into
        :param str default_schema: Enter the name of the default schema
        :param str host: Enter the account name you want to use to access the database. This is usually the identifier before .snowflakecomputing.com
        :param str role: Enter the role that you want to use to access Snowflake
        :param str username: Enter the name of the user you want to use to access the database
        :param str warehouse: Enter the name of the warehouse that you want to sync data into
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "default_schema", default_schema)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "warehouse", warehouse)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.DestinationSnowflakeCortexConfigurationIndexingCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Enter the name of the database that you want to sync data into
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="defaultSchema")
    def default_schema(self) -> str:
        """
        Enter the name of the default schema
        """
        return pulumi.get(self, "default_schema")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Enter the account name you want to use to access the database. This is usually the identifier before .snowflakecomputing.com
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Enter the role that you want to use to access Snowflake
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Enter the name of the user you want to use to access the database
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        Enter the name of the warehouse that you want to sync data into
        """
        return pulumi.get(self, "warehouse")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationIndexingCredentials(dict):
    def __init__(__self__, *,
                 password: str):
        """
        :param str password: Enter the password you want to use to access the database
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Enter the password you want to use to access the database
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"
        elif key == "fieldNameMappings":
            suggest = "field_name_mappings"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "textSplitter":
            suggest = "text_splitter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 chunk_overlap: Optional[int] = None,
                 field_name_mappings: Optional[Sequence['outputs.DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping']] = None,
                 metadata_fields: Optional[Sequence[str]] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 text_splitter: Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitter'] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param Sequence['DestinationSnowflakeCortexConfigurationProcessingFieldNameMappingArgs'] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param 'DestinationSnowflakeCortexConfigurationProcessingTextSplitterArgs' text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[Sequence['outputs.DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping']]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitter']:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromField":
            suggest = "from_field"
        elif key == "toField":
            suggest = "to_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_field: str,
                 to_field: str):
        """
        :param str from_field: The field name in the source
        :param str to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> str:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> str:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byMarkdownHeader":
            suggest = "by_markdown_header"
        elif key == "byProgrammingLanguage":
            suggest = "by_programming_language"
        elif key == "bySeparator":
            suggest = "by_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationProcessingTextSplitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingTextSplitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingTextSplitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_markdown_header: Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader'] = None,
                 by_programming_language: Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguage'] = None,
                 by_separator: Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator'] = None):
        """
        :param 'DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeaderArgs' by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param 'DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguageArgs' by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param 'DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparatorArgs' by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader']:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguage']:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional['outputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator']:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitLevel":
            suggest = "split_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_level: Optional[int] = None):
        """
        :param int split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[int]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguage(dict):
    def __init__(__self__, *,
                 language: str):
        """
        :param str language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> str:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepSeparator":
            suggest = "keep_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_separator: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param bool keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param Sequence[str] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[bool]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")


@pulumi.output_type
class DestinationTeradataConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "sslMode":
            suggest = "ssl_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationTeradataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationTeradataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationTeradataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 schema: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 ssl_mode: Optional['outputs.DestinationTeradataConfigurationSslMode'] = None):
        """
        :param str host: Hostname of the database.
        :param str username: Username to use to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: Password associated with the username.
        :param str schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "airbyte_td"
        :param bool ssl: Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        :param 'DestinationTeradataConfigurationSslModeArgs' ssl_mode: SSL connection modes. 
                <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
                <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
                <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
                <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
                 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
                 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
                See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "airbyte_td"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional['outputs.DestinationTeradataConfigurationSslMode']:
        """
        SSL connection modes. 
         <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
         <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
         <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
         <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
          <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
          <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
         See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")


@pulumi.output_type
class DestinationTeradataConfigurationSslMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCa":
            suggest = "verify_ca"
        elif key == "verifyFull":
            suggest = "verify_full"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationTeradataConfigurationSslMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationTeradataConfigurationSslMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationTeradataConfigurationSslMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: Optional['outputs.DestinationTeradataConfigurationSslModeAllow'] = None,
                 disable: Optional['outputs.DestinationTeradataConfigurationSslModeDisable'] = None,
                 prefer: Optional['outputs.DestinationTeradataConfigurationSslModePrefer'] = None,
                 require: Optional['outputs.DestinationTeradataConfigurationSslModeRequire'] = None,
                 verify_ca: Optional['outputs.DestinationTeradataConfigurationSslModeVerifyCa'] = None,
                 verify_full: Optional['outputs.DestinationTeradataConfigurationSslModeVerifyFull'] = None):
        """
        :param 'DestinationTeradataConfigurationSslModeAllowArgs' allow: Allow SSL mode.
        :param 'DestinationTeradataConfigurationSslModeDisableArgs' disable: Disable SSL.
        :param 'DestinationTeradataConfigurationSslModePreferArgs' prefer: Prefer SSL mode.
        :param 'DestinationTeradataConfigurationSslModeRequireArgs' require: Require SSL mode.
        :param 'DestinationTeradataConfigurationSslModeVerifyCaArgs' verify_ca: Verify-ca SSL mode.
        :param 'DestinationTeradataConfigurationSslModeVerifyFullArgs' verify_full: Verify-full SSL mode.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.DestinationTeradataConfigurationSslModeAllow']:
        """
        Allow SSL mode.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def disable(self) -> Optional['outputs.DestinationTeradataConfigurationSslModeDisable']:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def prefer(self) -> Optional['outputs.DestinationTeradataConfigurationSslModePrefer']:
        """
        Prefer SSL mode.
        """
        return pulumi.get(self, "prefer")

    @property
    @pulumi.getter
    def require(self) -> Optional['outputs.DestinationTeradataConfigurationSslModeRequire']:
        """
        Require SSL mode.
        """
        return pulumi.get(self, "require")

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional['outputs.DestinationTeradataConfigurationSslModeVerifyCa']:
        """
        Verify-ca SSL mode.
        """
        return pulumi.get(self, "verify_ca")

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional['outputs.DestinationTeradataConfigurationSslModeVerifyFull']:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")


@pulumi.output_type
class DestinationTeradataConfigurationSslModeAllow(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationTeradataConfigurationSslModeDisable(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationTeradataConfigurationSslModePrefer(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationTeradataConfigurationSslModeRequire(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationTeradataConfigurationSslModeVerifyCa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sslCaCertificate":
            suggest = "ssl_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationTeradataConfigurationSslModeVerifyCa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationTeradataConfigurationSslModeVerifyCa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationTeradataConfigurationSslModeVerifyCa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssl_ca_certificate: str):
        """
        :param str ssl_ca_certificate: Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
                See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> str:
        """
        Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
         See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_ca_certificate")


@pulumi.output_type
class DestinationTeradataConfigurationSslModeVerifyFull(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sslCaCertificate":
            suggest = "ssl_ca_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationTeradataConfigurationSslModeVerifyFull. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationTeradataConfigurationSslModeVerifyFull.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationTeradataConfigurationSslModeVerifyFull.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssl_ca_certificate: str):
        """
        :param str ssl_ca_certificate: Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
                See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> str:
        """
        Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
         See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_ca_certificate")


@pulumi.output_type
class DestinationTypesenseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationTypesenseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationTypesenseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationTypesenseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 host: str,
                 batch_size: Optional[int] = None,
                 path: Optional[str] = None,
                 port: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str api_key: Typesense API Key
        :param str host: Hostname of the Typesense instance without protocol.
        :param int batch_size: How many documents should be imported together. Default 1000
        :param str path: Path of the Typesense instance. Default is none
        :param str port: Port of the Typesense instance. Ex: 8108, 80, 443. Default is 443
        :param str protocol: Protocol of the Typesense instance. Ex: http or https. Default is https
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "host", host)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Typesense API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the Typesense instance without protocol.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[int]:
        """
        How many documents should be imported together. Default 1000
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path of the Typesense instance. Default is none
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port of the Typesense instance. Ex: 8108, 80, 443. Default is 443
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocol of the Typesense instance. Ex: http or https. Default is https
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class DestinationVectaraConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corpusName":
            suggest = "corpus_name"
        elif key == "customerId":
            suggest = "customer_id"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "titleField":
            suggest = "title_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationVectaraConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationVectaraConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationVectaraConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 corpus_name: str,
                 customer_id: str,
                 oauth2: 'outputs.DestinationVectaraConfigurationOauth2',
                 metadata_fields: Optional[Sequence[str]] = None,
                 parallelize: Optional[bool] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 title_field: Optional[str] = None):
        """
        :param str corpus_name: The Name of Corpus to load data into
        :param str customer_id: Your customer id as it is in the authenticaion url
        :param 'DestinationVectaraConfigurationOauth2Args' oauth2: OAuth2.0 credentials used to authenticate admin actions (creating/deleting corpora)
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param bool parallelize: Parallelize indexing into Vectara with multiple threads. Default: false
        :param Sequence[str] text_fields: List of fields in the record that should be in the section of the document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param str title_field: A field that will be used to populate the `title` of each document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. Default: ""
        """
        pulumi.set(__self__, "corpus_name", corpus_name)
        pulumi.set(__self__, "customer_id", customer_id)
        pulumi.set(__self__, "oauth2", oauth2)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if parallelize is not None:
            pulumi.set(__self__, "parallelize", parallelize)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if title_field is not None:
            pulumi.set(__self__, "title_field", title_field)

    @property
    @pulumi.getter(name="corpusName")
    def corpus_name(self) -> str:
        """
        The Name of Corpus to load data into
        """
        return pulumi.get(self, "corpus_name")

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> str:
        """
        Your customer id as it is in the authenticaion url
        """
        return pulumi.get(self, "customer_id")

    @property
    @pulumi.getter
    def oauth2(self) -> 'outputs.DestinationVectaraConfigurationOauth2':
        """
        OAuth2.0 credentials used to authenticate admin actions (creating/deleting corpora)
        """
        return pulumi.get(self, "oauth2")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter
    def parallelize(self) -> Optional[bool]:
        """
        Parallelize indexing into Vectara with multiple threads. Default: false
        """
        return pulumi.get(self, "parallelize")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be in the section of the document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="titleField")
    def title_field(self) -> Optional[str]:
        """
        A field that will be used to populate the `title` of each document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. Default: ""
        """
        return pulumi.get(self, "title_field")


@pulumi.output_type
class DestinationVectaraConfigurationOauth2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationVectaraConfigurationOauth2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationVectaraConfigurationOauth2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationVectaraConfigurationOauth2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str):
        """
        :param str client_id: OAuth2.0 client id
        :param str client_secret: OAuth2.0 client secret
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        OAuth2.0 client id
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OAuth2.0 client secret
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class DestinationWeaviateConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "omitRawText":
            suggest = "omit_raw_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding: 'outputs.DestinationWeaviateConfigurationEmbedding',
                 indexing: 'outputs.DestinationWeaviateConfigurationIndexing',
                 processing: 'outputs.DestinationWeaviateConfigurationProcessing',
                 omit_raw_text: Optional[bool] = None):
        """
        :param 'DestinationWeaviateConfigurationEmbeddingArgs' embedding: Embedding configuration
        :param 'DestinationWeaviateConfigurationIndexingArgs' indexing: Indexing configuration
        :param bool omit_raw_text: Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        pulumi.set(__self__, "embedding", embedding)
        pulumi.set(__self__, "indexing", indexing)
        pulumi.set(__self__, "processing", processing)
        if omit_raw_text is not None:
            pulumi.set(__self__, "omit_raw_text", omit_raw_text)

    @property
    @pulumi.getter
    def embedding(self) -> 'outputs.DestinationWeaviateConfigurationEmbedding':
        """
        Embedding configuration
        """
        return pulumi.get(self, "embedding")

    @property
    @pulumi.getter
    def indexing(self) -> 'outputs.DestinationWeaviateConfigurationIndexing':
        """
        Indexing configuration
        """
        return pulumi.get(self, "indexing")

    @property
    @pulumi.getter
    def processing(self) -> 'outputs.DestinationWeaviateConfigurationProcessing':
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="omitRawText")
    def omit_raw_text(self) -> Optional[bool]:
        """
        Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
        """
        return pulumi.get(self, "omit_raw_text")


@pulumi.output_type
class DestinationWeaviateConfigurationEmbedding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureOpenAi":
            suggest = "azure_open_ai"
        elif key == "fromField":
            suggest = "from_field"
        elif key == "noExternalEmbedding":
            suggest = "no_external_embedding"
        elif key == "openAi":
            suggest = "open_ai"
        elif key == "openAiCompatible":
            suggest = "open_ai_compatible"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationEmbedding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationEmbedding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationEmbedding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_open_ai: Optional['outputs.DestinationWeaviateConfigurationEmbeddingAzureOpenAi'] = None,
                 cohere: Optional['outputs.DestinationWeaviateConfigurationEmbeddingCohere'] = None,
                 fake: Optional['outputs.DestinationWeaviateConfigurationEmbeddingFake'] = None,
                 from_field: Optional['outputs.DestinationWeaviateConfigurationEmbeddingFromField'] = None,
                 no_external_embedding: Optional['outputs.DestinationWeaviateConfigurationEmbeddingNoExternalEmbedding'] = None,
                 open_ai: Optional['outputs.DestinationWeaviateConfigurationEmbeddingOpenAi'] = None,
                 open_ai_compatible: Optional['outputs.DestinationWeaviateConfigurationEmbeddingOpenAiCompatible'] = None):
        """
        :param 'DestinationWeaviateConfigurationEmbeddingAzureOpenAiArgs' azure_open_ai: Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationWeaviateConfigurationEmbeddingCohereArgs' cohere: Use the Cohere API to embed text.
        :param 'DestinationWeaviateConfigurationEmbeddingFakeArgs' fake: Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        :param 'DestinationWeaviateConfigurationEmbeddingFromFieldArgs' from_field: Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
        :param 'DestinationWeaviateConfigurationEmbeddingNoExternalEmbeddingArgs' no_external_embedding: Do not calculate and pass embeddings to Weaviate. Suitable for clusters with configured vectorizers to calculate embeddings within Weaviate or for classes that should only support regular text search.
        :param 'DestinationWeaviateConfigurationEmbeddingOpenAiArgs' open_ai: Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        :param 'DestinationWeaviateConfigurationEmbeddingOpenAiCompatibleArgs' open_ai_compatible: Use a service that's compatible with the OpenAI API to embed text.
        """
        if azure_open_ai is not None:
            pulumi.set(__self__, "azure_open_ai", azure_open_ai)
        if cohere is not None:
            pulumi.set(__self__, "cohere", cohere)
        if fake is not None:
            pulumi.set(__self__, "fake", fake)
        if from_field is not None:
            pulumi.set(__self__, "from_field", from_field)
        if no_external_embedding is not None:
            pulumi.set(__self__, "no_external_embedding", no_external_embedding)
        if open_ai is not None:
            pulumi.set(__self__, "open_ai", open_ai)
        if open_ai_compatible is not None:
            pulumi.set(__self__, "open_ai_compatible", open_ai_compatible)

    @property
    @pulumi.getter(name="azureOpenAi")
    def azure_open_ai(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingAzureOpenAi']:
        """
        Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "azure_open_ai")

    @property
    @pulumi.getter
    def cohere(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingCohere']:
        """
        Use the Cohere API to embed text.
        """
        return pulumi.get(self, "cohere")

    @property
    @pulumi.getter
    def fake(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingFake']:
        """
        Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
        """
        return pulumi.get(self, "fake")

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingFromField']:
        """
        Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="noExternalEmbedding")
    def no_external_embedding(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingNoExternalEmbedding']:
        """
        Do not calculate and pass embeddings to Weaviate. Suitable for clusters with configured vectorizers to calculate embeddings within Weaviate or for classes that should only support regular text search.
        """
        return pulumi.get(self, "no_external_embedding")

    @property
    @pulumi.getter(name="openAi")
    def open_ai(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingOpenAi']:
        """
        Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
        """
        return pulumi.get(self, "open_ai")

    @property
    @pulumi.getter(name="openAiCompatible")
    def open_ai_compatible(self) -> Optional['outputs.DestinationWeaviateConfigurationEmbeddingOpenAiCompatible']:
        """
        Use a service that's compatible with the OpenAI API to embed text.
        """
        return pulumi.get(self, "open_ai_compatible")


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingAzureOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiBase":
            suggest = "api_base"
        elif key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationEmbeddingAzureOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationEmbeddingAzureOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_base: str,
                 deployment: str,
                 openai_key: str):
        """
        :param str api_base: The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str deployment: The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        :param str openai_key: The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        pulumi.set(__self__, "api_base", api_base)
        pulumi.set(__self__, "deployment", deployment)
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="apiBase")
    def api_base(self) -> str:
        """
        The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "api_base")

    @property
    @pulumi.getter
    def deployment(self) -> str:
        """
        The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "deployment")

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        """
        The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
        """
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingCohere(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohereKey":
            suggest = "cohere_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationEmbeddingCohere. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationEmbeddingCohere.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationEmbeddingCohere.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohere_key: str):
        pulumi.set(__self__, "cohere_key", cohere_key)

    @property
    @pulumi.getter(name="cohereKey")
    def cohere_key(self) -> str:
        return pulumi.get(self, "cohere_key")


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingFake(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingFromField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationEmbeddingFromField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationEmbeddingFromField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationEmbeddingFromField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: int,
                 field_name: str):
        """
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str field_name: Name of the field in the record that contains the embedding
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "field_name", field_name)

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the record that contains the embedding
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingNoExternalEmbedding(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingOpenAi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openaiKey":
            suggest = "openai_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationEmbeddingOpenAi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationEmbeddingOpenAi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 openai_key: str):
        pulumi.set(__self__, "openai_key", openai_key)

    @property
    @pulumi.getter(name="openaiKey")
    def openai_key(self) -> str:
        return pulumi.get(self, "openai_key")


@pulumi.output_type
class DestinationWeaviateConfigurationEmbeddingOpenAiCompatible(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "apiKey":
            suggest = "api_key"
        elif key == "modelName":
            suggest = "model_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationEmbeddingOpenAiCompatible. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationEmbeddingOpenAiCompatible.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 dimensions: int,
                 api_key: Optional[str] = None,
                 model_name: Optional[str] = None):
        """
        :param str base_url: The base URL for your OpenAI-compatible service
        :param int dimensions: The number of dimensions the embedding model is generating
        :param str api_key: Default: ""
        :param str model_name: The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "dimensions", dimensions)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The base URL for your OpenAI-compatible service
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def dimensions(self) -> int:
        """
        The number of dimensions the embedding model is generating
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[str]:
        """
        The name of the model to use for embedding. Default: "text-embedding-ada-002"
        """
        return pulumi.get(self, "model_name")


@pulumi.output_type
class DestinationWeaviateConfigurationIndexing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalHeaders":
            suggest = "additional_headers"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "defaultVectorizer":
            suggest = "default_vectorizer"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationIndexing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationIndexing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationIndexing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth: 'outputs.DestinationWeaviateConfigurationIndexingAuth',
                 host: str,
                 additional_headers: Optional[Sequence['outputs.DestinationWeaviateConfigurationIndexingAdditionalHeader']] = None,
                 batch_size: Optional[int] = None,
                 default_vectorizer: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 text_field: Optional[str] = None):
        """
        :param 'DestinationWeaviateConfigurationIndexingAuthArgs' auth: Authentication method
        :param str host: The public endpoint of the Weaviate cluster.
        :param Sequence['DestinationWeaviateConfigurationIndexingAdditionalHeaderArgs'] additional_headers: Additional HTTP headers to send with every request.
        :param int batch_size: The number of records to send to Weaviate in each batch. Default: 128
        :param str default_vectorizer: The vectorizer to use if new classes need to be created. must be one of ["none", "text2vec-cohere", "text2vec-huggingface", "text2vec-openai", "text2vec-palm", "text2vec-contextionary", "text2vec-transformers", "text2vec-gpt4all"]; Default: "none"
        :param str tenant_id: The tenant ID to use for multi tenancy. Default: ""
        :param str text_field: The field in the object that contains the embedded text. Default: "text"
        """
        pulumi.set(__self__, "auth", auth)
        pulumi.set(__self__, "host", host)
        if additional_headers is not None:
            pulumi.set(__self__, "additional_headers", additional_headers)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if default_vectorizer is not None:
            pulumi.set(__self__, "default_vectorizer", default_vectorizer)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if text_field is not None:
            pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter
    def auth(self) -> 'outputs.DestinationWeaviateConfigurationIndexingAuth':
        """
        Authentication method
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The public endpoint of the Weaviate cluster.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="additionalHeaders")
    def additional_headers(self) -> Optional[Sequence['outputs.DestinationWeaviateConfigurationIndexingAdditionalHeader']]:
        """
        Additional HTTP headers to send with every request.
        """
        return pulumi.get(self, "additional_headers")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[int]:
        """
        The number of records to send to Weaviate in each batch. Default: 128
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="defaultVectorizer")
    def default_vectorizer(self) -> Optional[str]:
        """
        The vectorizer to use if new classes need to be created. must be one of ["none", "text2vec-cohere", "text2vec-huggingface", "text2vec-openai", "text2vec-palm", "text2vec-contextionary", "text2vec-transformers", "text2vec-gpt4all"]; Default: "none"
        """
        return pulumi.get(self, "default_vectorizer")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The tenant ID to use for multi tenancy. Default: ""
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> Optional[str]:
        """
        The field in the object that contains the embedded text. Default: "text"
        """
        return pulumi.get(self, "text_field")


@pulumi.output_type
class DestinationWeaviateConfigurationIndexingAdditionalHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerKey":
            suggest = "header_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationIndexingAdditionalHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationIndexingAdditionalHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationIndexingAdditionalHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_key: str,
                 value: str):
        pulumi.set(__self__, "header_key", header_key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="headerKey")
    def header_key(self) -> str:
        return pulumi.get(self, "header_key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DestinationWeaviateConfigurationIndexingAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "noAuthentication":
            suggest = "no_authentication"
        elif key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationIndexingAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationIndexingAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationIndexingAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.DestinationWeaviateConfigurationIndexingAuthApiToken'] = None,
                 no_authentication: Optional['outputs.DestinationWeaviateConfigurationIndexingAuthNoAuthentication'] = None,
                 username_password: Optional['outputs.DestinationWeaviateConfigurationIndexingAuthUsernamePassword'] = None):
        """
        :param 'DestinationWeaviateConfigurationIndexingAuthApiTokenArgs' api_token: Authenticate using an API token (suitable for Weaviate Cloud)
        :param 'DestinationWeaviateConfigurationIndexingAuthNoAuthenticationArgs' no_authentication: Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        :param 'DestinationWeaviateConfigurationIndexingAuthUsernamePasswordArgs' username_password: Authenticate using username and password (suitable for self-managed Weaviate clusters)
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if no_authentication is not None:
            pulumi.set(__self__, "no_authentication", no_authentication)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.DestinationWeaviateConfigurationIndexingAuthApiToken']:
        """
        Authenticate using an API token (suitable for Weaviate Cloud)
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="noAuthentication")
    def no_authentication(self) -> Optional['outputs.DestinationWeaviateConfigurationIndexingAuthNoAuthentication']:
        """
        Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
        """
        return pulumi.get(self, "no_authentication")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.DestinationWeaviateConfigurationIndexingAuthUsernamePassword']:
        """
        Authenticate using username and password (suitable for self-managed Weaviate clusters)
        """
        return pulumi.get(self, "username_password")


@pulumi.output_type
class DestinationWeaviateConfigurationIndexingAuthApiToken(dict):
    def __init__(__self__, *,
                 token: str):
        """
        :param str token: API Token for the Weaviate instance
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        API Token for the Weaviate instance
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class DestinationWeaviateConfigurationIndexingAuthNoAuthentication(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationWeaviateConfigurationIndexingAuthUsernamePassword(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password for the Weaviate cluster
        :param str username: Username for the Weaviate cluster
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for the Weaviate cluster
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for the Weaviate cluster
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DestinationWeaviateConfigurationProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "chunkOverlap":
            suggest = "chunk_overlap"
        elif key == "fieldNameMappings":
            suggest = "field_name_mappings"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "textFields":
            suggest = "text_fields"
        elif key == "textSplitter":
            suggest = "text_splitter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: int,
                 chunk_overlap: Optional[int] = None,
                 field_name_mappings: Optional[Sequence['outputs.DestinationWeaviateConfigurationProcessingFieldNameMapping']] = None,
                 metadata_fields: Optional[Sequence[str]] = None,
                 text_fields: Optional[Sequence[str]] = None,
                 text_splitter: Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitter'] = None):
        """
        :param int chunk_size: Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        :param int chunk_overlap: Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        :param Sequence['DestinationWeaviateConfigurationProcessingFieldNameMappingArgs'] field_name_mappings: List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        :param Sequence[str] metadata_fields: List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        :param Sequence[str] text_fields: List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        :param 'DestinationWeaviateConfigurationProcessingTextSplitterArgs' text_splitter: Split text fields into chunks based on the specified method.
        """
        pulumi.set(__self__, "chunk_size", chunk_size)
        if chunk_overlap is not None:
            pulumi.set(__self__, "chunk_overlap", chunk_overlap)
        if field_name_mappings is not None:
            pulumi.set(__self__, "field_name_mappings", field_name_mappings)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if text_fields is not None:
            pulumi.set(__self__, "text_fields", text_fields)
        if text_splitter is not None:
            pulumi.set(__self__, "text_splitter", text_splitter)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> int:
        """
        Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter(name="chunkOverlap")
    def chunk_overlap(self) -> Optional[int]:
        """
        Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
        """
        return pulumi.get(self, "chunk_overlap")

    @property
    @pulumi.getter(name="fieldNameMappings")
    def field_name_mappings(self) -> Optional[Sequence['outputs.DestinationWeaviateConfigurationProcessingFieldNameMapping']]:
        """
        List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
        """
        return pulumi.get(self, "field_name_mappings")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="textFields")
    def text_fields(self) -> Optional[Sequence[str]]:
        """
        List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
        """
        return pulumi.get(self, "text_fields")

    @property
    @pulumi.getter(name="textSplitter")
    def text_splitter(self) -> Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitter']:
        """
        Split text fields into chunks based on the specified method.
        """
        return pulumi.get(self, "text_splitter")


@pulumi.output_type
class DestinationWeaviateConfigurationProcessingFieldNameMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromField":
            suggest = "from_field"
        elif key == "toField":
            suggest = "to_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationProcessingFieldNameMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationProcessingFieldNameMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_field: str,
                 to_field: str):
        """
        :param str from_field: The field name in the source
        :param str to_field: The field name to use in the destination
        """
        pulumi.set(__self__, "from_field", from_field)
        pulumi.set(__self__, "to_field", to_field)

    @property
    @pulumi.getter(name="fromField")
    def from_field(self) -> str:
        """
        The field name in the source
        """
        return pulumi.get(self, "from_field")

    @property
    @pulumi.getter(name="toField")
    def to_field(self) -> str:
        """
        The field name to use in the destination
        """
        return pulumi.get(self, "to_field")


@pulumi.output_type
class DestinationWeaviateConfigurationProcessingTextSplitter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byMarkdownHeader":
            suggest = "by_markdown_header"
        elif key == "byProgrammingLanguage":
            suggest = "by_programming_language"
        elif key == "bySeparator":
            suggest = "by_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationProcessingTextSplitter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationProcessingTextSplitter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationProcessingTextSplitter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 by_markdown_header: Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader'] = None,
                 by_programming_language: Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguage'] = None,
                 by_separator: Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitterBySeparator'] = None):
        """
        :param 'DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeaderArgs' by_markdown_header: Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        :param 'DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguageArgs' by_programming_language: Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        :param 'DestinationWeaviateConfigurationProcessingTextSplitterBySeparatorArgs' by_separator: Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        if by_markdown_header is not None:
            pulumi.set(__self__, "by_markdown_header", by_markdown_header)
        if by_programming_language is not None:
            pulumi.set(__self__, "by_programming_language", by_programming_language)
        if by_separator is not None:
            pulumi.set(__self__, "by_separator", by_separator)

    @property
    @pulumi.getter(name="byMarkdownHeader")
    def by_markdown_header(self) -> Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader']:
        """
        Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
        """
        return pulumi.get(self, "by_markdown_header")

    @property
    @pulumi.getter(name="byProgrammingLanguage")
    def by_programming_language(self) -> Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguage']:
        """
        Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
        """
        return pulumi.get(self, "by_programming_language")

    @property
    @pulumi.getter(name="bySeparator")
    def by_separator(self) -> Optional['outputs.DestinationWeaviateConfigurationProcessingTextSplitterBySeparator']:
        """
        Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
        """
        return pulumi.get(self, "by_separator")


@pulumi.output_type
class DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitLevel":
            suggest = "split_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_level: Optional[int] = None):
        """
        :param int split_level: Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        if split_level is not None:
            pulumi.set(__self__, "split_level", split_level)

    @property
    @pulumi.getter(name="splitLevel")
    def split_level(self) -> Optional[int]:
        """
        Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
        """
        return pulumi.get(self, "split_level")


@pulumi.output_type
class DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguage(dict):
    def __init__(__self__, *,
                 language: str):
        """
        :param str language: Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        pulumi.set(__self__, "language", language)

    @property
    @pulumi.getter
    def language(self) -> str:
        """
        Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
        """
        return pulumi.get(self, "language")


@pulumi.output_type
class DestinationWeaviateConfigurationProcessingTextSplitterBySeparator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepSeparator":
            suggest = "keep_separator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationWeaviateConfigurationProcessingTextSplitterBySeparator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationWeaviateConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationWeaviateConfigurationProcessingTextSplitterBySeparator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_separator: Optional[bool] = None,
                 separators: Optional[Sequence[str]] = None):
        """
        :param bool keep_separator: Whether to keep the separator in the resulting chunks. Default: false
        :param Sequence[str] separators: List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        if keep_separator is not None:
            pulumi.set(__self__, "keep_separator", keep_separator)
        if separators is not None:
            pulumi.set(__self__, "separators", separators)

    @property
    @pulumi.getter(name="keepSeparator")
    def keep_separator(self) -> Optional[bool]:
        """
        Whether to keep the separator in the resulting chunks. Default: false
        """
        return pulumi.get(self, "keep_separator")

    @property
    @pulumi.getter
    def separators(self) -> Optional[Sequence[str]]:
        """
        List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\\n".
        """
        return pulumi.get(self, "separators")


@pulumi.output_type
class DestinationYellowbrickConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 schema: Optional[str] = None,
                 ssl: Optional[bool] = None,
                 ssl_mode: Optional['outputs.DestinationYellowbrickConfigurationSslMode'] = None,
                 tunnel_method: Optional['outputs.DestinationYellowbrickConfigurationTunnelMethod'] = None):
        """
        :param str database: Name of the database.
        :param str host: Hostname of the database.
        :param str username: Username to use to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: Password associated with the username.
        :param int port: Port of the database. Default: 5432
        :param str schema: The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        :param bool ssl: Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        :param 'DestinationYellowbrickConfigurationSslModeArgs' ssl_mode: SSL connection modes. 
                <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
                <b>allow</b> - Chose this mode to enable encryption only when required by the source database
                <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
                <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
                 <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
                 <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
                See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        :param 'DestinationYellowbrickConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database. Default: 5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[bool]:
        """
        Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslMode']:
        """
        SSL connection modes. 
         <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
         <b>allow</b> - Chose this mode to enable encryption only when required by the source database
         <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
         <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
          <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
          <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
         See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.DestinationYellowbrickConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class DestinationYellowbrickConfigurationSslMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCa":
            suggest = "verify_ca"
        elif key == "verifyFull":
            suggest = "verify_full"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfigurationSslMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfigurationSslMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfigurationSslMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: Optional['outputs.DestinationYellowbrickConfigurationSslModeAllow'] = None,
                 disable: Optional['outputs.DestinationYellowbrickConfigurationSslModeDisable'] = None,
                 prefer: Optional['outputs.DestinationYellowbrickConfigurationSslModePrefer'] = None,
                 require: Optional['outputs.DestinationYellowbrickConfigurationSslModeRequire'] = None,
                 verify_ca: Optional['outputs.DestinationYellowbrickConfigurationSslModeVerifyCa'] = None,
                 verify_full: Optional['outputs.DestinationYellowbrickConfigurationSslModeVerifyFull'] = None):
        """
        :param 'DestinationYellowbrickConfigurationSslModeAllowArgs' allow: Allow SSL mode.
        :param 'DestinationYellowbrickConfigurationSslModeDisableArgs' disable: Disable SSL.
        :param 'DestinationYellowbrickConfigurationSslModePreferArgs' prefer: Prefer SSL mode.
        :param 'DestinationYellowbrickConfigurationSslModeRequireArgs' require: Require SSL mode.
        :param 'DestinationYellowbrickConfigurationSslModeVerifyCaArgs' verify_ca: Verify-ca SSL mode.
        :param 'DestinationYellowbrickConfigurationSslModeVerifyFullArgs' verify_full: Verify-full SSL mode.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslModeAllow']:
        """
        Allow SSL mode.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def disable(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslModeDisable']:
        """
        Disable SSL.
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def prefer(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslModePrefer']:
        """
        Prefer SSL mode.
        """
        return pulumi.get(self, "prefer")

    @property
    @pulumi.getter
    def require(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslModeRequire']:
        """
        Require SSL mode.
        """
        return pulumi.get(self, "require")

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslModeVerifyCa']:
        """
        Verify-ca SSL mode.
        """
        return pulumi.get(self, "verify_ca")

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional['outputs.DestinationYellowbrickConfigurationSslModeVerifyFull']:
        """
        Verify-full SSL mode.
        """
        return pulumi.get(self, "verify_full")


@pulumi.output_type
class DestinationYellowbrickConfigurationSslModeAllow(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationYellowbrickConfigurationSslModeDisable(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationYellowbrickConfigurationSslModePrefer(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationYellowbrickConfigurationSslModeRequire(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationYellowbrickConfigurationSslModeVerifyCa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfigurationSslModeVerifyCa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfigurationSslModeVerifyCa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfigurationSslModeVerifyCa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class DestinationYellowbrickConfigurationSslModeVerifyFull(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfigurationSslModeVerifyFull. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfigurationSslModeVerifyFull.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfigurationSslModeVerifyFull.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_certificate: str,
                 client_key: str,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_certificate: Client certificate
        :param str client_key: Client key
        :param str client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> str:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> str:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class DestinationYellowbrickConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.DestinationYellowbrickConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.DestinationYellowbrickConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class DestinationYellowbrickConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceAhaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAhaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAhaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAhaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 url: str):
        """
        :param str api_key: API Key
        :param str url: URL
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SourceAircallConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiId":
            suggest = "api_id"
        elif key == "apiToken":
            suggest = "api_token"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAircallConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAircallConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAircallConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_id: str,
                 api_token: str,
                 start_date: str):
        """
        :param str api_id: App ID found at settings https://dashboard.aircall.io/integrations/api-keys
        :param str api_token: App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
        :param str start_date: Date time filter for incremental filter, Specify which date to extract from.
        """
        pulumi.set(__self__, "api_id", api_id)
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiId")
    def api_id(self) -> str:
        """
        App ID found at settings https://dashboard.aircall.io/integrations/api-keys
        """
        return pulumi.get(self, "api_id")

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Date time filter for incremental filter, Specify which date to extract from.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceAirtableConfiguration(dict):
    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceAirtableConfigurationCredentials'] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceAirtableConfigurationCredentials']:
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceAirtableConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth20":
            suggest = "o_auth20"
        elif key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAirtableConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAirtableConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAirtableConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth20: Optional['outputs.SourceAirtableConfigurationCredentialsOAuth20'] = None,
                 personal_access_token: Optional['outputs.SourceAirtableConfigurationCredentialsPersonalAccessToken'] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceAirtableConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional['outputs.SourceAirtableConfigurationCredentialsPersonalAccessToken']:
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class SourceAirtableConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "tokenExpiryDate":
            suggest = "token_expiry_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAirtableConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAirtableConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAirtableConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 access_token: Optional[str] = None,
                 token_expiry_date: Optional[str] = None):
        """
        :param str client_id: The client ID of the Airtable developer application.
        :param str client_secret: The client secret the Airtable developer application.
        :param str refresh_token: The key to refresh the expired access token.
        :param str access_token: Access Token for making authenticated requests.
        :param str token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if token_expiry_date is not None:
            pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the Airtable developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret the Airtable developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The key to refresh the expired access token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> Optional[str]:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")


@pulumi.output_type
class SourceAirtableConfigurationCredentialsPersonalAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAirtableConfigurationCredentialsPersonalAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAirtableConfigurationCredentialsPersonalAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAirtableConfigurationCredentialsPersonalAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceAmazonAdsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "lookBackWindow":
            suggest = "look_back_window"
        elif key == "marketplaceIds":
            suggest = "marketplace_ids"
        elif key == "reportRecordTypes":
            suggest = "report_record_types"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "stateFilters":
            suggest = "state_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAmazonAdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAmazonAdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAmazonAdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 look_back_window: Optional[int] = None,
                 marketplace_ids: Optional[Sequence[str]] = None,
                 profiles: Optional[Sequence[int]] = None,
                 region: Optional[str] = None,
                 report_record_types: Optional[Sequence[str]] = None,
                 start_date: Optional[str] = None,
                 state_filters: Optional[Sequence[str]] = None):
        """
        :param str client_id: The client ID of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        :param str client_secret: The client secret of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        :param str refresh_token: Amazon Ads refresh token. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens">docs</a> for more information on how to obtain this token.
        :param int look_back_window: The amount of days to go back in time to get the updated data from Amazon Ads. Default: 3
        :param Sequence[str] marketplace_ids: Marketplace IDs you want to fetch data for. Note: If Profile IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        :param Sequence[int] profiles: Profile IDs you want to fetch data for. The Amazon Ads source connector supports only profiles with seller and vendor type, profiles with agency type will be ignored. See <a href="https://advertising.amazon.com/API/docs/en-us/concepts/authorization/profiles">docs</a> for more details. Note: If Marketplace IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        :param str region: Region to pull data from (EU/NA/FE). See <a href="https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints">docs</a> for more details. must be one of ["NA", "EU", "FE"]; Default: "NA"
        :param Sequence[str] report_record_types: Optional configuration which accepts an array of string of record types. Leave blank for default behaviour to pull all report types. Use this config option only if you want to pull specific report type(s). See <a href="https://advertising.amazon.com/API/docs/en-us/reporting/v2/report-types">docs</a> for more details
        :param str start_date: The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
        :param Sequence[str] state_filters: Reflects the state of the Display, Product, and Brand Campaign streams as enabled, paused, or archived. If you do not populate this field, it will be ignored completely.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if look_back_window is not None:
            pulumi.set(__self__, "look_back_window", look_back_window)
        if marketplace_ids is not None:
            pulumi.set(__self__, "marketplace_ids", marketplace_ids)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if report_record_types is not None:
            pulumi.set(__self__, "report_record_types", report_record_types)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if state_filters is not None:
            pulumi.set(__self__, "state_filters", state_filters)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Amazon Ads refresh token. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens">docs</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="lookBackWindow")
    def look_back_window(self) -> Optional[int]:
        """
        The amount of days to go back in time to get the updated data from Amazon Ads. Default: 3
        """
        return pulumi.get(self, "look_back_window")

    @property
    @pulumi.getter(name="marketplaceIds")
    def marketplace_ids(self) -> Optional[Sequence[str]]:
        """
        Marketplace IDs you want to fetch data for. Note: If Profile IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        """
        return pulumi.get(self, "marketplace_ids")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence[int]]:
        """
        Profile IDs you want to fetch data for. The Amazon Ads source connector supports only profiles with seller and vendor type, profiles with agency type will be ignored. See <a href="https://advertising.amazon.com/API/docs/en-us/concepts/authorization/profiles">docs</a> for more details. Note: If Marketplace IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
        """
        return pulumi.get(self, "profiles")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region to pull data from (EU/NA/FE). See <a href="https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints">docs</a> for more details. must be one of ["NA", "EU", "FE"]; Default: "NA"
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="reportRecordTypes")
    def report_record_types(self) -> Optional[Sequence[str]]:
        """
        Optional configuration which accepts an array of string of record types. Leave blank for default behaviour to pull all report types. Use this config option only if you want to pull specific report type(s). See <a href="https://advertising.amazon.com/API/docs/en-us/reporting/v2/report-types">docs</a> for more details
        """
        return pulumi.get(self, "report_record_types")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="stateFilters")
    def state_filters(self) -> Optional[Sequence[str]]:
        """
        Reflects the state of the Display, Product, and Brand Campaign streams as enabled, paused, or archived. If you do not populate this field, it will be ignored completely.
        """
        return pulumi.get(self, "state_filters")


@pulumi.output_type
class SourceAmazonSellerPartnerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lwaAppId":
            suggest = "lwa_app_id"
        elif key == "lwaClientSecret":
            suggest = "lwa_client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "accountType":
            suggest = "account_type"
        elif key == "awsEnvironment":
            suggest = "aws_environment"
        elif key == "periodInDays":
            suggest = "period_in_days"
        elif key == "replicationEndDate":
            suggest = "replication_end_date"
        elif key == "replicationStartDate":
            suggest = "replication_start_date"
        elif key == "reportOptionsLists":
            suggest = "report_options_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAmazonSellerPartnerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAmazonSellerPartnerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAmazonSellerPartnerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lwa_app_id: str,
                 lwa_client_secret: str,
                 refresh_token: str,
                 account_type: Optional[str] = None,
                 aws_environment: Optional[str] = None,
                 period_in_days: Optional[int] = None,
                 region: Optional[str] = None,
                 replication_end_date: Optional[str] = None,
                 replication_start_date: Optional[str] = None,
                 report_options_lists: Optional[Sequence['outputs.SourceAmazonSellerPartnerConfigurationReportOptionsList']] = None):
        """
        :param str lwa_app_id: Your Login with Amazon Client ID.
        :param str lwa_client_secret: Your Login with Amazon Client Secret.
        :param str refresh_token: The Refresh Token obtained via OAuth flow authorization.
        :param str account_type: Type of the Account you're going to authorize the Airbyte application by. must be one of ["Seller", "Vendor"]; Default: "Seller"
        :param str aws_environment: Select the AWS Environment. must be one of ["PRODUCTION", "SANDBOX"]; Default: "PRODUCTION"
        :param int period_in_days: For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day. Default: 90
        :param str region: Select the AWS Region. must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]; Default: "US"
        :param str replication_end_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        :param str replication_start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided, the date 2 years ago from today will be used.
        :param Sequence['SourceAmazonSellerPartnerConfigurationReportOptionsListArgs'] report_options_lists: Additional information passed to reports. This varies by report type.
        """
        pulumi.set(__self__, "lwa_app_id", lwa_app_id)
        pulumi.set(__self__, "lwa_client_secret", lwa_client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if account_type is not None:
            pulumi.set(__self__, "account_type", account_type)
        if aws_environment is not None:
            pulumi.set(__self__, "aws_environment", aws_environment)
        if period_in_days is not None:
            pulumi.set(__self__, "period_in_days", period_in_days)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if replication_end_date is not None:
            pulumi.set(__self__, "replication_end_date", replication_end_date)
        if replication_start_date is not None:
            pulumi.set(__self__, "replication_start_date", replication_start_date)
        if report_options_lists is not None:
            pulumi.set(__self__, "report_options_lists", report_options_lists)

    @property
    @pulumi.getter(name="lwaAppId")
    def lwa_app_id(self) -> str:
        """
        Your Login with Amazon Client ID.
        """
        return pulumi.get(self, "lwa_app_id")

    @property
    @pulumi.getter(name="lwaClientSecret")
    def lwa_client_secret(self) -> str:
        """
        Your Login with Amazon Client Secret.
        """
        return pulumi.get(self, "lwa_client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The Refresh Token obtained via OAuth flow authorization.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="accountType")
    def account_type(self) -> Optional[str]:
        """
        Type of the Account you're going to authorize the Airbyte application by. must be one of ["Seller", "Vendor"]; Default: "Seller"
        """
        return pulumi.get(self, "account_type")

    @property
    @pulumi.getter(name="awsEnvironment")
    def aws_environment(self) -> Optional[str]:
        """
        Select the AWS Environment. must be one of ["PRODUCTION", "SANDBOX"]; Default: "PRODUCTION"
        """
        return pulumi.get(self, "aws_environment")

    @property
    @pulumi.getter(name="periodInDays")
    def period_in_days(self) -> Optional[int]:
        """
        For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day. Default: 90
        """
        return pulumi.get(self, "period_in_days")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Select the AWS Region. must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]; Default: "US"
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="replicationEndDate")
    def replication_end_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "replication_end_date")

    @property
    @pulumi.getter(name="replicationStartDate")
    def replication_start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided, the date 2 years ago from today will be used.
        """
        return pulumi.get(self, "replication_start_date")

    @property
    @pulumi.getter(name="reportOptionsLists")
    def report_options_lists(self) -> Optional[Sequence['outputs.SourceAmazonSellerPartnerConfigurationReportOptionsList']]:
        """
        Additional information passed to reports. This varies by report type.
        """
        return pulumi.get(self, "report_options_lists")


@pulumi.output_type
class SourceAmazonSellerPartnerConfigurationReportOptionsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionsLists":
            suggest = "options_lists"
        elif key == "streamName":
            suggest = "stream_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAmazonSellerPartnerConfigurationReportOptionsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAmazonSellerPartnerConfigurationReportOptionsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAmazonSellerPartnerConfigurationReportOptionsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 options_lists: Sequence['outputs.SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList'],
                 stream_name: str):
        """
        :param Sequence['SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsListArgs'] options_lists: List of options
        :param str stream_name: must be one of ["GET_AFN_INVENTORY_DATA", "GET_AFN_INVENTORY_DATA_BY_COUNTRY", "GET_AMAZON_FULFILLED_SHIPMENTS_DATA_GENERAL", "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_RETURNS_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_PROMOTION_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_REPLACEMENT_DATA", "GET_FBA_FULFILLMENT_REMOVAL_ORDER_DETAIL_DATA", "GET_FBA_FULFILLMENT_REMOVAL_SHIPMENT_DETAIL_DATA", "GET_FBA_INVENTORY_PLANNING_DATA", "GET_FBA_MYI_UNSUPPRESSED_INVENTORY_DATA", "GET_FBA_REIMBURSEMENTS_DATA", "GET_FBA_SNS_FORECAST_DATA", "GET_FBA_SNS_PERFORMANCE_DATA", "GET_FBA_STORAGE_FEE_CHARGES_DATA", "GET_FLAT_FILE_ACTIONABLE_ORDER_DATA_SHIPPING", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_LAST_UPDATE_GENERAL", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_FLAT_FILE_ARCHIVED_ORDERS_DATA_BY_ORDER_DATE", "GET_FLAT_FILE_OPEN_LISTINGS_DATA", "GET_FLAT_FILE_RETURNS_DATA_BY_RETURN_DATE", "GET_LEDGER_DETAIL_VIEW_DATA", "GET_LEDGER_SUMMARY_VIEW_DATA", "GET_MERCHANT_CANCELLED_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_ALL_DATA", "GET_MERCHANT_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_DATA_BACK_COMPAT", "GET_MERCHANT_LISTINGS_INACTIVE_DATA", "GET_MERCHANTS_LISTINGS_FYP_REPORT", "GET_ORDER_REPORT_DATA_SHIPPING", "GET_RESTOCK_INVENTORY_RECOMMENDATIONS_REPORT", "GET_SELLER_FEEDBACK_DATA", "GET_STRANDED_INVENTORY_UI_DATA", "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE", "GET_XML_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_XML_BROWSE_TREE_DATA"]
        """
        pulumi.set(__self__, "options_lists", options_lists)
        pulumi.set(__self__, "stream_name", stream_name)

    @property
    @pulumi.getter(name="optionsLists")
    def options_lists(self) -> Sequence['outputs.SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList']:
        """
        List of options
        """
        return pulumi.get(self, "options_lists")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        must be one of ["GET_AFN_INVENTORY_DATA", "GET_AFN_INVENTORY_DATA_BY_COUNTRY", "GET_AMAZON_FULFILLED_SHIPMENTS_DATA_GENERAL", "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_RETURNS_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_PROMOTION_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_REPLACEMENT_DATA", "GET_FBA_FULFILLMENT_REMOVAL_ORDER_DETAIL_DATA", "GET_FBA_FULFILLMENT_REMOVAL_SHIPMENT_DETAIL_DATA", "GET_FBA_INVENTORY_PLANNING_DATA", "GET_FBA_MYI_UNSUPPRESSED_INVENTORY_DATA", "GET_FBA_REIMBURSEMENTS_DATA", "GET_FBA_SNS_FORECAST_DATA", "GET_FBA_SNS_PERFORMANCE_DATA", "GET_FBA_STORAGE_FEE_CHARGES_DATA", "GET_FLAT_FILE_ACTIONABLE_ORDER_DATA_SHIPPING", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_LAST_UPDATE_GENERAL", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_FLAT_FILE_ARCHIVED_ORDERS_DATA_BY_ORDER_DATE", "GET_FLAT_FILE_OPEN_LISTINGS_DATA", "GET_FLAT_FILE_RETURNS_DATA_BY_RETURN_DATE", "GET_LEDGER_DETAIL_VIEW_DATA", "GET_LEDGER_SUMMARY_VIEW_DATA", "GET_MERCHANT_CANCELLED_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_ALL_DATA", "GET_MERCHANT_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_DATA_BACK_COMPAT", "GET_MERCHANT_LISTINGS_INACTIVE_DATA", "GET_MERCHANTS_LISTINGS_FYP_REPORT", "GET_ORDER_REPORT_DATA_SHIPPING", "GET_RESTOCK_INVENTORY_RECOMMENDATIONS_REPORT", "GET_SELLER_FEEDBACK_DATA", "GET_STRANDED_INVENTORY_UI_DATA", "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE", "GET_XML_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_XML_BROWSE_TREE_DATA"]
        """
        return pulumi.get(self, "stream_name")


@pulumi.output_type
class SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "optionName":
            suggest = "option_name"
        elif key == "optionValue":
            suggest = "option_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 option_name: str,
                 option_value: str):
        pulumi.set(__self__, "option_name", option_name)
        pulumi.set(__self__, "option_value", option_value)

    @property
    @pulumi.getter(name="optionName")
    def option_name(self) -> str:
        return pulumi.get(self, "option_name")

    @property
    @pulumi.getter(name="optionValue")
    def option_value(self) -> str:
        return pulumi.get(self, "option_value")


@pulumi.output_type
class SourceAmazonSqsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "attributesToReturn":
            suggest = "attributes_to_return"
        elif key == "deleteMessages":
            suggest = "delete_messages"
        elif key == "maxBatchSize":
            suggest = "max_batch_size"
        elif key == "maxWaitTime":
            suggest = "max_wait_time"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "visibilityTimeout":
            suggest = "visibility_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAmazonSqsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAmazonSqsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAmazonSqsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: str,
                 region: str,
                 access_key: Optional[str] = None,
                 attributes_to_return: Optional[str] = None,
                 delete_messages: Optional[bool] = None,
                 max_batch_size: Optional[int] = None,
                 max_wait_time: Optional[int] = None,
                 secret_key: Optional[str] = None,
                 visibility_timeout: Optional[int] = None):
        """
        :param str queue_url: URL of the SQS Queue
        :param str region: AWS Region of the SQS Queue. must be one of ["af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
        :param str access_key: The Access Key ID of the AWS IAM Role to use for pulling messages
        :param str attributes_to_return: Comma separated list of Mesage Attribute names to return
        :param bool delete_messages: If Enabled, messages will be deleted from the SQS Queue after being read. If Disabled, messages are left in the queue and can be read more than once. WARNING: Enabling this option can result in data loss in cases of failure, use with caution, see documentation for more detail. . Default: false
        :param int max_batch_size: Max amount of messages to get in one batch (10 max)
        :param int max_wait_time: Max amount of time in seconds to wait for messages in a single poll (20 max)
        :param str secret_key: The Secret Key of the AWS IAM Role to use for pulling messages
        :param int visibility_timeout: Modify the Visibility Timeout of the individual message from the Queue's default (seconds).
        """
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "region", region)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if attributes_to_return is not None:
            pulumi.set(__self__, "attributes_to_return", attributes_to_return)
        if delete_messages is not None:
            pulumi.set(__self__, "delete_messages", delete_messages)
        if max_batch_size is not None:
            pulumi.set(__self__, "max_batch_size", max_batch_size)
        if max_wait_time is not None:
            pulumi.set(__self__, "max_wait_time", max_wait_time)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if visibility_timeout is not None:
            pulumi.set(__self__, "visibility_timeout", visibility_timeout)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> str:
        """
        URL of the SQS Queue
        """
        return pulumi.get(self, "queue_url")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        AWS Region of the SQS Queue. must be one of ["af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The Access Key ID of the AWS IAM Role to use for pulling messages
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="attributesToReturn")
    def attributes_to_return(self) -> Optional[str]:
        """
        Comma separated list of Mesage Attribute names to return
        """
        return pulumi.get(self, "attributes_to_return")

    @property
    @pulumi.getter(name="deleteMessages")
    def delete_messages(self) -> Optional[bool]:
        """
        If Enabled, messages will be deleted from the SQS Queue after being read. If Disabled, messages are left in the queue and can be read more than once. WARNING: Enabling this option can result in data loss in cases of failure, use with caution, see documentation for more detail. . Default: false
        """
        return pulumi.get(self, "delete_messages")

    @property
    @pulumi.getter(name="maxBatchSize")
    def max_batch_size(self) -> Optional[int]:
        """
        Max amount of messages to get in one batch (10 max)
        """
        return pulumi.get(self, "max_batch_size")

    @property
    @pulumi.getter(name="maxWaitTime")
    def max_wait_time(self) -> Optional[int]:
        """
        Max amount of time in seconds to wait for messages in a single poll (20 max)
        """
        return pulumi.get(self, "max_wait_time")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        The Secret Key of the AWS IAM Role to use for pulling messages
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="visibilityTimeout")
    def visibility_timeout(self) -> Optional[int]:
        """
        Modify the Visibility Timeout of the individual message from the Queue's default (seconds).
        """
        return pulumi.get(self, "visibility_timeout")


@pulumi.output_type
class SourceAmplitudeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "dataRegion":
            suggest = "data_region"
        elif key == "requestTimeRange":
            suggest = "request_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAmplitudeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAmplitudeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAmplitudeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 secret_key: str,
                 start_date: str,
                 data_region: Optional[str] = None,
                 request_time_range: Optional[int] = None):
        """
        :param str api_key: Amplitude API Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        :param str secret_key: Amplitude Secret Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        :param str start_date: UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param str data_region: Amplitude data region server. must be one of ["Standard Server", "EU Residency Server"]; Default: "Standard Server"
        :param int request_time_range: According to <a href="https://www.docs.developers.amplitude.com/analytics/apis/export-api/#considerations">Considerations</a> too big time range in request can cause a timeout error. In this case, set shorter time interval in hours. Default: 24
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)
        if data_region is not None:
            pulumi.set(__self__, "data_region", data_region)
        if request_time_range is not None:
            pulumi.set(__self__, "request_time_range", request_time_range)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Amplitude API Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Amplitude Secret Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="dataRegion")
    def data_region(self) -> Optional[str]:
        """
        Amplitude data region server. must be one of ["Standard Server", "EU Residency Server"]; Default: "Standard Server"
        """
        return pulumi.get(self, "data_region")

    @property
    @pulumi.getter(name="requestTimeRange")
    def request_time_range(self) -> Optional[int]:
        """
        According to <a href="https://www.docs.developers.amplitude.com/analytics/apis/export-api/#considerations">Considerations</a> too big time range in request can cause a timeout error. In this case, set shorter time interval in hours. Default: 24
        """
        return pulumi.get(self, "request_time_range")


@pulumi.output_type
class SourceApifyDatasetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceApifyDatasetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceApifyDatasetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceApifyDatasetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: str,
                 token: str):
        """
        :param str dataset_id: ID of the dataset you would like to load to Airbyte. In Apify Console, you can view your datasets in the <a href="https://console.apify.com/storage/datasets">Storage section under the Datasets tab</a> after you login. See the <a href="https://docs.apify.com/platform/storage/dataset">Apify Docs</a> for more information.
        :param str token: Personal API token of your Apify account. In Apify Console, you can find your API token in the <a href="https://console.apify.com/account/integrations">Settings section under the Integrations tab</a> after you login. See the <a href="https://docs.apify.com/platform/integrations/api#api-token">Apify Docs</a> for more information.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        ID of the dataset you would like to load to Airbyte. In Apify Console, you can view your datasets in the <a href="https://console.apify.com/storage/datasets">Storage section under the Datasets tab</a> after you login. See the <a href="https://docs.apify.com/platform/storage/dataset">Apify Docs</a> for more information.
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Personal API token of your Apify account. In Apify Console, you can find your API token in the <a href="https://console.apify.com/account/integrations">Settings section under the Integrations tab</a> after you login. See the <a href="https://docs.apify.com/platform/integrations/api#api-token">Apify Docs</a> for more information.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class SourceAppfollowConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecret":
            suggest = "api_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAppfollowConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAppfollowConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAppfollowConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret: Optional[str] = None):
        """
        :param str api_secret: API Key provided by Appfollow
        """
        if api_secret is not None:
            pulumi.set(__self__, "api_secret", api_secret)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> Optional[str]:
        """
        API Key provided by Appfollow
        """
        return pulumi.get(self, "api_secret")


@pulumi.output_type
class SourceAsanaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationExportIds":
            suggest = "organization_export_ids"
        elif key == "testMode":
            suggest = "test_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAsanaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAsanaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAsanaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceAsanaConfigurationCredentials'] = None,
                 organization_export_ids: Optional[Sequence[str]] = None,
                 test_mode: Optional[bool] = None):
        """
        :param 'SourceAsanaConfigurationCredentialsArgs' credentials: Choose how to authenticate to Github
        :param Sequence[str] organization_export_ids: Globally unique identifiers for the organization exports
        :param bool test_mode: This flag is used for testing purposes for certain streams that return a lot of data. This flag is not meant to be enabled for prod.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if organization_export_ids is not None:
            pulumi.set(__self__, "organization_export_ids", organization_export_ids)
        if test_mode is not None:
            pulumi.set(__self__, "test_mode", test_mode)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceAsanaConfigurationCredentials']:
        """
        Choose how to authenticate to Github
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="organizationExportIds")
    def organization_export_ids(self) -> Optional[Sequence[str]]:
        """
        Globally unique identifiers for the organization exports
        """
        return pulumi.get(self, "organization_export_ids")

    @property
    @pulumi.getter(name="testMode")
    def test_mode(self) -> Optional[bool]:
        """
        This flag is used for testing purposes for certain streams that return a lot of data. This flag is not meant to be enabled for prod.
        """
        return pulumi.get(self, "test_mode")


@pulumi.output_type
class SourceAsanaConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaAsanaOauth":
            suggest = "authenticate_via_asana_oauth"
        elif key == "authenticateWithPersonalAccessToken":
            suggest = "authenticate_with_personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAsanaConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAsanaConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAsanaConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_asana_oauth: Optional['outputs.SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth'] = None,
                 authenticate_with_personal_access_token: Optional['outputs.SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken'] = None):
        if authenticate_via_asana_oauth is not None:
            pulumi.set(__self__, "authenticate_via_asana_oauth", authenticate_via_asana_oauth)
        if authenticate_with_personal_access_token is not None:
            pulumi.set(__self__, "authenticate_with_personal_access_token", authenticate_with_personal_access_token)

    @property
    @pulumi.getter(name="authenticateViaAsanaOauth")
    def authenticate_via_asana_oauth(self) -> Optional['outputs.SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth']:
        return pulumi.get(self, "authenticate_via_asana_oauth")

    @property
    @pulumi.getter(name="authenticateWithPersonalAccessToken")
    def authenticate_with_personal_access_token(self) -> Optional['outputs.SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken']:
        return pulumi.get(self, "authenticate_with_personal_access_token")


@pulumi.output_type
class SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: str):
        """
        :param str personal_access_token: Asana Personal Access Token (generate yours <a href="https://app.asana.com/0/developer-console">here</a>).
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> str:
        """
        Asana Personal Access Token (generate yours <a href="https://app.asana.com/0/developer-console">here</a>).
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class SourceAuth0Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAuth0Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAuth0Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAuth0Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: str,
                 credentials: 'outputs.SourceAuth0ConfigurationCredentials',
                 start_date: Optional[str] = None):
        """
        :param str base_url: The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Default: "2023-08-05T00:43:59.244Z"
        """
        pulumi.set(__self__, "base_url", base_url)
        pulumi.set(__self__, "credentials", credentials)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> str:
        """
        The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceAuth0ConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Default: "2023-08-05T00:43:59.244Z"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceAuth0ConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth2AccessToken":
            suggest = "o_auth2_access_token"
        elif key == "oAuth2ConfidentialApplication":
            suggest = "o_auth2_confidential_application"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAuth0ConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAuth0ConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAuth0ConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth2_access_token: Optional['outputs.SourceAuth0ConfigurationCredentialsOAuth2AccessToken'] = None,
                 o_auth2_confidential_application: Optional['outputs.SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication'] = None):
        if o_auth2_access_token is not None:
            pulumi.set(__self__, "o_auth2_access_token", o_auth2_access_token)
        if o_auth2_confidential_application is not None:
            pulumi.set(__self__, "o_auth2_confidential_application", o_auth2_confidential_application)

    @property
    @pulumi.getter(name="oAuth2AccessToken")
    def o_auth2_access_token(self) -> Optional['outputs.SourceAuth0ConfigurationCredentialsOAuth2AccessToken']:
        return pulumi.get(self, "o_auth2_access_token")

    @property
    @pulumi.getter(name="oAuth2ConfidentialApplication")
    def o_auth2_confidential_application(self) -> Optional['outputs.SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication']:
        return pulumi.get(self, "o_auth2_confidential_application")


@pulumi.output_type
class SourceAuth0ConfigurationCredentialsOAuth2AccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAuth0ConfigurationCredentialsOAuth2AccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAuth0ConfigurationCredentialsOAuth2AccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAuth0ConfigurationCredentialsOAuth2AccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: Also called <a href="https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-testing">API Access Token </a> The access token used to call the Auth0 Management API Token. It's a JWT that contains specific grant permissions knowns as scopes.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Also called <a href="https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-testing">API Access Token </a> The access token used to call the Auth0 Management API Token. It's a JWT that contains specific grant permissions knowns as scopes.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: str,
                 client_id: str,
                 client_secret: str):
        """
        :param str audience: The audience for the token, which is your API. You can find this in the Identifier field on your  <a href="https://manage.auth0.com/#/apis">API's settings tab</a>
        :param str client_id: Your application's Client ID. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        :param str client_secret: Your application's Client Secret. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        """
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        The audience for the token, which is your API. You can find this in the Identifier field on your  <a href="https://manage.auth0.com/#/apis">API's settings tab</a>
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your application's Client ID. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Your application's Client Secret. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceAwsCloudtrailConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsKeyId":
            suggest = "aws_key_id"
        elif key == "awsRegionName":
            suggest = "aws_region_name"
        elif key == "awsSecretKey":
            suggest = "aws_secret_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAwsCloudtrailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAwsCloudtrailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAwsCloudtrailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_key_id: str,
                 aws_region_name: str,
                 aws_secret_key: str,
                 start_date: Optional[str] = None):
        """
        :param str aws_key_id: AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        :param str aws_region_name: The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name.
        :param str aws_secret_key: AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        :param str start_date: The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD. Default: "1970-01-01"
        """
        pulumi.set(__self__, "aws_key_id", aws_key_id)
        pulumi.set(__self__, "aws_region_name", aws_region_name)
        pulumi.set(__self__, "aws_secret_key", aws_secret_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="awsKeyId")
    def aws_key_id(self) -> str:
        """
        AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "aws_key_id")

    @property
    @pulumi.getter(name="awsRegionName")
    def aws_region_name(self) -> str:
        """
        The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name.
        """
        return pulumi.get(self, "aws_region_name")

    @property
    @pulumi.getter(name="awsSecretKey")
    def aws_secret_key(self) -> str:
        """
        AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "aws_secret_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD. Default: "1970-01-01"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceAzureBlobStorageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorageAccountName":
            suggest = "azure_blob_storage_account_name"
        elif key == "azureBlobStorageContainerName":
            suggest = "azure_blob_storage_container_name"
        elif key == "azureBlobStorageEndpoint":
            suggest = "azure_blob_storage_endpoint"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage_account_name: str,
                 azure_blob_storage_container_name: str,
                 credentials: 'outputs.SourceAzureBlobStorageConfigurationCredentials',
                 streams: Sequence['outputs.SourceAzureBlobStorageConfigurationStream'],
                 azure_blob_storage_endpoint: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str azure_blob_storage_account_name: The account's name of the Azure Blob Storage.
        :param str azure_blob_storage_container_name: The name of the Azure blob storage container.
        :param 'SourceAzureBlobStorageConfigurationCredentialsArgs' credentials: Credentials for connecting to the Azure Blob Storage
        :param Sequence['SourceAzureBlobStorageConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str azure_blob_storage_endpoint: This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "azure_blob_storage_account_name", azure_blob_storage_account_name)
        pulumi.set(__self__, "azure_blob_storage_container_name", azure_blob_storage_container_name)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "streams", streams)
        if azure_blob_storage_endpoint is not None:
            pulumi.set(__self__, "azure_blob_storage_endpoint", azure_blob_storage_endpoint)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="azureBlobStorageAccountName")
    def azure_blob_storage_account_name(self) -> str:
        """
        The account's name of the Azure Blob Storage.
        """
        return pulumi.get(self, "azure_blob_storage_account_name")

    @property
    @pulumi.getter(name="azureBlobStorageContainerName")
    def azure_blob_storage_container_name(self) -> str:
        """
        The name of the Azure blob storage container.
        """
        return pulumi.get(self, "azure_blob_storage_container_name")

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceAzureBlobStorageConfigurationCredentials':
        """
        Credentials for connecting to the Azure Blob Storage
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceAzureBlobStorageConfigurationStream']:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="azureBlobStorageEndpoint")
    def azure_blob_storage_endpoint(self) -> Optional[str]:
        """
        This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
        """
        return pulumi.get(self, "azure_blob_storage_endpoint")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaOauth2":
            suggest = "authenticate_via_oauth2"
        elif key == "authenticateViaStorageAccountKey":
            suggest = "authenticate_via_storage_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_oauth2: Optional['outputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2'] = None,
                 authenticate_via_storage_account_key: Optional['outputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey'] = None):
        if authenticate_via_oauth2 is not None:
            pulumi.set(__self__, "authenticate_via_oauth2", authenticate_via_oauth2)
        if authenticate_via_storage_account_key is not None:
            pulumi.set(__self__, "authenticate_via_storage_account_key", authenticate_via_storage_account_key)

    @property
    @pulumi.getter(name="authenticateViaOauth2")
    def authenticate_via_oauth2(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2']:
        return pulumi.get(self, "authenticate_via_oauth2")

    @property
    @pulumi.getter(name="authenticateViaStorageAccountKey")
    def authenticate_via_storage_account_key(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey']:
        return pulumi.get(self, "authenticate_via_storage_account_key")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 tenant_id: str):
        """
        :param str client_id: Client ID of your Microsoft developer application
        :param str client_secret: Client Secret of your Microsoft developer application
        :param str refresh_token: Refresh Token of your Microsoft developer application
        :param str tenant_id: Tenant ID of the Microsoft Azure Application user
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token of your Microsoft developer application
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID of the Microsoft Azure Application user
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureBlobStorageAccountKey":
            suggest = "azure_blob_storage_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_blob_storage_account_key: str):
        """
        :param str azure_blob_storage_account_key: The Azure blob storage account key.
        """
        pulumi.set(__self__, "azure_blob_storage_account_key", azure_blob_storage_account_key)

    @property
    @pulumi.getter(name="azureBlobStorageAccountKey")
    def azure_blob_storage_account_key(self) -> str:
        """
        The Azure blob storage account key.
        """
        return pulumi.get(self, "azure_blob_storage_account_key")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "legacyPrefix":
            suggest = "legacy_prefix"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceAzureBlobStorageConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 legacy_prefix: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceAzureBlobStorageConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str legacy_prefix: The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceAzureBlobStorageConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[str]:
        """
        The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFormat":
            suggest = "avro_format"
        elif key == "csvFormat":
            suggest = "csv_format"
        elif key == "documentFileTypeFormatExperimental":
            suggest = "document_file_type_format_experimental"
        elif key == "jsonlFormat":
            suggest = "jsonl_format"
        elif key == "parquetFormat":
            suggest = "parquet_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_format: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatAvroFormat'] = None,
                 csv_format: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormat'] = None,
                 document_file_type_format_experimental: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental'] = None,
                 jsonl_format: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatJsonlFormat'] = None,
                 parquet_format: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatParquetFormat'] = None):
        """
        :param 'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs' document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatAvroFormat']:
        return pulumi.get(self, "avro_format")

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental']:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatJsonlFormat']:
        return pulumi.get(self, "jsonl_format")

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatParquetFormat']:
        return pulumi.get(self, "parquet_format")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatAvroFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleAsString":
            suggest = "double_as_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormatAvroFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_as_string: Optional[bool] = None):
        """
        :param bool double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[bool]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "ignoreErrorsOnFieldsMismatch":
            suggest = "ignore_errors_on_fields_mismatch"
        elif key == "inferenceType":
            suggest = "inference_type"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 ignore_errors_on_fields_mismatch: Optional[bool] = None,
                 inference_type: Optional[str] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param bool ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param str inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[bool]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[str]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnprocessableFiles":
            suggest = "skip_unprocessable_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processing: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing'] = None,
                 skip_unprocessable_files: Optional[bool] = None,
                 strategy: Optional[str] = None):
        """
        :param 'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs' processing: Processing configuration
        :param bool skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param str strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing']:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[bool]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing(dict):
    def __init__(__self__, *,
                 local: Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal'] = None):
        """
        :param 'SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs' local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal']:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatJsonlFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceAzureBlobStorageConfigurationStreamFormatParquetFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalAsFloat":
            suggest = "decimal_as_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureBlobStorageConfigurationStreamFormatParquetFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureBlobStorageConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_as_float: Optional[bool] = None):
        """
        :param bool decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[bool]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")


@pulumi.output_type
class SourceAzureTableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccessKey":
            suggest = "storage_access_key"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "storageEndpointSuffix":
            suggest = "storage_endpoint_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceAzureTableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceAzureTableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceAzureTableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_access_key: str,
                 storage_account_name: str,
                 storage_endpoint_suffix: Optional[str] = None):
        """
        :param str storage_access_key: Azure Table Storage Access Key. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain this key.
        :param str storage_account_name: The name of your storage account.
        :param str storage_endpoint_suffix: Azure Table Storage service account URL suffix. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain endpoint suffix. Default: "core.windows.net"
        """
        pulumi.set(__self__, "storage_access_key", storage_access_key)
        pulumi.set(__self__, "storage_account_name", storage_account_name)
        if storage_endpoint_suffix is not None:
            pulumi.set(__self__, "storage_endpoint_suffix", storage_endpoint_suffix)

    @property
    @pulumi.getter(name="storageAccessKey")
    def storage_access_key(self) -> str:
        """
        Azure Table Storage Access Key. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "storage_access_key")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> str:
        """
        The name of your storage account.
        """
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="storageEndpointSuffix")
    def storage_endpoint_suffix(self) -> Optional[str]:
        """
        Azure Table Storage service account URL suffix. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain endpoint suffix. Default: "core.windows.net"
        """
        return pulumi.get(self, "storage_endpoint_suffix")


@pulumi.output_type
class SourceBambooHrConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "customReportsFields":
            suggest = "custom_reports_fields"
        elif key == "customReportsIncludeDefaultFields":
            suggest = "custom_reports_include_default_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceBambooHrConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceBambooHrConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceBambooHrConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 subdomain: str,
                 custom_reports_fields: Optional[str] = None,
                 custom_reports_include_default_fields: Optional[bool] = None):
        """
        :param str api_key: Api key of bamboo hr
        :param str subdomain: Sub Domain of bamboo hr
        :param str custom_reports_fields: Comma-separated list of fields to include in custom reports. Default: ""
        :param bool custom_reports_include_default_fields: If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names. Default: true
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "subdomain", subdomain)
        if custom_reports_fields is not None:
            pulumi.set(__self__, "custom_reports_fields", custom_reports_fields)
        if custom_reports_include_default_fields is not None:
            pulumi.set(__self__, "custom_reports_include_default_fields", custom_reports_include_default_fields)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Api key of bamboo hr
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        Sub Domain of bamboo hr
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter(name="customReportsFields")
    def custom_reports_fields(self) -> Optional[str]:
        """
        Comma-separated list of fields to include in custom reports. Default: ""
        """
        return pulumi.get(self, "custom_reports_fields")

    @property
    @pulumi.getter(name="customReportsIncludeDefaultFields")
    def custom_reports_include_default_fields(self) -> Optional[bool]:
        """
        If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names. Default: true
        """
        return pulumi.get(self, "custom_reports_include_default_fields")


@pulumi.output_type
class SourceBigqueryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsJson":
            suggest = "credentials_json"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "datasetId":
            suggest = "dataset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceBigqueryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceBigqueryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceBigqueryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_json: str,
                 project_id: str,
                 dataset_id: Optional[str] = None):
        """
        :param str credentials_json: The contents of your Service Account Key JSON file. See the <a href="https://docs.airbyte.com/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte">docs</a> for more information on how to obtain this key.
        :param str project_id: The GCP project ID for the project containing the target BigQuery dataset.
        :param str dataset_id: The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
        """
        pulumi.set(__self__, "credentials_json", credentials_json)
        pulumi.set(__self__, "project_id", project_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> str:
        """
        The contents of your Service Account Key JSON file. See the <a href="https://docs.airbyte.com/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "credentials_json")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The GCP project ID for the project containing the target BigQuery dataset.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[str]:
        """
        The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
        """
        return pulumi.get(self, "dataset_id")


@pulumi.output_type
class SourceBingAdsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "developerToken":
            suggest = "developer_token"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "accountNames":
            suggest = "account_names"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customReports":
            suggest = "custom_reports"
        elif key == "lookbackWindow":
            suggest = "lookback_window"
        elif key == "reportsStartDate":
            suggest = "reports_start_date"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceBingAdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceBingAdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceBingAdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 developer_token: str,
                 refresh_token: str,
                 account_names: Optional[Sequence['outputs.SourceBingAdsConfigurationAccountName']] = None,
                 client_secret: Optional[str] = None,
                 custom_reports: Optional[Sequence['outputs.SourceBingAdsConfigurationCustomReport']] = None,
                 lookback_window: Optional[int] = None,
                 reports_start_date: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Microsoft Advertising developer application.
        :param str developer_token: Developer token associated with user. See more info <a href="https://docs.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13#get-developer-token"> in the docs</a>.
        :param str refresh_token: Refresh Token to renew the expired Access Token.
        :param Sequence['SourceBingAdsConfigurationAccountNameArgs'] account_names: Predicates that will be used to sync data by specific accounts.
        :param str client_secret: The Client Secret of your Microsoft Advertising developer application. Default: ""
        :param Sequence['SourceBingAdsConfigurationCustomReportArgs'] custom_reports: You can add your Custom Bing Ads report by creating one.
        :param int lookback_window: Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode without specified Reports Start Date. Default: 0
        :param str reports_start_date: The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format. If not set, data from previous and current calendar year will be replicated.
        :param str tenant_id: The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value. Default: "common"
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "developer_token", developer_token)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if account_names is not None:
            pulumi.set(__self__, "account_names", account_names)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if lookback_window is not None:
            pulumi.set(__self__, "lookback_window", lookback_window)
        if reports_start_date is not None:
            pulumi.set(__self__, "reports_start_date", reports_start_date)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Microsoft Advertising developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> str:
        """
        Developer token associated with user. See more info <a href="https://docs.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13#get-developer-token"> in the docs</a>.
        """
        return pulumi.get(self, "developer_token")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="accountNames")
    def account_names(self) -> Optional[Sequence['outputs.SourceBingAdsConfigurationAccountName']]:
        """
        Predicates that will be used to sync data by specific accounts.
        """
        return pulumi.get(self, "account_names")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of your Microsoft Advertising developer application. Default: ""
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[Sequence['outputs.SourceBingAdsConfigurationCustomReport']]:
        """
        You can add your Custom Bing Ads report by creating one.
        """
        return pulumi.get(self, "custom_reports")

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional[int]:
        """
        Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode without specified Reports Start Date. Default: 0
        """
        return pulumi.get(self, "lookback_window")

    @property
    @pulumi.getter(name="reportsStartDate")
    def reports_start_date(self) -> Optional[str]:
        """
        The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format. If not set, data from previous and current calendar year will be replicated.
        """
        return pulumi.get(self, "reports_start_date")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value. Default: "common"
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SourceBingAdsConfigurationAccountName(dict):
    def __init__(__self__, *,
                 name: str,
                 operator: str):
        """
        :param str name: Account Name is a string value for comparing with the specified predicate.
        :param str operator: An Operator that will be used to filter accounts. The Contains predicate has features for matching words, matching inflectional forms of words, searching using wildcard characters, and searching using proximity. The Equals is used to return all rows where account name is equal(=) to the string that you provided. must be one of ["Contains", "Equals"]
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Account Name is a string value for comparing with the specified predicate.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        An Operator that will be used to filter accounts. The Contains predicate has features for matching words, matching inflectional forms of words, searching using wildcard characters, and searching using proximity. The Equals is used to return all rows where account name is equal(=) to the string that you provided. must be one of ["Contains", "Equals"]
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class SourceBingAdsConfigurationCustomReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reportColumns":
            suggest = "report_columns"
        elif key == "reportingObject":
            suggest = "reporting_object"
        elif key == "reportAggregation":
            suggest = "report_aggregation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceBingAdsConfigurationCustomReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceBingAdsConfigurationCustomReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceBingAdsConfigurationCustomReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 report_columns: Sequence[str],
                 reporting_object: str,
                 report_aggregation: Optional[str] = None):
        """
        :param str name: The name of the custom report, this name would be used as stream name
        :param Sequence[str] report_columns: A list of available report object columns. You can find it in description of reporting object that you want to add to custom report.
        :param str reporting_object: The name of the the object derives from the ReportRequest object. You can find it in Bing Ads Api docs - Reporting API - Reporting Data Objects. must be one of ["AccountPerformanceReportRequest", "AdDynamicTextPerformanceReportRequest", "AdExtensionByAdReportRequest", "AdExtensionByKeywordReportRequest", "AdExtensionDetailReportRequest", "AdGroupPerformanceReportRequest", "AdPerformanceReportRequest", "AgeGenderAudienceReportRequest", "AudiencePerformanceReportRequest", "CallDetailReportRequest", "CampaignPerformanceReportRequest", "ConversionPerformanceReportRequest", "DestinationUrlPerformanceReportRequest", "DSAAutoTargetPerformanceReportRequest", "DSACategoryPerformanceReportRequest", "DSASearchQueryPerformanceReportRequest", "GeographicPerformanceReportRequest", "GoalsAndFunnelsReportRequest", "HotelDimensionPerformanceReportRequest", "HotelGroupPerformanceReportRequest", "KeywordPerformanceReportRequest", "NegativeKeywordConflictReportRequest", "ProductDimensionPerformanceReportRequest", "ProductMatchCountReportRequest", "ProductNegativeKeywordConflictReportRequest", "ProductPartitionPerformanceReportRequest", "ProductPartitionUnitPerformanceReportRequest", "ProductSearchQueryPerformanceReportRequest", "ProfessionalDemographicsAudienceReportRequest", "PublisherUsagePerformanceReportRequest", "SearchCampaignChangeHistoryReportRequest", "SearchQueryPerformanceReportRequest", "ShareOfVoiceReportRequest", "UserLocationPerformanceReportRequest"]
        :param str report_aggregation: A list of available aggregations. Default: "[Hourly]"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "report_columns", report_columns)
        pulumi.set(__self__, "reporting_object", reporting_object)
        if report_aggregation is not None:
            pulumi.set(__self__, "report_aggregation", report_aggregation)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom report, this name would be used as stream name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="reportColumns")
    def report_columns(self) -> Sequence[str]:
        """
        A list of available report object columns. You can find it in description of reporting object that you want to add to custom report.
        """
        return pulumi.get(self, "report_columns")

    @property
    @pulumi.getter(name="reportingObject")
    def reporting_object(self) -> str:
        """
        The name of the the object derives from the ReportRequest object. You can find it in Bing Ads Api docs - Reporting API - Reporting Data Objects. must be one of ["AccountPerformanceReportRequest", "AdDynamicTextPerformanceReportRequest", "AdExtensionByAdReportRequest", "AdExtensionByKeywordReportRequest", "AdExtensionDetailReportRequest", "AdGroupPerformanceReportRequest", "AdPerformanceReportRequest", "AgeGenderAudienceReportRequest", "AudiencePerformanceReportRequest", "CallDetailReportRequest", "CampaignPerformanceReportRequest", "ConversionPerformanceReportRequest", "DestinationUrlPerformanceReportRequest", "DSAAutoTargetPerformanceReportRequest", "DSACategoryPerformanceReportRequest", "DSASearchQueryPerformanceReportRequest", "GeographicPerformanceReportRequest", "GoalsAndFunnelsReportRequest", "HotelDimensionPerformanceReportRequest", "HotelGroupPerformanceReportRequest", "KeywordPerformanceReportRequest", "NegativeKeywordConflictReportRequest", "ProductDimensionPerformanceReportRequest", "ProductMatchCountReportRequest", "ProductNegativeKeywordConflictReportRequest", "ProductPartitionPerformanceReportRequest", "ProductPartitionUnitPerformanceReportRequest", "ProductSearchQueryPerformanceReportRequest", "ProfessionalDemographicsAudienceReportRequest", "PublisherUsagePerformanceReportRequest", "SearchCampaignChangeHistoryReportRequest", "SearchQueryPerformanceReportRequest", "ShareOfVoiceReportRequest", "UserLocationPerformanceReportRequest"]
        """
        return pulumi.get(self, "reporting_object")

    @property
    @pulumi.getter(name="reportAggregation")
    def report_aggregation(self) -> Optional[str]:
        """
        A list of available aggregations. Default: "[Hourly]"
        """
        return pulumi.get(self, "report_aggregation")


@pulumi.output_type
class SourceBraintreeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "merchantId":
            suggest = "merchant_id"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "publicKey":
            suggest = "public_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceBraintreeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceBraintreeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceBraintreeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment: str,
                 merchant_id: str,
                 private_key: str,
                 public_key: str,
                 start_date: Optional[str] = None):
        """
        :param str environment: Environment specifies where the data will come from. must be one of ["Development", "Sandbox", "Qa", "Production"]
        :param str merchant_id: The unique identifier for your entire gateway account. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this ID.
        :param str private_key: Braintree Private Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        :param str public_key: Braintree Public Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "merchant_id", merchant_id)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "public_key", public_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Environment specifies where the data will come from. must be one of ["Development", "Sandbox", "Qa", "Production"]
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="merchantId")
    def merchant_id(self) -> str:
        """
        The unique identifier for your entire gateway account. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this ID.
        """
        return pulumi.get(self, "merchant_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Braintree Private Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        """
        Braintree Public Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceBrazeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceBrazeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceBrazeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceBrazeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str,
                 url: str):
        """
        :param str api_key: Braze REST API key
        :param str start_date: Rows after this date will be synced
        :param str url: Braze REST API endpoint
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Braze REST API key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Rows after this date will be synced
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Braze REST API endpoint
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SourceCartConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCartConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCartConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCartConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 credentials: Optional['outputs.SourceCartConfigurationCredentials'] = None):
        """
        :param str start_date: The date from which you'd like to replicate the data
        """
        pulumi.set(__self__, "start_date", start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate the data
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceCartConfigurationCredentials']:
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceCartConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "centralApiRouter":
            suggest = "central_api_router"
        elif key == "singleStoreAccessToken":
            suggest = "single_store_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCartConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCartConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCartConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 central_api_router: Optional['outputs.SourceCartConfigurationCredentialsCentralApiRouter'] = None,
                 single_store_access_token: Optional['outputs.SourceCartConfigurationCredentialsSingleStoreAccessToken'] = None):
        if central_api_router is not None:
            pulumi.set(__self__, "central_api_router", central_api_router)
        if single_store_access_token is not None:
            pulumi.set(__self__, "single_store_access_token", single_store_access_token)

    @property
    @pulumi.getter(name="centralApiRouter")
    def central_api_router(self) -> Optional['outputs.SourceCartConfigurationCredentialsCentralApiRouter']:
        return pulumi.get(self, "central_api_router")

    @property
    @pulumi.getter(name="singleStoreAccessToken")
    def single_store_access_token(self) -> Optional['outputs.SourceCartConfigurationCredentialsSingleStoreAccessToken']:
        return pulumi.get(self, "single_store_access_token")


@pulumi.output_type
class SourceCartConfigurationCredentialsCentralApiRouter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteId":
            suggest = "site_id"
        elif key == "userName":
            suggest = "user_name"
        elif key == "userSecret":
            suggest = "user_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCartConfigurationCredentialsCentralApiRouter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCartConfigurationCredentialsCentralApiRouter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCartConfigurationCredentialsCentralApiRouter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_id: str,
                 user_name: str,
                 user_secret: str):
        """
        :param str site_id: You can determine a site provisioning site Id by hitting https://site.com/store/sitemonitor.aspx and reading the response param PSID
        :param str user_name: Enter your application's User Name
        :param str user_secret: Enter your application's User Secret
        """
        pulumi.set(__self__, "site_id", site_id)
        pulumi.set(__self__, "user_name", user_name)
        pulumi.set(__self__, "user_secret", user_secret)

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        """
        You can determine a site provisioning site Id by hitting https://site.com/store/sitemonitor.aspx and reading the response param PSID
        """
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        Enter your application's User Name
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="userSecret")
    def user_secret(self) -> str:
        """
        Enter your application's User Secret
        """
        return pulumi.get(self, "user_secret")


@pulumi.output_type
class SourceCartConfigurationCredentialsSingleStoreAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCartConfigurationCredentialsSingleStoreAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCartConfigurationCredentialsSingleStoreAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCartConfigurationCredentialsSingleStoreAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 store_name: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str store_name: The name of Cart.com Online Store. All API URLs start with https://[mystorename.com]/api/v1/, where [mystorename.com] is the domain name of your store.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "store_name", store_name)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        """
        The name of Cart.com Online Store. All API URLs start with https://[mystorename.com]/api/v1/, where [mystorename.com] is the domain name of your store.
        """
        return pulumi.get(self, "store_name")


@pulumi.output_type
class SourceChargebeeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteApiKey":
            suggest = "site_api_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "productCatalog":
            suggest = "product_catalog"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceChargebeeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceChargebeeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceChargebeeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site: str,
                 site_api_key: str,
                 start_date: str,
                 product_catalog: Optional[str] = None):
        """
        :param str site: The site prefix for your Chargebee instance.
        :param str site_api_key: Chargebee API Key. See the <a href="https://docs.airbyte.com/integrations/sources/chargebee">docs</a> for more information on how to obtain this key.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
        :param str product_catalog: Product Catalog version of your Chargebee site. Instructions on how to find your version you may find <a href="https://apidocs.chargebee.com/docs/api?prod_cat_ver=2">here</a> under `API Version` section. If left blank, the product catalog version will be set to 2.0. must be one of ["1.0", "2.0"]; Default: "2.0"
        """
        pulumi.set(__self__, "site", site)
        pulumi.set(__self__, "site_api_key", site_api_key)
        pulumi.set(__self__, "start_date", start_date)
        if product_catalog is not None:
            pulumi.set(__self__, "product_catalog", product_catalog)

    @property
    @pulumi.getter
    def site(self) -> str:
        """
        The site prefix for your Chargebee instance.
        """
        return pulumi.get(self, "site")

    @property
    @pulumi.getter(name="siteApiKey")
    def site_api_key(self) -> str:
        """
        Chargebee API Key. See the <a href="https://docs.airbyte.com/integrations/sources/chargebee">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "site_api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="productCatalog")
    def product_catalog(self) -> Optional[str]:
        """
        Product Catalog version of your Chargebee site. Instructions on how to find your version you may find <a href="https://apidocs.chargebee.com/docs/api?prod_cat_ver=2">here</a> under `API Version` section. If left blank, the product catalog version will be set to 2.0. must be one of ["1.0", "2.0"]; Default: "2.0"
        """
        return pulumi.get(self, "product_catalog")


@pulumi.output_type
class SourceChartmogulConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceChartmogulConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceChartmogulConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceChartmogulConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str):
        """
        :param str api_key: Your Chartmogul API key. See <a href="https://help.chartmogul.com/hc/en-us/articles/4407796325906-Creating-and-Managing-API-keys#creating-an-api-key"> the docs </a> for info on how to obtain this.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your Chartmogul API key. See <a href="https://help.chartmogul.com/hc/en-us/articles/4407796325906-Creating-and-Managing-API-keys#creating-an-api-key"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceClickhouseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceClickhouseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceClickhouseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceClickhouseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 tunnel_method: Optional['outputs.SourceClickhouseConfigurationTunnelMethod'] = None):
        """
        :param str database: The name of the database.
        :param str host: The host endpoint of the Clickhouse cluster.
        :param str username: The username which is used to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        :param str password: The password associated with this username.
        :param int port: The port of the database. Default: 8123
        :param 'SourceClickhouseConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host endpoint of the Clickhouse cluster.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port of the database. Default: 8123
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.SourceClickhouseConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class SourceClickhouseConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceClickhouseConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceClickhouseConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceClickhouseConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.SourceClickhouseConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.SourceClickhouseConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.SourceClickhouseConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.SourceClickhouseConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class SourceClickhouseConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceClickhouseConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceClickhouseConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceClickhouseConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceClickhouseConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceClickupApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "folderId":
            suggest = "folder_id"
        elif key == "includeClosedTasks":
            suggest = "include_closed_tasks"
        elif key == "listId":
            suggest = "list_id"
        elif key == "spaceId":
            suggest = "space_id"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceClickupApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceClickupApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceClickupApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 folder_id: Optional[str] = None,
                 include_closed_tasks: Optional[bool] = None,
                 list_id: Optional[str] = None,
                 space_id: Optional[str] = None,
                 team_id: Optional[str] = None):
        """
        :param str api_token: Every ClickUp API call required authentication. This field is your personal API token. See <a href="https://clickup.com/api/developer-portal/authentication/#personal-token">here</a>.
        :param str folder_id: The ID of your folder in your space. Retrieve it from the `/space/{space_id}/folder` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetFolders/">here</a>.
        :param bool include_closed_tasks: Include or exclude closed tasks. By default, they are excluded. See <a https://clickup.com/api/clickupreference/operation/GetTasks/#!in=query&path=include_closed&t=request">here</a>. Default: false
        :param str list_id: The ID of your list in your folder. Retrieve it from the `/folder/{folder_id}/list` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetLists/">here</a>.
        :param str space_id: The ID of your space in your workspace. Retrieve it from the `/team/{team_id}/space` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetSpaces/">here</a>.
        :param str team_id: The ID of your team in ClickUp. Retrieve it from the `/team` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetAuthorizedTeams/">here</a>.
        """
        pulumi.set(__self__, "api_token", api_token)
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if include_closed_tasks is not None:
            pulumi.set(__self__, "include_closed_tasks", include_closed_tasks)
        if list_id is not None:
            pulumi.set(__self__, "list_id", list_id)
        if space_id is not None:
            pulumi.set(__self__, "space_id", space_id)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Every ClickUp API call required authentication. This field is your personal API token. See <a href="https://clickup.com/api/developer-portal/authentication/#personal-token">here</a>.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[str]:
        """
        The ID of your folder in your space. Retrieve it from the `/space/{space_id}/folder` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetFolders/">here</a>.
        """
        return pulumi.get(self, "folder_id")

    @property
    @pulumi.getter(name="includeClosedTasks")
    def include_closed_tasks(self) -> Optional[bool]:
        """
        Include or exclude closed tasks. By default, they are excluded. See <a https://clickup.com/api/clickupreference/operation/GetTasks/#!in=query&path=include_closed&t=request">here</a>. Default: false
        """
        return pulumi.get(self, "include_closed_tasks")

    @property
    @pulumi.getter(name="listId")
    def list_id(self) -> Optional[str]:
        """
        The ID of your list in your folder. Retrieve it from the `/folder/{folder_id}/list` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetLists/">here</a>.
        """
        return pulumi.get(self, "list_id")

    @property
    @pulumi.getter(name="spaceId")
    def space_id(self) -> Optional[str]:
        """
        The ID of your space in your workspace. Retrieve it from the `/team/{team_id}/space` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetSpaces/">here</a>.
        """
        return pulumi.get(self, "space_id")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        The ID of your team in ClickUp. Retrieve it from the `/team` of the ClickUp API. See <a href="https://clickup.com/api/clickupreference/operation/GetAuthorizedTeams/">here</a>.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class SourceClockifyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "workspaceId":
            suggest = "workspace_id"
        elif key == "apiUrl":
            suggest = "api_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceClockifyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceClockifyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceClockifyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 workspace_id: str,
                 api_url: Optional[str] = None):
        """
        :param str api_key: You can get your api access_key <a href="https://app.clockify.me/user/settings">here</a> This API is Case Sensitive.
        :param str workspace_id: WorkSpace Id
        :param str api_url: The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify. Default: "https://api.clockify.me"
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "workspace_id", workspace_id)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        You can get your api access_key <a href="https://app.clockify.me/user/settings">here</a> This API is Case Sensitive.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> str:
        """
        WorkSpace Id
        """
        return pulumi.get(self, "workspace_id")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify. Default: "https://api.clockify.me"
        """
        return pulumi.get(self, "api_url")


@pulumi.output_type
class SourceCloseComConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCloseComConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCloseComConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCloseComConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: Optional[str] = None):
        """
        :param str api_key: Close.com API key (usually starts with 'api_'; find yours <a href="https://app.close.com/settings/api/">here</a>).
        :param str start_date: The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD. Default: "2021-01-01"
        """
        pulumi.set(__self__, "api_key", api_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Close.com API key (usually starts with 'api_'; find yours <a href="https://app.close.com/settings/api/">here</a>).
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD. Default: "2021-01-01"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceCodaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCodaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCodaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCodaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: str):
        """
        :param str auth_token: Bearer token
        """
        pulumi.set(__self__, "auth_token", auth_token)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        Bearer token
        """
        return pulumi.get(self, "auth_token")


@pulumi.output_type
class SourceCoinApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "symbolId":
            suggest = "symbol_id"
        elif key == "endDate":
            suggest = "end_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCoinApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCoinApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCoinApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 period: str,
                 start_date: str,
                 symbol_id: str,
                 end_date: Optional[str] = None,
                 environment: Optional[str] = None,
                 limit: Optional[int] = None):
        """
        :param str api_key: API Key
        :param str period: The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
        :param str start_date: The start date in ISO 8601 format.
        :param str symbol_id: The symbol ID to use. See the documentation for a list.
               https://docs.coinapi.io/#list-all-symbols-get
        :param str end_date: The end date in ISO 8601 format. If not supplied, data will be returned
               from the start date to the current time, or when the count of result
               elements reaches its limit.
        :param str environment: The environment to use. Either sandbox or production.
               
               must be one of ["sandbox", "production"]; Default: "sandbox"
        :param int limit: The maximum number of elements to return. If not supplied, the default
               is 100. For numbers larger than 100, each 100 items is counted as one
               request for pricing purposes. Maximum value is 100000.
               
               Default: 100
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "symbol_id", symbol_id)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def period(self) -> str:
        """
        The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The start date in ISO 8601 format.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="symbolId")
    def symbol_id(self) -> str:
        """
        The symbol ID to use. See the documentation for a list.
        https://docs.coinapi.io/#list-all-symbols-get
        """
        return pulumi.get(self, "symbol_id")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The end date in ISO 8601 format. If not supplied, data will be returned
        from the start date to the current time, or when the count of result
        elements reaches its limit.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The environment to use. Either sandbox or production.

        must be one of ["sandbox", "production"]; Default: "sandbox"
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of elements to return. If not supplied, the default
        is 100. For numbers larger than 100, each 100 items is counted as one
        request for pricing purposes. Maximum value is 100000.

        Default: 100
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class SourceCoinmarketcapConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceCoinmarketcapConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceCoinmarketcapConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceCoinmarketcapConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 data_type: str,
                 symbols: Optional[Sequence[str]] = None):
        """
        :param str api_key: Your API Key. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Authentication">here</a>. The token is case sensitive.
        :param str data_type: /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Endpoint-Overview">here</a>. must be one of ["latest", "historical"]
        :param Sequence[str] symbols: Cryptocurrency symbols. (only used for quotes stream)
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "data_type", data_type)
        if symbols is not None:
            pulumi.set(__self__, "symbols", symbols)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Authentication">here</a>. The token is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> str:
        """
        /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Endpoint-Overview">here</a>. must be one of ["latest", "historical"]
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def symbols(self) -> Optional[Sequence[str]]:
        """
        Cryptocurrency symbols. (only used for quotes stream)
        """
        return pulumi.get(self, "symbols")


@pulumi.output_type
class SourceConfigcatConfiguration(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Basic auth password. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        :param str username: Basic auth user name. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Basic auth password. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Basic auth user name. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SourceConfluenceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceConfluenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceConfluenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceConfluenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 domain_name: str,
                 email: str):
        """
        :param str api_token: Please follow the Jira confluence for generating an API token: <a href="https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/">generating an API token</a>.
        :param str domain_name: Your Confluence domain name
        :param str email: Your Confluence login email
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Please follow the Jira confluence for generating an API token: <a href="https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/">generating an API token</a>.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        Your Confluence domain name
        """
        return pulumi.get(self, "domain_name")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        Your Confluence login email
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class SourceConvexConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "deploymentUrl":
            suggest = "deployment_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceConvexConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceConvexConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceConvexConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 deployment_url: str):
        """
        :param str access_key: API access key used to retrieve data from Convex.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "deployment_url", deployment_url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        API access key used to retrieve data from Convex.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="deploymentUrl")
    def deployment_url(self) -> str:
        return pulumi.get(self, "deployment_url")


@pulumi.output_type
class SourceDatascopeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDatascopeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDatascopeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDatascopeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str):
        """
        :param str api_key: API Key
        :param str start_date: Start date for the data to be replicated
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start date for the data to be replicated
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceDelightedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDelightedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDelightedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDelightedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 since: str):
        """
        :param str api_key: A Delighted API key.
        :param str since: The date from which you'd like to replicate the data
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "since", since)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        A Delighted API key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def since(self) -> str:
        """
        The date from which you'd like to replicate the data
        """
        return pulumi.get(self, "since")


@pulumi.output_type
class SourceDixaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "batchSize":
            suggest = "batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDixaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDixaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDixaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 start_date: str,
                 batch_size: Optional[int] = None):
        """
        :param str api_token: Dixa API token
        :param str start_date: The connector pulls records updated from this date onwards.
        :param int batch_size: Number of days to batch into one request. Max 31. Default: 31
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "start_date", start_date)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Dixa API token
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The connector pulls records updated from this date onwards.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[int]:
        """
        Number of days to batch into one request. Max 31. Default: 31
        """
        return pulumi.get(self, "batch_size")


@pulumi.output_type
class SourceDockerhubConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerUsername":
            suggest = "docker_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDockerhubConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDockerhubConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDockerhubConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 docker_username: str):
        """
        :param str docker_username: Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
        """
        pulumi.set(__self__, "docker_username", docker_username)

    @property
    @pulumi.getter(name="dockerUsername")
    def docker_username(self) -> str:
        """
        Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
        """
        return pulumi.get(self, "docker_username")


@pulumi.output_type
class SourceDremioConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "baseUrl":
            suggest = "base_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDremioConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDremioConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDremioConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 base_url: Optional[str] = None):
        """
        :param str api_key: API Key that is generated when you authenticate to Dremio API
        :param str base_url: URL of your Dremio instance. Default: "https://app.dremio.cloud"
        """
        pulumi.set(__self__, "api_key", api_key)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key that is generated when you authenticate to Dremio API
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[str]:
        """
        URL of your Dremio instance. Default: "https://app.dremio.cloud"
        """
        return pulumi.get(self, "base_url")


@pulumi.output_type
class SourceDynamodbConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreMissingReadPermissionsTables":
            suggest = "ignore_missing_read_permissions_tables"
        elif key == "reservedAttributeNames":
            suggest = "reserved_attribute_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDynamodbConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDynamodbConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDynamodbConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceDynamodbConfigurationCredentials'] = None,
                 endpoint: Optional[str] = None,
                 ignore_missing_read_permissions_tables: Optional[bool] = None,
                 region: Optional[str] = None,
                 reserved_attribute_names: Optional[str] = None):
        """
        :param 'SourceDynamodbConfigurationCredentialsArgs' credentials: Credentials for the service
        :param str endpoint: the URL of the Dynamodb database. Default: ""
        :param bool ignore_missing_read_permissions_tables: Ignore tables with missing scan/read permissions. Default: false
        :param str region: The region of the Dynamodb database. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        :param str reserved_attribute_names: Comma separated reserved attribute names present in your tables
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if ignore_missing_read_permissions_tables is not None:
            pulumi.set(__self__, "ignore_missing_read_permissions_tables", ignore_missing_read_permissions_tables)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if reserved_attribute_names is not None:
            pulumi.set(__self__, "reserved_attribute_names", reserved_attribute_names)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceDynamodbConfigurationCredentials']:
        """
        Credentials for the service
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        the URL of the Dynamodb database. Default: ""
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="ignoreMissingReadPermissionsTables")
    def ignore_missing_read_permissions_tables(self) -> Optional[bool]:
        """
        Ignore tables with missing scan/read permissions. Default: false
        """
        return pulumi.get(self, "ignore_missing_read_permissions_tables")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region of the Dynamodb database. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]; Default: ""
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="reservedAttributeNames")
    def reserved_attribute_names(self) -> Optional[str]:
        """
        Comma separated reserved attribute names present in your tables
        """
        return pulumi.get(self, "reserved_attribute_names")


@pulumi.output_type
class SourceDynamodbConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaAccessKeys":
            suggest = "authenticate_via_access_keys"
        elif key == "roleBasedAuthentication":
            suggest = "role_based_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDynamodbConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDynamodbConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDynamodbConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_access_keys: Optional['outputs.SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys'] = None,
                 role_based_authentication: Optional['outputs.SourceDynamodbConfigurationCredentialsRoleBasedAuthentication'] = None):
        if authenticate_via_access_keys is not None:
            pulumi.set(__self__, "authenticate_via_access_keys", authenticate_via_access_keys)
        if role_based_authentication is not None:
            pulumi.set(__self__, "role_based_authentication", role_based_authentication)

    @property
    @pulumi.getter(name="authenticateViaAccessKeys")
    def authenticate_via_access_keys(self) -> Optional['outputs.SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys']:
        return pulumi.get(self, "authenticate_via_access_keys")

    @property
    @pulumi.getter(name="roleBasedAuthentication")
    def role_based_authentication(self) -> Optional['outputs.SourceDynamodbConfigurationCredentialsRoleBasedAuthentication']:
        return pulumi.get(self, "role_based_authentication")


@pulumi.output_type
class SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: str,
                 secret_access_key: str,
                 additional_properties: Optional[str] = None):
        """
        :param str access_key_id: The access key id to access Dynamodb. Airbyte requires read permissions to the database
        :param str secret_access_key: The corresponding secret to the access key id.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        The access key id to access Dynamodb. Airbyte requires read permissions to the database
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        The corresponding secret to the access key id.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceDynamodbConfigurationCredentialsRoleBasedAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceDynamodbConfigurationCredentialsRoleBasedAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceDynamodbConfigurationCredentialsRoleBasedAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceDynamodbConfigurationCredentialsRoleBasedAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[str] = None):
        """
        :param str additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceEmailoctopusConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceEmailoctopusConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceEmailoctopusConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceEmailoctopusConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: EmailOctopus API Key. See the <a href="https://help.emailoctopus.com/article/165-how-to-create-and-delete-api-keys">docs</a> for information on how to generate this key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        EmailOctopus API Key. See the <a href="https://help.emailoctopus.com/article/165-how-to-create-and-delete-api-keys">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceExchangeRatesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "ignoreWeekends":
            suggest = "ignore_weekends"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceExchangeRatesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceExchangeRatesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceExchangeRatesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 start_date: str,
                 base: Optional[str] = None,
                 ignore_weekends: Optional[bool] = None):
        """
        :param str access_key: Your API Key. See <a href="https://apilayer.com/marketplace/exchangerates_data-api">here</a>. The key is case sensitive.
        :param str start_date: Start getting data from that date.
        :param str base: ISO reference currency. See <a href="https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html">here</a>. Free plan doesn't support Source Currency Switching, default base currency is EUR
        :param bool ignore_weekends: Ignore weekends? (Exchanges don't run on weekends). Default: true
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "start_date", start_date)
        if base is not None:
            pulumi.set(__self__, "base", base)
        if ignore_weekends is not None:
            pulumi.set(__self__, "ignore_weekends", ignore_weekends)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Your API Key. See <a href="https://apilayer.com/marketplace/exchangerates_data-api">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start getting data from that date.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def base(self) -> Optional[str]:
        """
        ISO reference currency. See <a href="https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html">here</a>. Free plan doesn't support Source Currency Switching, default base currency is EUR
        """
        return pulumi.get(self, "base")

    @property
    @pulumi.getter(name="ignoreWeekends")
    def ignore_weekends(self) -> Optional[bool]:
        """
        Ignore weekends? (Exchanges don't run on weekends). Default: true
        """
        return pulumi.get(self, "ignore_weekends")


@pulumi.output_type
class SourceFacebookMarketingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "accountIds":
            suggest = "account_ids"
        elif key == "actionBreakdownsAllowEmpty":
            suggest = "action_breakdowns_allow_empty"
        elif key == "adStatuses":
            suggest = "ad_statuses"
        elif key == "adsetStatuses":
            suggest = "adset_statuses"
        elif key == "campaignStatuses":
            suggest = "campaign_statuses"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customInsights":
            suggest = "custom_insights"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "fetchThumbnailImages":
            suggest = "fetch_thumbnail_images"
        elif key == "insightsJobTimeout":
            suggest = "insights_job_timeout"
        elif key == "insightsLookbackWindow":
            suggest = "insights_lookback_window"
        elif key == "pageSize":
            suggest = "page_size"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFacebookMarketingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFacebookMarketingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFacebookMarketingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 account_ids: Sequence[str],
                 action_breakdowns_allow_empty: Optional[bool] = None,
                 ad_statuses: Optional[Sequence[str]] = None,
                 adset_statuses: Optional[Sequence[str]] = None,
                 campaign_statuses: Optional[Sequence[str]] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 custom_insights: Optional[Sequence['outputs.SourceFacebookMarketingConfigurationCustomInsight']] = None,
                 end_date: Optional[str] = None,
                 fetch_thumbnail_images: Optional[bool] = None,
                 insights_job_timeout: Optional[int] = None,
                 insights_lookback_window: Optional[int] = None,
                 page_size: Optional[int] = None,
                 start_date: Optional[str] = None):
        """
        :param str access_token: The value of the generated access token. From your App’s Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
        :param Sequence[str] account_ids: The Facebook Ad account ID(s) to pull data from. The Ad account ID number is in the account dropdown menu or in your browser's address bar of your <a href="https://adsmanager.facebook.com/adsmanager/">Meta Ads Manager</a>. See the <a href="https://www.facebook.com/business/help/1492627900875762">docs</a> for more information.
        :param bool action_breakdowns_allow_empty: Allows action_breakdowns to be an empty list. Default: true
        :param Sequence[str] ad_statuses: Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        :param Sequence[str] adset_statuses: Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        :param Sequence[str] campaign_statuses: Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        :param str client_id: The Client Id for your OAuth app
        :param str client_secret: The Client Secret for your OAuth app
        :param Sequence['SourceFacebookMarketingConfigurationCustomInsightArgs'] custom_insights: A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        :param str end_date: The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        :param bool fetch_thumbnail_images: Set to active if you want to fetch the thumbnail_url and store the result in thumbnail_data_url for each Ad Creative. Default: false
        :param int insights_job_timeout: Insights Job Timeout establishes the maximum amount of time (in minutes) of waiting for the report job to complete. When timeout is reached the job is considered failed and we are trying to request smaller amount of data by breaking the job to few smaller ones. If you definitely know that 60 minutes is not enough for your report to be processed then you can decrease the timeout value, so we start breaking job to smaller parts faster. Default: 60
        :param int insights_lookback_window: The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here. Default: 28
        :param int page_size: Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases. Default: 100
        :param str start_date: The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. If not set then all data will be replicated for usual streams and only last 2 years for insight streams.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "account_ids", account_ids)
        if action_breakdowns_allow_empty is not None:
            pulumi.set(__self__, "action_breakdowns_allow_empty", action_breakdowns_allow_empty)
        if ad_statuses is not None:
            pulumi.set(__self__, "ad_statuses", ad_statuses)
        if adset_statuses is not None:
            pulumi.set(__self__, "adset_statuses", adset_statuses)
        if campaign_statuses is not None:
            pulumi.set(__self__, "campaign_statuses", campaign_statuses)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_insights is not None:
            pulumi.set(__self__, "custom_insights", custom_insights)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if fetch_thumbnail_images is not None:
            pulumi.set(__self__, "fetch_thumbnail_images", fetch_thumbnail_images)
        if insights_job_timeout is not None:
            pulumi.set(__self__, "insights_job_timeout", insights_job_timeout)
        if insights_lookback_window is not None:
            pulumi.set(__self__, "insights_lookback_window", insights_lookback_window)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The value of the generated access token. From your App’s Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Sequence[str]:
        """
        The Facebook Ad account ID(s) to pull data from. The Ad account ID number is in the account dropdown menu or in your browser's address bar of your <a href="https://adsmanager.facebook.com/adsmanager/">Meta Ads Manager</a>. See the <a href="https://www.facebook.com/business/help/1492627900875762">docs</a> for more information.
        """
        return pulumi.get(self, "account_ids")

    @property
    @pulumi.getter(name="actionBreakdownsAllowEmpty")
    def action_breakdowns_allow_empty(self) -> Optional[bool]:
        """
        Allows action_breakdowns to be an empty list. Default: true
        """
        return pulumi.get(self, "action_breakdowns_allow_empty")

    @property
    @pulumi.getter(name="adStatuses")
    def ad_statuses(self) -> Optional[Sequence[str]]:
        """
        Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        """
        return pulumi.get(self, "ad_statuses")

    @property
    @pulumi.getter(name="adsetStatuses")
    def adset_statuses(self) -> Optional[Sequence[str]]:
        """
        Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        """
        return pulumi.get(self, "adset_statuses")

    @property
    @pulumi.getter(name="campaignStatuses")
    def campaign_statuses(self) -> Optional[Sequence[str]]:
        """
        Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
        """
        return pulumi.get(self, "campaign_statuses")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client Id for your OAuth app
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for your OAuth app
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="customInsights")
    def custom_insights(self) -> Optional[Sequence['outputs.SourceFacebookMarketingConfigurationCustomInsight']]:
        """
        A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        """
        return pulumi.get(self, "custom_insights")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="fetchThumbnailImages")
    def fetch_thumbnail_images(self) -> Optional[bool]:
        """
        Set to active if you want to fetch the thumbnail_url and store the result in thumbnail_data_url for each Ad Creative. Default: false
        """
        return pulumi.get(self, "fetch_thumbnail_images")

    @property
    @pulumi.getter(name="insightsJobTimeout")
    def insights_job_timeout(self) -> Optional[int]:
        """
        Insights Job Timeout establishes the maximum amount of time (in minutes) of waiting for the report job to complete. When timeout is reached the job is considered failed and we are trying to request smaller amount of data by breaking the job to few smaller ones. If you definitely know that 60 minutes is not enough for your report to be processed then you can decrease the timeout value, so we start breaking job to smaller parts faster. Default: 60
        """
        return pulumi.get(self, "insights_job_timeout")

    @property
    @pulumi.getter(name="insightsLookbackWindow")
    def insights_lookback_window(self) -> Optional[int]:
        """
        The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here. Default: 28
        """
        return pulumi.get(self, "insights_lookback_window")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[int]:
        """
        Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases. Default: 100
        """
        return pulumi.get(self, "page_size")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. If not set then all data will be replicated for usual streams and only last 2 years for insight streams.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceFacebookMarketingConfigurationCustomInsight(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionBreakdowns":
            suggest = "action_breakdowns"
        elif key == "actionReportTime":
            suggest = "action_report_time"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "insightsJobTimeout":
            suggest = "insights_job_timeout"
        elif key == "insightsLookbackWindow":
            suggest = "insights_lookback_window"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "timeIncrement":
            suggest = "time_increment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFacebookMarketingConfigurationCustomInsight. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFacebookMarketingConfigurationCustomInsight.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFacebookMarketingConfigurationCustomInsight.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 action_breakdowns: Optional[Sequence[str]] = None,
                 action_report_time: Optional[str] = None,
                 breakdowns: Optional[Sequence[str]] = None,
                 end_date: Optional[str] = None,
                 fields: Optional[Sequence[str]] = None,
                 insights_job_timeout: Optional[int] = None,
                 insights_lookback_window: Optional[int] = None,
                 level: Optional[str] = None,
                 start_date: Optional[str] = None,
                 time_increment: Optional[int] = None):
        """
        :param str name: The name value of insight
        :param Sequence[str] action_breakdowns: A list of chosen action_breakdowns for action_breakdowns
        :param str action_report_time: Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd. must be one of ["conversion", "impression", "mixed"]; Default: "mixed"
        :param Sequence[str] breakdowns: A list of chosen breakdowns for breakdowns
        :param str end_date: The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        :param Sequence[str] fields: A list of chosen fields for fields parameter
        :param int insights_job_timeout: The insights job timeout. Default: 60
        :param int insights_lookback_window: The attribution window. Default: 28
        :param str level: Chosen level for API. must be one of ["ad", "adset", "campaign", "account"]; Default: "ad"
        :param str start_date: The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
        :param int time_increment: Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). Default: 1
        """
        pulumi.set(__self__, "name", name)
        if action_breakdowns is not None:
            pulumi.set(__self__, "action_breakdowns", action_breakdowns)
        if action_report_time is not None:
            pulumi.set(__self__, "action_report_time", action_report_time)
        if breakdowns is not None:
            pulumi.set(__self__, "breakdowns", breakdowns)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if insights_job_timeout is not None:
            pulumi.set(__self__, "insights_job_timeout", insights_job_timeout)
        if insights_lookback_window is not None:
            pulumi.set(__self__, "insights_lookback_window", insights_lookback_window)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if time_increment is not None:
            pulumi.set(__self__, "time_increment", time_increment)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name value of insight
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="actionBreakdowns")
    def action_breakdowns(self) -> Optional[Sequence[str]]:
        """
        A list of chosen action_breakdowns for action_breakdowns
        """
        return pulumi.get(self, "action_breakdowns")

    @property
    @pulumi.getter(name="actionReportTime")
    def action_report_time(self) -> Optional[str]:
        """
        Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd. must be one of ["conversion", "impression", "mixed"]; Default: "mixed"
        """
        return pulumi.get(self, "action_report_time")

    @property
    @pulumi.getter
    def breakdowns(self) -> Optional[Sequence[str]]:
        """
        A list of chosen breakdowns for breakdowns
        """
        return pulumi.get(self, "breakdowns")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[str]]:
        """
        A list of chosen fields for fields parameter
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter(name="insightsJobTimeout")
    def insights_job_timeout(self) -> Optional[int]:
        """
        The insights job timeout. Default: 60
        """
        return pulumi.get(self, "insights_job_timeout")

    @property
    @pulumi.getter(name="insightsLookbackWindow")
    def insights_lookback_window(self) -> Optional[int]:
        """
        The attribution window. Default: 28
        """
        return pulumi.get(self, "insights_lookback_window")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Chosen level for API. must be one of ["ad", "adset", "campaign", "account"]; Default: "ad"
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="timeIncrement")
    def time_increment(self) -> Optional[int]:
        """
        Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). Default: 1
        """
        return pulumi.get(self, "time_increment")


@pulumi.output_type
class SourceFakerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alwaysUpdated":
            suggest = "always_updated"
        elif key == "recordsPerSlice":
            suggest = "records_per_slice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFakerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFakerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFakerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 always_updated: Optional[bool] = None,
                 count: Optional[int] = None,
                 parallelism: Optional[int] = None,
                 records_per_slice: Optional[int] = None,
                 seed: Optional[int] = None):
        """
        :param bool always_updated: Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted. Default: true
        :param int count: How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream. Default: 1000
        :param int parallelism: How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source. Default: 4
        :param int records_per_slice: How many fake records will be in each page (stream slice), before a state message is emitted?. Default: 1000
        :param int seed: Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random). Default: -1
        """
        if always_updated is not None:
            pulumi.set(__self__, "always_updated", always_updated)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if parallelism is not None:
            pulumi.set(__self__, "parallelism", parallelism)
        if records_per_slice is not None:
            pulumi.set(__self__, "records_per_slice", records_per_slice)
        if seed is not None:
            pulumi.set(__self__, "seed", seed)

    @property
    @pulumi.getter(name="alwaysUpdated")
    def always_updated(self) -> Optional[bool]:
        """
        Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted. Default: true
        """
        return pulumi.get(self, "always_updated")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream. Default: 1000
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def parallelism(self) -> Optional[int]:
        """
        How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source. Default: 4
        """
        return pulumi.get(self, "parallelism")

    @property
    @pulumi.getter(name="recordsPerSlice")
    def records_per_slice(self) -> Optional[int]:
        """
        How many fake records will be in each page (stream slice), before a state message is emitted?. Default: 1000
        """
        return pulumi.get(self, "records_per_slice")

    @property
    @pulumi.getter
    def seed(self) -> Optional[int]:
        """
        Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random). Default: -1
        """
        return pulumi.get(self, "seed")


@pulumi.output_type
class SourceFaunaConfiguration(dict):
    def __init__(__self__, *,
                 secret: str,
                 collection: Optional['outputs.SourceFaunaConfigurationCollection'] = None,
                 domain: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        """
        :param str secret: Fauna secret, used when authenticating with the database.
        :param 'SourceFaunaConfigurationCollectionArgs' collection: Settings for the Fauna Collection.
        :param str domain: Domain of Fauna to query. Defaults db.fauna.com. See <a href=https://docs.fauna.com/fauna/current/learn/understanding/region_groups#how-to-use-region-groups>the docs</a>. Default: "db.fauna.com"
        :param int port: Endpoint port. Default: 443
        :param str scheme: URL scheme. Default: "https"
        """
        pulumi.set(__self__, "secret", secret)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        Fauna secret, used when authenticating with the database.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def collection(self) -> Optional['outputs.SourceFaunaConfigurationCollection']:
        """
        Settings for the Fauna Collection.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain of Fauna to query. Defaults db.fauna.com. See <a href=https://docs.fauna.com/fauna/current/learn/understanding/region_groups#how-to-use-region-groups>the docs</a>. Default: "db.fauna.com"
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Endpoint port. Default: 443
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        URL scheme. Default: "https"
        """
        return pulumi.get(self, "scheme")


@pulumi.output_type
class SourceFaunaConfigurationCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pageSize":
            suggest = "page_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFaunaConfigurationCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFaunaConfigurationCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFaunaConfigurationCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deletions: 'outputs.SourceFaunaConfigurationCollectionDeletions',
                 page_size: Optional[int] = None):
        """
        :param 'SourceFaunaConfigurationCollectionDeletionsArgs' deletions: <b>This only applies to incremental syncs.</b> <br>
               Enabling deletion mode informs your destination of deleted documents.<br>
               Disabled - Leave this feature disabled, and ignore deleted documents.<br>
               Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.
        :param int page_size: The page size used when reading documents from the database. The larger the page size, the faster the connector processes documents. However, if a page is too large, the connector may fail. <br>
               Choose your page size based on how large the documents are. <br>
               See <a href="https://docs.fauna.com/fauna/current/learn/understanding/types#page">the docs</a>.
               Default: 64
        """
        pulumi.set(__self__, "deletions", deletions)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)

    @property
    @pulumi.getter
    def deletions(self) -> 'outputs.SourceFaunaConfigurationCollectionDeletions':
        """
        <b>This only applies to incremental syncs.</b> <br>
        Enabling deletion mode informs your destination of deleted documents.<br>
        Disabled - Leave this feature disabled, and ignore deleted documents.<br>
        Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.
        """
        return pulumi.get(self, "deletions")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[int]:
        """
        The page size used when reading documents from the database. The larger the page size, the faster the connector processes documents. However, if a page is too large, the connector may fail. <br>
        Choose your page size based on how large the documents are. <br>
        See <a href="https://docs.fauna.com/fauna/current/learn/understanding/types#page">the docs</a>.
        Default: 64
        """
        return pulumi.get(self, "page_size")


@pulumi.output_type
class SourceFaunaConfigurationCollectionDeletions(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.SourceFaunaConfigurationCollectionDeletionsDisabled'] = None,
                 enabled: Optional['outputs.SourceFaunaConfigurationCollectionDeletionsEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.SourceFaunaConfigurationCollectionDeletionsDisabled']:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.SourceFaunaConfigurationCollectionDeletionsEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SourceFaunaConfigurationCollectionDeletionsDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceFaunaConfigurationCollectionDeletionsEnabled(dict):
    def __init__(__self__, *,
                 column: Optional[str] = None):
        """
        :param str column: Name of the "deleted at" column. Default: "deleted_at"
        """
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        Name of the "deleted at" column. Default: "deleted_at"
        """
        return pulumi.get(self, "column")


@pulumi.output_type
class SourceFileConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetName":
            suggest = "dataset_name"
        elif key == "readerOptions":
            suggest = "reader_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFileConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFileConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFileConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_name: str,
                 provider: 'outputs.SourceFileConfigurationProvider',
                 url: str,
                 format: Optional[str] = None,
                 reader_options: Optional[str] = None):
        """
        :param str dataset_name: The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
        :param 'SourceFileConfigurationProviderArgs' provider: The storage Provider or Location of the file(s) which should be replicated.
        :param str url: The URL path to access the file which should be replicated.
        :param str format: The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs). must be one of ["csv", "json", "jsonl", "excel", "excel_binary", "fwf", "feather", "parquet", "yaml"]; Default: "csv"
        :param str reader_options: This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
        """
        pulumi.set(__self__, "dataset_name", dataset_name)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if reader_options is not None:
            pulumi.set(__self__, "reader_options", reader_options)

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> str:
        """
        The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
        """
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter
    def provider(self) -> 'outputs.SourceFileConfigurationProvider':
        """
        The storage Provider or Location of the file(s) which should be replicated.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL path to access the file which should be replicated.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs). must be one of ["csv", "json", "jsonl", "excel", "excel_binary", "fwf", "feather", "parquet", "yaml"]; Default: "csv"
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="readerOptions")
    def reader_options(self) -> Optional[str]:
        """
        This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
        """
        return pulumi.get(self, "reader_options")


@pulumi.output_type
class SourceFileConfigurationProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azBlobAzureBlobStorage":
            suggest = "az_blob_azure_blob_storage"
        elif key == "gcsGoogleCloudStorage":
            suggest = "gcs_google_cloud_storage"
        elif key == "httpsPublicWeb":
            suggest = "https_public_web"
        elif key == "s3AmazonWebServices":
            suggest = "s3_amazon_web_services"
        elif key == "scpSecureCopyProtocol":
            suggest = "scp_secure_copy_protocol"
        elif key == "sftpSecureFileTransferProtocol":
            suggest = "sftp_secure_file_transfer_protocol"
        elif key == "sshSecureShell":
            suggest = "ssh_secure_shell"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFileConfigurationProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFileConfigurationProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFileConfigurationProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 az_blob_azure_blob_storage: Optional['outputs.SourceFileConfigurationProviderAzBlobAzureBlobStorage'] = None,
                 gcs_google_cloud_storage: Optional['outputs.SourceFileConfigurationProviderGcsGoogleCloudStorage'] = None,
                 https_public_web: Optional['outputs.SourceFileConfigurationProviderHttpsPublicWeb'] = None,
                 s3_amazon_web_services: Optional['outputs.SourceFileConfigurationProviderS3AmazonWebServices'] = None,
                 scp_secure_copy_protocol: Optional['outputs.SourceFileConfigurationProviderScpSecureCopyProtocol'] = None,
                 sftp_secure_file_transfer_protocol: Optional['outputs.SourceFileConfigurationProviderSftpSecureFileTransferProtocol'] = None,
                 ssh_secure_shell: Optional['outputs.SourceFileConfigurationProviderSshSecureShell'] = None):
        if az_blob_azure_blob_storage is not None:
            pulumi.set(__self__, "az_blob_azure_blob_storage", az_blob_azure_blob_storage)
        if gcs_google_cloud_storage is not None:
            pulumi.set(__self__, "gcs_google_cloud_storage", gcs_google_cloud_storage)
        if https_public_web is not None:
            pulumi.set(__self__, "https_public_web", https_public_web)
        if s3_amazon_web_services is not None:
            pulumi.set(__self__, "s3_amazon_web_services", s3_amazon_web_services)
        if scp_secure_copy_protocol is not None:
            pulumi.set(__self__, "scp_secure_copy_protocol", scp_secure_copy_protocol)
        if sftp_secure_file_transfer_protocol is not None:
            pulumi.set(__self__, "sftp_secure_file_transfer_protocol", sftp_secure_file_transfer_protocol)
        if ssh_secure_shell is not None:
            pulumi.set(__self__, "ssh_secure_shell", ssh_secure_shell)

    @property
    @pulumi.getter(name="azBlobAzureBlobStorage")
    def az_blob_azure_blob_storage(self) -> Optional['outputs.SourceFileConfigurationProviderAzBlobAzureBlobStorage']:
        return pulumi.get(self, "az_blob_azure_blob_storage")

    @property
    @pulumi.getter(name="gcsGoogleCloudStorage")
    def gcs_google_cloud_storage(self) -> Optional['outputs.SourceFileConfigurationProviderGcsGoogleCloudStorage']:
        return pulumi.get(self, "gcs_google_cloud_storage")

    @property
    @pulumi.getter(name="httpsPublicWeb")
    def https_public_web(self) -> Optional['outputs.SourceFileConfigurationProviderHttpsPublicWeb']:
        return pulumi.get(self, "https_public_web")

    @property
    @pulumi.getter(name="s3AmazonWebServices")
    def s3_amazon_web_services(self) -> Optional['outputs.SourceFileConfigurationProviderS3AmazonWebServices']:
        return pulumi.get(self, "s3_amazon_web_services")

    @property
    @pulumi.getter(name="scpSecureCopyProtocol")
    def scp_secure_copy_protocol(self) -> Optional['outputs.SourceFileConfigurationProviderScpSecureCopyProtocol']:
        return pulumi.get(self, "scp_secure_copy_protocol")

    @property
    @pulumi.getter(name="sftpSecureFileTransferProtocol")
    def sftp_secure_file_transfer_protocol(self) -> Optional['outputs.SourceFileConfigurationProviderSftpSecureFileTransferProtocol']:
        return pulumi.get(self, "sftp_secure_file_transfer_protocol")

    @property
    @pulumi.getter(name="sshSecureShell")
    def ssh_secure_shell(self) -> Optional['outputs.SourceFileConfigurationProviderSshSecureShell']:
        return pulumi.get(self, "ssh_secure_shell")


@pulumi.output_type
class SourceFileConfigurationProviderAzBlobAzureBlobStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageAccount":
            suggest = "storage_account"
        elif key == "sasToken":
            suggest = "sas_token"
        elif key == "sharedKey":
            suggest = "shared_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFileConfigurationProviderAzBlobAzureBlobStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFileConfigurationProviderAzBlobAzureBlobStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFileConfigurationProviderAzBlobAzureBlobStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_account: str,
                 sas_token: Optional[str] = None,
                 shared_key: Optional[str] = None):
        """
        :param str storage_account: The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
        :param str sas_token: To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
        :param str shared_key: To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
        """
        pulumi.set(__self__, "storage_account", storage_account)
        if sas_token is not None:
            pulumi.set(__self__, "sas_token", sas_token)
        if shared_key is not None:
            pulumi.set(__self__, "shared_key", shared_key)

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> str:
        """
        The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
        """
        return pulumi.get(self, "storage_account")

    @property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> Optional[str]:
        """
        To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "sas_token")

    @property
    @pulumi.getter(name="sharedKey")
    def shared_key(self) -> Optional[str]:
        """
        To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "shared_key")


@pulumi.output_type
class SourceFileConfigurationProviderGcsGoogleCloudStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountJson":
            suggest = "service_account_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFileConfigurationProviderGcsGoogleCloudStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFileConfigurationProviderGcsGoogleCloudStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFileConfigurationProviderGcsGoogleCloudStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_json: Optional[str] = None):
        """
        :param str service_account_json: In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
        """
        if service_account_json is not None:
            pulumi.set(__self__, "service_account_json", service_account_json)

    @property
    @pulumi.getter(name="serviceAccountJson")
    def service_account_json(self) -> Optional[str]:
        """
        In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "service_account_json")


@pulumi.output_type
class SourceFileConfigurationProviderHttpsPublicWeb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFileConfigurationProviderHttpsPublicWeb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFileConfigurationProviderHttpsPublicWeb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFileConfigurationProviderHttpsPublicWeb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_agent: Optional[bool] = None):
        """
        :param bool user_agent: Add User-Agent to request. Default: false
        """
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[bool]:
        """
        Add User-Agent to request. Default: false
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class SourceFileConfigurationProviderS3AmazonWebServices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFileConfigurationProviderS3AmazonWebServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFileConfigurationProviderS3AmazonWebServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFileConfigurationProviderS3AmazonWebServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: Optional[str] = None,
                 aws_secret_access_key: Optional[str] = None):
        """
        :param str aws_access_key_id: In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param str aws_secret_access_key: In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[str]:
        """
        In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[str]:
        """
        In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_secret_access_key")


@pulumi.output_type
class SourceFileConfigurationProviderScpSecureCopyProtocol(dict):
    def __init__(__self__, *,
                 host: str,
                 user: str,
                 password: Optional[str] = None,
                 port: Optional[str] = None):
        """
        :param str port: Default: "22"
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def user(self) -> str:
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Default: "22"
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SourceFileConfigurationProviderSftpSecureFileTransferProtocol(dict):
    def __init__(__self__, *,
                 host: str,
                 user: str,
                 password: Optional[str] = None,
                 port: Optional[str] = None):
        """
        :param str port: Default: "22"
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def user(self) -> str:
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Default: "22"
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SourceFileConfigurationProviderSshSecureShell(dict):
    def __init__(__self__, *,
                 host: str,
                 user: str,
                 password: Optional[str] = None,
                 port: Optional[str] = None):
        """
        :param str port: Default: "22"
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def user(self) -> str:
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Default: "22"
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SourceFireboltConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFireboltConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFireboltConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFireboltConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 client_id: str,
                 client_secret: str,
                 database: str,
                 engine: str,
                 host: Optional[str] = None):
        """
        :param str account: Firebolt account to login.
        :param str client_id: Firebolt service account ID.
        :param str client_secret: Firebolt secret, corresponding to the service account ID.
        :param str database: The database to connect to.
        :param str engine: Engine name to connect to.
        :param str host: The host name of your Firebolt database.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "engine", engine)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def account(self) -> str:
        """
        Firebolt account to login.
        """
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Firebolt service account ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Firebolt secret, corresponding to the service account ID.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database to connect to.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def engine(self) -> str:
        """
        Engine name to connect to.
        """
        return pulumi.get(self, "engine")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The host name of your Firebolt database.
        """
        return pulumi.get(self, "host")


@pulumi.output_type
class SourceFreshcallerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "syncLagMinutes":
            suggest = "sync_lag_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFreshcallerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFreshcallerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFreshcallerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 domain: str,
                 requests_per_minute: Optional[int] = None,
                 start_date: Optional[str] = None,
                 sync_lag_minutes: Optional[int] = None):
        """
        :param str api_key: Freshcaller API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshcaller">docs</a> for more information on how to obtain this key.
        :param str domain: Used to construct Base URL for the Freshcaller APIs
        :param int requests_per_minute: The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        :param str start_date: UTC date and time. Any data created after this date will be replicated.
        :param int sync_lag_minutes: Lag in minutes for each sync, i.e., at time T, data for the time range [prev_sync_time, T-30] will be fetched
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "domain", domain)
        if requests_per_minute is not None:
            pulumi.set(__self__, "requests_per_minute", requests_per_minute)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if sync_lag_minutes is not None:
            pulumi.set(__self__, "sync_lag_minutes", sync_lag_minutes)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Freshcaller API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshcaller">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Used to construct Base URL for the Freshcaller APIs
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> Optional[int]:
        """
        The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        """
        return pulumi.get(self, "requests_per_minute")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time. Any data created after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="syncLagMinutes")
    def sync_lag_minutes(self) -> Optional[int]:
        """
        Lag in minutes for each sync, i.e., at time T, data for the time range [prev_sync_time, T-30] will be fetched
        """
        return pulumi.get(self, "sync_lag_minutes")


@pulumi.output_type
class SourceFreshdeskConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "lookbackWindowInDays":
            suggest = "lookback_window_in_days"
        elif key == "requestsPerMinute":
            suggest = "requests_per_minute"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFreshdeskConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFreshdeskConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFreshdeskConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 domain: str,
                 lookback_window_in_days: Optional[int] = None,
                 requests_per_minute: Optional[int] = None,
                 start_date: Optional[str] = None):
        """
        :param str api_key: Freshdesk API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshdesk">docs</a> for more information on how to obtain this key.
        :param str domain: Freshdesk domain
        :param int lookback_window_in_days: Number of days for lookback window for the stream Satisfaction Ratings. Default: 14
        :param int requests_per_minute: The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        :param str start_date: UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "domain", domain)
        if lookback_window_in_days is not None:
            pulumi.set(__self__, "lookback_window_in_days", lookback_window_in_days)
        if requests_per_minute is not None:
            pulumi.set(__self__, "requests_per_minute", requests_per_minute)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Freshdesk API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshdesk">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        Freshdesk domain
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="lookbackWindowInDays")
    def lookback_window_in_days(self) -> Optional[int]:
        """
        Number of days for lookback window for the stream Satisfaction Ratings. Default: 14
        """
        return pulumi.get(self, "lookback_window_in_days")

    @property
    @pulumi.getter(name="requestsPerMinute")
    def requests_per_minute(self) -> Optional[int]:
        """
        The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
        """
        return pulumi.get(self, "requests_per_minute")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceFreshsalesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "domainName":
            suggest = "domain_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceFreshsalesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceFreshsalesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceFreshsalesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 domain_name: str):
        """
        :param str api_key: Freshsales API Key. See <a href="https://crmsupport.freshworks.com/support/solutions/articles/50000002503-how-to-find-my-api-key-">here</a>. The key is case sensitive.
        :param str domain_name: The Name of your Freshsales domain
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "domain_name", domain_name)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Freshsales API Key. See <a href="https://crmsupport.freshworks.com/support/solutions/articles/50000002503-how-to-find-my-api-key-">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> str:
        """
        The Name of your Freshsales domain
        """
        return pulumi.get(self, "domain_name")


@pulumi.output_type
class SourceGainsightPxConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGainsightPxConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGainsightPxConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGainsightPxConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceGcsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGcsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGcsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGcsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 service_account: str,
                 streams: Sequence['outputs.SourceGcsConfigurationStream'],
                 start_date: Optional[str] = None):
        """
        :param str bucket: Name of the GCS bucket where the file(s) exist.
        :param str service_account: Enter your Google Cloud <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">service account key</a> in JSON format
        :param Sequence['SourceGcsConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href=https://docs.airbyte.com/cloud/core-concepts#stream>stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "streams", streams)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the GCS bucket where the file(s) exist.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> str:
        """
        Enter your Google Cloud <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">service account key</a> in JSON format
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceGcsConfigurationStream']:
        """
        Each instance of this configuration defines a <a href=https://docs.airbyte.com/cloud/core-concepts#stream>stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGcsConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "legacyPrefix":
            suggest = "legacy_prefix"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGcsConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGcsConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGcsConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceGcsConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 legacy_prefix: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceGcsConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str legacy_prefix: The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceGcsConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[str]:
        """
        The path prefix configured in previous versions of the GCS connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceGcsConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvFormat":
            suggest = "csv_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGcsConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGcsConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGcsConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_format: Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormat'] = None):
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")


@pulumi.output_type
class SourceGcsConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "ignoreErrorsOnFieldsMismatch":
            suggest = "ignore_errors_on_fields_mismatch"
        elif key == "inferenceType":
            suggest = "inference_type"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGcsConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGcsConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGcsConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 ignore_errors_on_fields_mismatch: Optional[bool] = None,
                 inference_type: Optional[str] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param bool ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param str inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[bool]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[str]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceGetlagoConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiUrl":
            suggest = "api_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGetlagoConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGetlagoConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGetlagoConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 api_url: Optional[str] = None):
        """
        :param str api_key: Your API Key. See <a href="https://doc.getlago.com/docs/api/intro">here</a>.
        :param str api_url: Your Lago API URL. Default: "https://api.getlago.com/api/v1"
        """
        pulumi.set(__self__, "api_key", api_key)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key. See <a href="https://doc.getlago.com/docs/api/intro">here</a>.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        Your Lago API URL. Default: "https://api.getlago.com/api/v1"
        """
        return pulumi.get(self, "api_url")


@pulumi.output_type
class SourceGithubConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGithubConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGithubConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGithubConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceGithubConfigurationCredentials',
                 repositories: Sequence[str],
                 api_url: Optional[str] = None,
                 branch: Optional[str] = None,
                 branches: Optional[Sequence[str]] = None,
                 repository: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceGithubConfigurationCredentialsArgs' credentials: Choose how to authenticate to GitHub
        :param Sequence[str] repositories: List of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/a* for matching multiple repositories by pattern.
        :param str api_url: Please enter your basic URL from self-hosted GitHub instance or leave it empty to use GitHub. Default: "https://api.github.com/"
        :param str branch: (DEPRCATED) Space-delimited list of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        :param Sequence[str] branches: List of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        :param str repository: (DEPRCATED) Space-delimited list of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/airbyte airbytehq/another-repo` for multiple repositories.
        :param str start_date: The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. If the date is not set, all data will be replicated.  For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the <a href="https://docs.airbyte.com/integrations/sources/github">docs</a> for more info
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "repositories", repositories)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceGithubConfigurationCredentials':
        """
        Choose how to authenticate to GitHub
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def repositories(self) -> Sequence[str]:
        """
        List of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/a* for matching multiple repositories by pattern.
        """
        return pulumi.get(self, "repositories")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        Please enter your basic URL from self-hosted GitHub instance or leave it empty to use GitHub. Default: "https://api.github.com/"
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        (DEPRCATED) Space-delimited list of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter
    def branches(self) -> Optional[Sequence[str]]:
        """
        List of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
        """
        return pulumi.get(self, "branches")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        """
        (DEPRCATED) Space-delimited list of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/airbyte airbytehq/another-repo` for multiple repositories.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. If the date is not set, all data will be replicated.  For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the <a href="https://docs.airbyte.com/integrations/sources/github">docs</a> for more info
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGithubConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth":
            suggest = "o_auth"
        elif key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGithubConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGithubConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGithubConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth: Optional['outputs.SourceGithubConfigurationCredentialsOAuth'] = None,
                 personal_access_token: Optional['outputs.SourceGithubConfigurationCredentialsPersonalAccessToken'] = None):
        if o_auth is not None:
            pulumi.set(__self__, "o_auth", o_auth)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="oAuth")
    def o_auth(self) -> Optional['outputs.SourceGithubConfigurationCredentialsOAuth']:
        return pulumi.get(self, "o_auth")

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional['outputs.SourceGithubConfigurationCredentialsPersonalAccessToken']:
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class SourceGithubConfigurationCredentialsOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGithubConfigurationCredentialsOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGithubConfigurationCredentialsOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGithubConfigurationCredentialsOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: OAuth access token
        :param str client_id: OAuth Client Id
        :param str client_secret: OAuth Client secret
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        OAuth access token
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        OAuth Client Id
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        OAuth Client secret
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceGithubConfigurationCredentialsPersonalAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "personalAccessToken":
            suggest = "personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGithubConfigurationCredentialsPersonalAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGithubConfigurationCredentialsPersonalAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGithubConfigurationCredentialsPersonalAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 personal_access_token: str):
        """
        :param str personal_access_token: Log into GitHub and then generate a <a href="https://github.com/settings/tokens">personal access token</a>. To load balance your API quota consumption across multiple API tokens, input multiple tokens separated with ","
        """
        pulumi.set(__self__, "personal_access_token", personal_access_token)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> str:
        """
        Log into GitHub and then generate a <a href="https://github.com/settings/tokens">personal access token</a>. To load balance your API quota consumption across multiple API tokens, input multiple tokens separated with ","
        """
        return pulumi.get(self, "personal_access_token")


@pulumi.output_type
class SourceGitlabConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiUrl":
            suggest = "api_url"
        elif key == "groupsLists":
            suggest = "groups_lists"
        elif key == "projectsLists":
            suggest = "projects_lists"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGitlabConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGitlabConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGitlabConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceGitlabConfigurationCredentials',
                 api_url: Optional[str] = None,
                 groups: Optional[str] = None,
                 groups_lists: Optional[Sequence[str]] = None,
                 projects: Optional[str] = None,
                 projects_lists: Optional[Sequence[str]] = None,
                 start_date: Optional[str] = None):
        """
        :param str api_url: Please enter your basic URL from GitLab instance. Default: "gitlab.com"
        :param str groups: [DEPRECATED] Space-delimited list of groups. e.g. airbyte.io.
        :param Sequence[str] groups_lists: List of groups. e.g. airbyte.io.
        :param str projects: [DEPRECATED] Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        :param Sequence[str] projects_lists: Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        :param str start_date: The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. Optional. If not set, all data will be replicated. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if groups_lists is not None:
            pulumi.set(__self__, "groups_lists", groups_lists)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if projects_lists is not None:
            pulumi.set(__self__, "projects_lists", projects_lists)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceGitlabConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        Please enter your basic URL from GitLab instance. Default: "gitlab.com"
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter
    def groups(self) -> Optional[str]:
        """
        [DEPRECATED] Space-delimited list of groups. e.g. airbyte.io.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="groupsLists")
    def groups_lists(self) -> Optional[Sequence[str]]:
        """
        List of groups. e.g. airbyte.io.
        """
        return pulumi.get(self, "groups_lists")

    @property
    @pulumi.getter
    def projects(self) -> Optional[str]:
        """
        [DEPRECATED] Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        """
        return pulumi.get(self, "projects")

    @property
    @pulumi.getter(name="projectsLists")
    def projects_lists(self) -> Optional[Sequence[str]]:
        """
        Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
        """
        return pulumi.get(self, "projects_lists")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. Optional. If not set, all data will be replicated. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGitlabConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth20":
            suggest = "o_auth20"
        elif key == "privateToken":
            suggest = "private_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGitlabConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGitlabConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGitlabConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth20: Optional['outputs.SourceGitlabConfigurationCredentialsOAuth20'] = None,
                 private_token: Optional['outputs.SourceGitlabConfigurationCredentialsPrivateToken'] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if private_token is not None:
            pulumi.set(__self__, "private_token", private_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceGitlabConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")

    @property
    @pulumi.getter(name="privateToken")
    def private_token(self) -> Optional['outputs.SourceGitlabConfigurationCredentialsPrivateToken']:
        return pulumi.get(self, "private_token")


@pulumi.output_type
class SourceGitlabConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tokenExpiryDate":
            suggest = "token_expiry_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGitlabConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGitlabConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGitlabConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 token_expiry_date: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The API ID of the Gitlab developer application.
        :param str client_secret: The API Secret the Gitlab developer application.
        :param str refresh_token: The key to refresh the expired access_token.
        :param str token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The API ID of the Gitlab developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The API Secret the Gitlab developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> str:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")


@pulumi.output_type
class SourceGitlabConfigurationCredentialsPrivateToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGitlabConfigurationCredentialsPrivateToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGitlabConfigurationCredentialsPrivateToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGitlabConfigurationCredentialsPrivateToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: Log into your Gitlab account and then generate a personal Access Token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Log into your Gitlab account and then generate a personal Access Token.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceGlassfrogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGlassfrogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGlassfrogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGlassfrogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: API key provided by Glassfrog
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API key provided by Glassfrog
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceGnewsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "topHeadlinesQuery":
            suggest = "top_headlines_query"
        elif key == "topHeadlinesTopic":
            suggest = "top_headlines_topic"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGnewsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGnewsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGnewsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 query: str,
                 country: Optional[str] = None,
                 end_date: Optional[str] = None,
                 ins: Optional[Sequence[str]] = None,
                 language: Optional[str] = None,
                 nullables: Optional[Sequence[str]] = None,
                 sortby: Optional[str] = None,
                 start_date: Optional[str] = None,
                 top_headlines_query: Optional[str] = None,
                 top_headlines_topic: Optional[str] = None):
        """
        :param str api_key: API Key
        :param str query: This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
                 quotation marks are used to search for articles with the exact same keyword sequence. 
                 For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
               - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
                 search. By default the space character acts as an AND operator, it is possible to replace the space character 
                 by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
               - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
                 It is important to note that this operator has a higher precedence than the AND operator. For example the 
                 query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
                 the keyword Microsoft
               - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
                 specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
                 For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
                 iPhone
        :param str country: This parameter allows you to specify the country where the news articles returned by the API were published, the contents of the articles are not necessarily related to the specified country. You have to set as value the 2 letters code of the country you want to filter. must be one of ["au", "br", "ca", "cn", "eg", "fr", "de", "gr", "hk", "in", "ie", "il", "it", "jp", "nl", "no", "pk", "pe", "ph", "pt", "ro", "ru", "sg", "es", "se", "ch", "tw", "ua", "gb", "us"]
        :param str end_date: This parameter allows you to filter the articles that have a publication date smaller than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        :param Sequence[str] ins: This parameter allows you to choose in which attributes the keywords are searched. The attributes that can be set are title, description and content. It is possible to combine several attributes.
        :param str language: must be one of ["ar", "zh", "nl", "en", "fr", "de", "el", "he", "hi", "it", "ja", "ml", "mr", "no", "pt", "ro", "ru", "es", "sv", "ta", "te", "uk"]
        :param Sequence[str] nullables: This parameter allows you to specify the attributes that you allow to return null values. The attributes that  can be set are title, description and content. It is possible to combine several attributes
        :param str sortby: This parameter allows you to choose with which type of sorting the articles should be returned. Two values  are possible:
                 - publishedAt = sort by publication date, the articles with the most recent publication date are returned first
                 - relevance = sort by best match to keywords, the articles with the best match are returned first
               must be one of ["publishedAt", "relevance"]
        :param str start_date: This parameter allows you to filter the articles that have a publication date greater than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        :param str top_headlines_query: This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
                 quotation marks are used to search for articles with the exact same keyword sequence. 
                 For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
               - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
                 search. By default the space character acts as an AND operator, it is possible to replace the space character 
                 by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
               - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
                 It is important to note that this operator has a higher precedence than the AND operator. For example the 
                 query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
                 the keyword Microsoft
               - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
                 specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
                 For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
                 iPhone
        :param str top_headlines_topic: This parameter allows you to change the category for the request. must be one of ["breaking-news", "world", "nation", "business", "technology", "entertainment", "sports", "science", "health"]
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query", query)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if ins is not None:
            pulumi.set(__self__, "ins", ins)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if nullables is not None:
            pulumi.set(__self__, "nullables", nullables)
        if sortby is not None:
            pulumi.set(__self__, "sortby", sortby)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if top_headlines_query is not None:
            pulumi.set(__self__, "top_headlines_query", top_headlines_query)
        if top_headlines_topic is not None:
            pulumi.set(__self__, "top_headlines_topic", top_headlines_topic)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
          quotation marks are used to search for articles with the exact same keyword sequence. 
          For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
        - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
          search. By default the space character acts as an AND operator, it is possible to replace the space character 
          by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
        - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
          It is important to note that this operator has a higher precedence than the AND operator. For example the 
          query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
          the keyword Microsoft
        - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
          specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
          For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
          iPhone
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        This parameter allows you to specify the country where the news articles returned by the API were published, the contents of the articles are not necessarily related to the specified country. You have to set as value the 2 letters code of the country you want to filter. must be one of ["au", "br", "ca", "cn", "eg", "fr", "de", "gr", "hk", "in", "ie", "il", "it", "jp", "nl", "no", "pk", "pe", "ph", "pt", "ro", "ru", "sg", "es", "se", "ch", "tw", "ua", "gb", "us"]
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        This parameter allows you to filter the articles that have a publication date smaller than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def ins(self) -> Optional[Sequence[str]]:
        """
        This parameter allows you to choose in which attributes the keywords are searched. The attributes that can be set are title, description and content. It is possible to combine several attributes.
        """
        return pulumi.get(self, "ins")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        """
        must be one of ["ar", "zh", "nl", "en", "fr", "de", "el", "he", "hi", "it", "ja", "ml", "mr", "no", "pt", "ro", "ru", "es", "sv", "ta", "te", "uk"]
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter
    def nullables(self) -> Optional[Sequence[str]]:
        """
        This parameter allows you to specify the attributes that you allow to return null values. The attributes that  can be set are title, description and content. It is possible to combine several attributes
        """
        return pulumi.get(self, "nullables")

    @property
    @pulumi.getter
    def sortby(self) -> Optional[str]:
        """
        This parameter allows you to choose with which type of sorting the articles should be returned. Two values  are possible:
          - publishedAt = sort by publication date, the articles with the most recent publication date are returned first
          - relevance = sort by best match to keywords, the articles with the best match are returned first
        must be one of ["publishedAt", "relevance"]
        """
        return pulumi.get(self, "sortby")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        This parameter allows you to filter the articles that have a publication date greater than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="topHeadlinesQuery")
    def top_headlines_query(self) -> Optional[str]:
        """
        This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
          quotation marks are used to search for articles with the exact same keyword sequence. 
          For example the query: "Apple iPhone" will return articles matching at least once this sequence of keywords.
        - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
          search. By default the space character acts as an AND operator, it is possible to replace the space character 
          by AND to obtain the same result. For example the query: Apple Microsoft is equivalent to Apple AND Microsoft
        - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
          It is important to note that this operator has a higher precedence than the AND operator. For example the 
          query: Apple OR Microsoft will return all articles matching the keyword Apple as well as all articles matching 
          the keyword Microsoft
        - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
          specified keywords. To use it, you need to add NOT in front of each word or phrase surrounded by quotes.
          For example the query: Apple NOT iPhone will return all articles matching the keyword Apple but not the keyword
          iPhone
        """
        return pulumi.get(self, "top_headlines_query")

    @property
    @pulumi.getter(name="topHeadlinesTopic")
    def top_headlines_topic(self) -> Optional[str]:
        """
        This parameter allows you to change the category for the request. must be one of ["breaking-news", "world", "nation", "business", "technology", "entertainment", "sports", "science", "health"]
        """
        return pulumi.get(self, "top_headlines_topic")


@pulumi.output_type
class SourceGoogleAdsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conversionWindowDays":
            suggest = "conversion_window_days"
        elif key == "customQueriesArrays":
            suggest = "custom_queries_arrays"
        elif key == "customerId":
            suggest = "customer_id"
        elif key == "customerStatusFilters":
            suggest = "customer_status_filters"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceGoogleAdsConfigurationCredentials',
                 conversion_window_days: Optional[int] = None,
                 custom_queries_arrays: Optional[Sequence['outputs.SourceGoogleAdsConfigurationCustomQueriesArray']] = None,
                 customer_id: Optional[str] = None,
                 customer_status_filters: Optional[Sequence[str]] = None,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param int conversion_window_days: A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see <a href="https://support.google.com/google-ads/answer/3123169?hl=en">Google's documentation</a>. Default: 14
        :param str customer_id: Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param Sequence[str] customer_status_filters: A list of customer statuses to filter on. For detailed info about what each status mean refer to Google Ads <a href="https://developers.google.com/google-ads/api/reference/rpc/v15/CustomerStatusEnum.CustomerStatus">documentation</a>.
        :param str end_date: UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated. (Default value of today is used if not set)
        :param str start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. (Default value of two years ago is used if not set)
        """
        pulumi.set(__self__, "credentials", credentials)
        if conversion_window_days is not None:
            pulumi.set(__self__, "conversion_window_days", conversion_window_days)
        if custom_queries_arrays is not None:
            pulumi.set(__self__, "custom_queries_arrays", custom_queries_arrays)
        if customer_id is not None:
            pulumi.set(__self__, "customer_id", customer_id)
        if customer_status_filters is not None:
            pulumi.set(__self__, "customer_status_filters", customer_status_filters)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceGoogleAdsConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="conversionWindowDays")
    def conversion_window_days(self) -> Optional[int]:
        """
        A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see <a href="https://support.google.com/google-ads/answer/3123169?hl=en">Google's documentation</a>. Default: 14
        """
        return pulumi.get(self, "conversion_window_days")

    @property
    @pulumi.getter(name="customQueriesArrays")
    def custom_queries_arrays(self) -> Optional[Sequence['outputs.SourceGoogleAdsConfigurationCustomQueriesArray']]:
        return pulumi.get(self, "custom_queries_arrays")

    @property
    @pulumi.getter(name="customerId")
    def customer_id(self) -> Optional[str]:
        """
        Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "customer_id")

    @property
    @pulumi.getter(name="customerStatusFilters")
    def customer_status_filters(self) -> Optional[Sequence[str]]:
        """
        A list of customer statuses to filter on. For detailed info about what each status mean refer to Google Ads <a href="https://developers.google.com/google-ads/api/reference/rpc/v15/CustomerStatusEnum.CustomerStatus">documentation</a>.
        """
        return pulumi.get(self, "customer_status_filters")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated. (Default value of today is used if not set)
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. (Default value of two years ago is used if not set)
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGoogleAdsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "developerToken":
            suggest = "developer_token"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAdsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAdsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAdsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 developer_token: str,
                 refresh_token: str,
                 access_token: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param str client_secret: The Client Secret of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param str developer_token: The Developer Token granted by Google to use their APIs. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param str refresh_token: The token used to obtain a new Access Token. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        :param str access_token: The Access Token for making authenticated requests. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "developer_token", developer_token)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="developerToken")
    def developer_token(self) -> str:
        """
        The Developer Token granted by Google to use their APIs. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "developer_token")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token used to obtain a new Access Token. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The Access Token for making authenticated requests. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceGoogleAdsConfigurationCustomQueriesArray(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAdsConfigurationCustomQueriesArray. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAdsConfigurationCustomQueriesArray.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAdsConfigurationCustomQueriesArray.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 table_name: str):
        """
        :param str query: A custom defined GAQL query for building the report. Avoid including the segments.date field; wherever possible, Airbyte will automatically include it for incremental syncs. For more information, refer to <a href="https://developers.google.com/google-ads/api/fields/v11/overview_query_builder">Google's documentation</a>.
        :param str table_name: The table name in your destination database for the chosen query.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        A custom defined GAQL query for building the report. Avoid including the segments.date field; wherever possible, Airbyte will automatically include it for incremental syncs. For more information, refer to <a href="https://developers.google.com/google-ads/api/fields/v11/overview_query_builder">Google's documentation</a>.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The table name in your destination database for the chosen query.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyIds":
            suggest = "property_ids"
        elif key == "convertConversionsEvent":
            suggest = "convert_conversions_event"
        elif key == "customReportsArrays":
            suggest = "custom_reports_arrays"
        elif key == "dateRangesStartDate":
            suggest = "date_ranges_start_date"
        elif key == "keepEmptyRows":
            suggest = "keep_empty_rows"
        elif key == "windowInDays":
            suggest = "window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_ids: Sequence[str],
                 convert_conversions_event: Optional[bool] = None,
                 credentials: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCredentials'] = None,
                 custom_reports_arrays: Optional[Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray']] = None,
                 date_ranges_start_date: Optional[str] = None,
                 keep_empty_rows: Optional[bool] = None,
                 window_in_days: Optional[int] = None):
        """
        :param Sequence[str] property_ids: A list of your Property IDs. The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id#what_is_my_property_id'>Google Analytics documentation</a> to locate your property ID.
        :param bool convert_conversions_event: Enables conversion of `conversions:*` event metrics from integers to floats. This is beneficial for preventing data rounding when the API returns float values for any `conversions:*` fields. Default: false
        :param 'SourceGoogleAnalyticsDataApiConfigurationCredentialsArgs' credentials: Credentials for the service
        :param Sequence['SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayArgs'] custom_reports_arrays: You can add your Custom Analytics report by creating one.
        :param str date_ranges_start_date: The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
        :param bool keep_empty_rows: If false, each row with all metrics equal to 0 will not be returned. If true, these rows will be returned if they are not separately removed by a filter. More information is available in <a href="https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties/runReport#request-body">the documentation</a>. Default: false
        :param int window_in_days: The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api">the documentation</a>. Default: 1
        """
        pulumi.set(__self__, "property_ids", property_ids)
        if convert_conversions_event is not None:
            pulumi.set(__self__, "convert_conversions_event", convert_conversions_event)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_reports_arrays is not None:
            pulumi.set(__self__, "custom_reports_arrays", custom_reports_arrays)
        if date_ranges_start_date is not None:
            pulumi.set(__self__, "date_ranges_start_date", date_ranges_start_date)
        if keep_empty_rows is not None:
            pulumi.set(__self__, "keep_empty_rows", keep_empty_rows)
        if window_in_days is not None:
            pulumi.set(__self__, "window_in_days", window_in_days)

    @property
    @pulumi.getter(name="propertyIds")
    def property_ids(self) -> Sequence[str]:
        """
        A list of your Property IDs. The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id#what_is_my_property_id'>Google Analytics documentation</a> to locate your property ID.
        """
        return pulumi.get(self, "property_ids")

    @property
    @pulumi.getter(name="convertConversionsEvent")
    def convert_conversions_event(self) -> Optional[bool]:
        """
        Enables conversion of `conversions:*` event metrics from integers to floats. This is beneficial for preventing data rounding when the API returns float values for any `conversions:*` fields. Default: false
        """
        return pulumi.get(self, "convert_conversions_event")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCredentials']:
        """
        Credentials for the service
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customReportsArrays")
    def custom_reports_arrays(self) -> Optional[Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray']]:
        """
        You can add your Custom Analytics report by creating one.
        """
        return pulumi.get(self, "custom_reports_arrays")

    @property
    @pulumi.getter(name="dateRangesStartDate")
    def date_ranges_start_date(self) -> Optional[str]:
        """
        The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
        """
        return pulumi.get(self, "date_ranges_start_date")

    @property
    @pulumi.getter(name="keepEmptyRows")
    def keep_empty_rows(self) -> Optional[bool]:
        """
        If false, each row with all metrics equal to 0 will not be returned. If true, these rows will be returned if they are not separately removed by a filter. More information is available in <a href="https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties/runReport#request-body">the documentation</a>. Default: false
        """
        return pulumi.get(self, "keep_empty_rows")

    @property
    @pulumi.getter(name="windowInDays")
    def window_in_days(self) -> Optional[int]:
        """
        The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api">the documentation</a>. Default: 1
        """
        return pulumi.get(self, "window_in_days")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaGoogleOauth":
            suggest = "authenticate_via_google_oauth"
        elif key == "serviceAccountKeyAuthentication":
            suggest = "service_account_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_google_oauth: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth'] = None,
                 service_account_key_authentication: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication'] = None):
        if authenticate_via_google_oauth is not None:
            pulumi.set(__self__, "authenticate_via_google_oauth", authenticate_via_google_oauth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaGoogleOauth")
    def authenticate_via_google_oauth(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth']:
        return pulumi.get(self, "authenticate_via_google_oauth")

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication']:
        return pulumi.get(self, "service_account_key_authentication")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 access_token: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Google Analytics developer application.
        :param str client_secret: The Client Secret of your Google Analytics developer application.
        :param str refresh_token: The token for obtaining a new access token.
        :param str access_token: Access Token for making authenticated requests.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Google Analytics developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Google Analytics developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token for obtaining a new access token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsJson":
            suggest = "credentials_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_json: str):
        """
        :param str credentials_json: The JSON key linked to the service account used for authorization. For steps on obtaining this key, refer to <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api/#setup-guide">the setup guide</a>.
        """
        pulumi.set(__self__, "credentials_json", credentials_json)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> str:
        """
        The JSON key linked to the service account used for authorization. For steps on obtaining this key, refer to <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api/#setup-guide">the setup guide</a>.
        """
        return pulumi.get(self, "credentials_json")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohortSpec":
            suggest = "cohort_spec"
        elif key == "dimensionFilter":
            suggest = "dimension_filter"
        elif key == "metricFilter":
            suggest = "metric_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Sequence[str],
                 metrics: Sequence[str],
                 name: str,
                 cohort_spec: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpec'] = None,
                 dimension_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter'] = None,
                 metric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter'] = None):
        """
        :param Sequence[str] dimensions: A list of dimensions.
        :param Sequence[str] metrics: A list of metrics.
        :param str name: The name of the custom report, this name would be used as stream name.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecArgs' cohort_spec: Cohort reports creates a time series of user retention for the cohort.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterArgs' dimension_filter: Dimensions filter
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterArgs' metric_filter: Metrics filter
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "name", name)
        if cohort_spec is not None:
            pulumi.set(__self__, "cohort_spec", cohort_spec)
        if dimension_filter is not None:
            pulumi.set(__self__, "dimension_filter", dimension_filter)
        if metric_filter is not None:
            pulumi.set(__self__, "metric_filter", metric_filter)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence[str]:
        """
        A list of dimensions.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def metrics(self) -> Sequence[str]:
        """
        A list of metrics.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom report, this name would be used as stream name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="cohortSpec")
    def cohort_spec(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpec']:
        """
        Cohort reports creates a time series of user retention for the cohort.
        """
        return pulumi.get(self, "cohort_spec")

    @property
    @pulumi.getter(name="dimensionFilter")
    def dimension_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter']:
        """
        Dimensions filter
        """
        return pulumi.get(self, "dimension_filter")

    @property
    @pulumi.getter(name="metricFilter")
    def metric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter']:
        """
        Metrics filter
        """
        return pulumi.get(self, "metric_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpec(dict):
    def __init__(__self__, *,
                 disabled: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabled'] = None,
                 enabled: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled'] = None):
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def disabled(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabled']:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def enabled(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled']:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabled(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cohortReportSettings":
            suggest = "cohort_report_settings"
        elif key == "cohortsRange":
            suggest = "cohorts_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cohort_report_settings: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettings'] = None,
                 cohorts: Optional[Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort']] = None,
                 cohorts_range: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange'] = None):
        """
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettingsArgs' cohort_report_settings: Optional settings for a cohort report.
        """
        if cohort_report_settings is not None:
            pulumi.set(__self__, "cohort_report_settings", cohort_report_settings)
        if cohorts is not None:
            pulumi.set(__self__, "cohorts", cohorts)
        if cohorts_range is not None:
            pulumi.set(__self__, "cohorts_range", cohorts_range)

    @property
    @pulumi.getter(name="cohortReportSettings")
    def cohort_report_settings(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettings']:
        """
        Optional settings for a cohort report.
        """
        return pulumi.get(self, "cohort_report_settings")

    @property
    @pulumi.getter
    def cohorts(self) -> Optional[Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort']]:
        return pulumi.get(self, "cohorts")

    @property
    @pulumi.getter(name="cohortsRange")
    def cohorts_range(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange']:
        return pulumi.get(self, "cohorts_range")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateRange":
            suggest = "date_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date_range: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange',
                 dimension: str,
                 name: Optional[str] = None):
        """
        :param str dimension: Dimension used by the cohort. Required and only supports `firstSessionDate`. must be one of ["firstSessionDate"]
        :param str name: Assigns a name to this cohort. If not set, cohorts are named by their zero based index cohort_0, cohort_1, etc.
        """
        pulumi.set(__self__, "date_range", date_range)
        pulumi.set(__self__, "dimension", dimension)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dateRange")
    def date_range(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange':
        return pulumi.get(self, "date_range")

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        Dimension used by the cohort. Required and only supports `firstSessionDate`. must be one of ["firstSessionDate"]
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Assigns a name to this cohort. If not set, cohorts are named by their zero based index cohort_0, cohort_1, etc.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: str,
                 start_date: str):
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettings(dict):
    def __init__(__self__, *,
                 accumulate: Optional[bool] = None):
        """
        :param bool accumulate: If true, accumulates the result from first touch day to the end day
        """
        if accumulate is not None:
            pulumi.set(__self__, "accumulate", accumulate)

    @property
    @pulumi.getter
    def accumulate(self) -> Optional[bool]:
        """
        If true, accumulates the result from first touch day to the end day
        """
        return pulumi.get(self, "accumulate")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endOffset":
            suggest = "end_offset"
        elif key == "startOffset":
            suggest = "start_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_offset: int,
                 granularity: str,
                 start_offset: Optional[int] = None):
        """
        :param int end_offset: Specifies the end date of the extended reporting date range for a cohort report.
        :param str granularity: The granularity used to interpret the startOffset and endOffset for the extended reporting date range for a cohort report. must be one of ["GRANULARITY_UNSPECIFIED", "DAILY", "WEEKLY", "MONTHLY"]
        :param int start_offset: Specifies the start date of the extended reporting date range for a cohort report.
        """
        pulumi.set(__self__, "end_offset", end_offset)
        pulumi.set(__self__, "granularity", granularity)
        if start_offset is not None:
            pulumi.set(__self__, "start_offset", start_offset)

    @property
    @pulumi.getter(name="endOffset")
    def end_offset(self) -> int:
        """
        Specifies the end date of the extended reporting date range for a cohort report.
        """
        return pulumi.get(self, "end_offset")

    @property
    @pulumi.getter
    def granularity(self) -> str:
        """
        The granularity used to interpret the startOffset and endOffset for the extended reporting date range for a cohort report. must be one of ["GRANULARITY_UNSPECIFIED", "DAILY", "WEEKLY", "MONTHLY"]
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter(name="startOffset")
    def start_offset(self) -> Optional[int]:
        """
        Specifies the start date of the extended reporting date range for a cohort report.
        """
        return pulumi.get(self, "start_offset")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andGroup":
            suggest = "and_group"
        elif key == "notExpression":
            suggest = "not_expression"
        elif key == "orGroup":
            suggest = "or_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_group: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroup'] = None,
                 filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter'] = None,
                 not_expression: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpression'] = None,
                 or_group: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroup'] = None):
        """
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupArgs' and_group: The FilterExpressions in andGroup have an AND relationship.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterArgs' filter: A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all dimensions.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionArgs' not_expression: The FilterExpression is NOT of notExpression.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupArgs' or_group: The FilterExpressions in orGroup have an OR relationship.
        """
        if and_group is not None:
            pulumi.set(__self__, "and_group", and_group)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if not_expression is not None:
            pulumi.set(__self__, "not_expression", not_expression)
        if or_group is not None:
            pulumi.set(__self__, "or_group", or_group)

    @property
    @pulumi.getter(name="andGroup")
    def and_group(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroup']:
        """
        The FilterExpressions in andGroup have an AND relationship.
        """
        return pulumi.get(self, "and_group")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter']:
        """
        A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all dimensions.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="notExpression")
    def not_expression(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpression']:
        """
        The FilterExpression is NOT of notExpression.
        """
        return pulumi.get(self, "not_expression")

    @property
    @pulumi.getter(name="orGroup")
    def or_group(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroup']:
        """
        The FilterExpressions in orGroup have an OR relationship.
        """
        return pulumi.get(self, "or_group")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroup(dict):
    def __init__(__self__, *,
                 expressions: Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression']):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression']:
        return pulumi.get(self, "expressions")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpression(dict):
    def __init__(__self__, *,
                 expression: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression'] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression']:
        return pulumi.get(self, "expression")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroup(dict):
    def __init__(__self__, *,
                 expressions: Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression']):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression']:
        return pulumi.get(self, "expressions")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andGroup":
            suggest = "and_group"
        elif key == "notExpression":
            suggest = "not_expression"
        elif key == "orGroup":
            suggest = "or_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_group: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroup'] = None,
                 filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter'] = None,
                 not_expression: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpression'] = None,
                 or_group: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroup'] = None):
        """
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupArgs' and_group: The FilterExpressions in andGroup have an AND relationship.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterArgs' filter: A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all metrics.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionArgs' not_expression: The FilterExpression is NOT of notExpression.
        :param 'SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupArgs' or_group: The FilterExpressions in orGroup have an OR relationship.
        """
        if and_group is not None:
            pulumi.set(__self__, "and_group", and_group)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if not_expression is not None:
            pulumi.set(__self__, "not_expression", not_expression)
        if or_group is not None:
            pulumi.set(__self__, "or_group", or_group)

    @property
    @pulumi.getter(name="andGroup")
    def and_group(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroup']:
        """
        The FilterExpressions in andGroup have an AND relationship.
        """
        return pulumi.get(self, "and_group")

    @property
    @pulumi.getter
    def filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter']:
        """
        A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all metrics.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="notExpression")
    def not_expression(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpression']:
        """
        The FilterExpression is NOT of notExpression.
        """
        return pulumi.get(self, "not_expression")

    @property
    @pulumi.getter(name="orGroup")
    def or_group(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroup']:
        """
        The FilterExpressions in orGroup have an OR relationship.
        """
        return pulumi.get(self, "or_group")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroup(dict):
    def __init__(__self__, *,
                 expressions: Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression']):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression']:
        return pulumi.get(self, "expressions")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpression(dict):
    def __init__(__self__, *,
                 expression: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression'] = None):
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression']:
        return pulumi.get(self, "expression")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroup(dict):
    def __init__(__self__, *,
                 expressions: Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression']):
        pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Sequence['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression']:
        return pulumi.get(self, "expressions")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 filter: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter'):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter':
        return pulumi.get(self, "filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "betweenFilter":
            suggest = "between_filter"
        elif key == "inListFilter":
            suggest = "in_list_filter"
        elif key == "numericFilter":
            suggest = "numeric_filter"
        elif key == "stringFilter":
            suggest = "string_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 between_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter'] = None,
                 in_list_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter'] = None,
                 numeric_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilter'] = None,
                 string_filter: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter'] = None):
        if between_filter is not None:
            pulumi.set(__self__, "between_filter", between_filter)
        if in_list_filter is not None:
            pulumi.set(__self__, "in_list_filter", in_list_filter)
        if numeric_filter is not None:
            pulumi.set(__self__, "numeric_filter", numeric_filter)
        if string_filter is not None:
            pulumi.set(__self__, "string_filter", string_filter)

    @property
    @pulumi.getter(name="betweenFilter")
    def between_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter']:
        return pulumi.get(self, "between_filter")

    @property
    @pulumi.getter(name="inListFilter")
    def in_list_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter']:
        return pulumi.get(self, "in_list_filter")

    @property
    @pulumi.getter(name="numericFilter")
    def numeric_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilter']:
        return pulumi.get(self, "numeric_filter")

    @property
    @pulumi.getter(name="stringFilter")
    def string_filter(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter']:
        return pulumi.get(self, "string_filter")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromValue":
            suggest = "from_value"
        elif key == "toValue":
            suggest = "to_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue',
                 to_value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue'):
        pulumi.set(__self__, "from_value", from_value)
        pulumi.set(__self__, "to_value", to_value)

    @property
    @pulumi.getter(name="fromValue")
    def from_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue':
        return pulumi.get(self, "from_value")

    @property
    @pulumi.getter(name="toValue")
    def to_value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue':
        return pulumi.get(self, "to_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 case_sensitive: Optional[bool] = None):
        pulumi.set(__self__, "values", values)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilter(dict):
    def __init__(__self__, *,
                 operations: Sequence[str],
                 value: 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue'):
        pulumi.set(__self__, "operations", operations)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operations(self) -> Sequence[str]:
        return pulumi.get(self, "operations")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue':
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleValue":
            suggest = "double_value"
        elif key == "int64Value":
            suggest = "int64_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValue'] = None,
                 int64_value: Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64Value'] = None):
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if int64_value is not None:
            pulumi.set(__self__, "int64_value", int64_value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValue']:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="int64Value")
    def int64_value(self) -> Optional['outputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64Value']:
        return pulumi.get(self, "int64_value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValue(dict):
    def __init__(__self__, *,
                 value: float):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64Value(dict):
    def __init__(__self__, *,
                 value: str):
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitive":
            suggest = "case_sensitive"
        elif key == "matchTypes":
            suggest = "match_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 case_sensitive: Optional[bool] = None,
                 match_types: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "value", value)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if match_types is not None:
            pulumi.set(__self__, "match_types", match_types)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[bool]:
        return pulumi.get(self, "case_sensitive")

    @property
    @pulumi.getter(name="matchTypes")
    def match_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_types")


@pulumi.output_type
class SourceGoogleAnalyticsV4ServiceAccountOnlyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "viewId":
            suggest = "view_id"
        elif key == "customReports":
            suggest = "custom_reports"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "windowInDays":
            suggest = "window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsV4ServiceAccountOnlyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsV4ServiceAccountOnlyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsV4ServiceAccountOnlyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 view_id: str,
                 credentials: Optional['outputs.SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials'] = None,
                 custom_reports: Optional[str] = None,
                 end_date: Optional[str] = None,
                 window_in_days: Optional[int] = None):
        """
        :param str start_date: The date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        :param str view_id: The ID for the Google Analytics View you want to fetch data from. This can be found from the <a href="https://ga-dev-tools.appspot.com/account-explorer/">Google Analytics Account Explorer</a>.
        :param 'SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsArgs' credentials: Credentials for the service
        :param str custom_reports: A JSON array describing the custom reports you want to sync from Google Analytics. See <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4#data-processing-latency">the docs</a> for more information about the exact format you can use to fill out this field.
        :param str end_date: The date in the format YYYY-MM-DD. Any data after this date will not be replicated.
        :param int window_in_days: The time increment used by the connector when requesting data from the Google Analytics API. More information is available in the <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4/#sampling-in-reports">the docs</a>. The bigger this value is, the faster the sync will be, but the more likely that sampling will be applied to your data, potentially causing inaccuracies in the returned results. We recommend setting this to 1 unless you have a hard requirement to make the sync faster at the expense of accuracy. The minimum allowed value for this field is 1, and the maximum is 364. . Default: 1
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "view_id", view_id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if window_in_days is not None:
            pulumi.set(__self__, "window_in_days", window_in_days)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> str:
        """
        The ID for the Google Analytics View you want to fetch data from. This can be found from the <a href="https://ga-dev-tools.appspot.com/account-explorer/">Google Analytics Account Explorer</a>.
        """
        return pulumi.get(self, "view_id")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials']:
        """
        Credentials for the service
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[str]:
        """
        A JSON array describing the custom reports you want to sync from Google Analytics. See <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4#data-processing-latency">the docs</a> for more information about the exact format you can use to fill out this field.
        """
        return pulumi.get(self, "custom_reports")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The date in the format YYYY-MM-DD. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="windowInDays")
    def window_in_days(self) -> Optional[int]:
        """
        The time increment used by the connector when requesting data from the Google Analytics API. More information is available in the <a href="https://docs.airbyte.com/integrations/sources/google-analytics-v4/#sampling-in-reports">the docs</a>. The bigger this value is, the faster the sync will be, but the more likely that sampling will be applied to your data, potentially causing inaccuracies in the returned results. We recommend setting this to 1 unless you have a hard requirement to make the sync faster at the expense of accuracy. The minimum allowed value for this field is 1, and the maximum is 364. . Default: 1
        """
        return pulumi.get(self, "window_in_days")


@pulumi.output_type
class SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountKeyAuthentication":
            suggest = "service_account_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_key_authentication: Optional['outputs.SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication'] = None):
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional['outputs.SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication']:
        return pulumi.get(self, "service_account_key_authentication")


@pulumi.output_type
class SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsJson":
            suggest = "credentials_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleAnalyticsV4ServiceAccountOnlyConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_json: str):
        """
        :param str credentials_json: The JSON key of the service account to use for authorization
        """
        pulumi.set(__self__, "credentials_json", credentials_json)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> str:
        """
        The JSON key of the service account to use for authorization
        """
        return pulumi.get(self, "credentials_json")


@pulumi.output_type
class SourceGoogleDirectoryConfiguration(dict):
    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceGoogleDirectoryConfigurationCredentials'] = None):
        """
        :param 'SourceGoogleDirectoryConfigurationCredentialsArgs' credentials: Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports <a href="https://developers.google.com/identity/protocols/oauth2#webserver" target="_blank">Web server application</a> and <a href="https://developers.google.com/identity/protocols/oauth2#serviceaccount" target="_blank">Service accounts</a> scenarios.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceGoogleDirectoryConfigurationCredentials']:
        """
        Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports <a href="https://developers.google.com/identity/protocols/oauth2#webserver" target="_blank">Web server application</a> and <a href="https://developers.google.com/identity/protocols/oauth2#serviceaccount" target="_blank">Service accounts</a> scenarios.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceGoogleDirectoryConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountKey":
            suggest = "service_account_key"
        elif key == "signInViaGoogleOAuth":
            suggest = "sign_in_via_google_o_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDirectoryConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDirectoryConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDirectoryConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_key: Optional['outputs.SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey'] = None,
                 sign_in_via_google_o_auth: Optional['outputs.SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth'] = None):
        """
        :param 'SourceGoogleDirectoryConfigurationCredentialsServiceAccountKeyArgs' service_account_key: For these scenario user should obtain service account's credentials from the Google API Console and provide delegated email.
        :param 'SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuthArgs' sign_in_via_google_o_auth: For these scenario user only needs to give permission to read Google Directory data.
        """
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if sign_in_via_google_o_auth is not None:
            pulumi.set(__self__, "sign_in_via_google_o_auth", sign_in_via_google_o_auth)

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional['outputs.SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey']:
        """
        For these scenario user should obtain service account's credentials from the Google API Console and provide delegated email.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter(name="signInViaGoogleOAuth")
    def sign_in_via_google_o_auth(self) -> Optional['outputs.SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth']:
        """
        For these scenario user only needs to give permission to read Google Directory data.
        """
        return pulumi.get(self, "sign_in_via_google_o_auth")


@pulumi.output_type
class SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsJson":
            suggest = "credentials_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_json: str,
                 email: str):
        """
        :param str credentials_json: The contents of the JSON service account key. See the <a href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation">docs</a> for more information on how to generate this key.
        :param str email: The email of the user, which has permissions to access the Google Workspace Admin APIs.
        """
        pulumi.set(__self__, "credentials_json", credentials_json)
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="credentialsJson")
    def credentials_json(self) -> str:
        """
        The contents of the JSON service account key. See the <a href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation">docs</a> for more information on how to generate this key.
        """
        return pulumi.get(self, "credentials_json")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user, which has permissions to access the Google Workspace Admin APIs.
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The Client ID of the developer application.
        :param str client_secret: The Client Secret of the developer application.
        :param str refresh_token: The Token for obtaining a new access token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of the developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of the developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The Token for obtaining a new access token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceGoogleDriveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderUrl":
            suggest = "folder_url"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceGoogleDriveConfigurationCredentials',
                 folder_url: str,
                 streams: Sequence['outputs.SourceGoogleDriveConfigurationStream'],
                 start_date: Optional[str] = None):
        """
        :param 'SourceGoogleDriveConfigurationCredentialsArgs' credentials: Credentials for connecting to the Google Drive API
        :param str folder_url: URL for the folder you want to sync. Using individual streams and glob patterns, it's possible to only sync a subset of all files located in the folder.
        :param Sequence['SourceGoogleDriveConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "folder_url", folder_url)
        pulumi.set(__self__, "streams", streams)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceGoogleDriveConfigurationCredentials':
        """
        Credentials for connecting to the Google Drive API
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="folderUrl")
    def folder_url(self) -> str:
        """
        URL for the folder you want to sync. Using individual streams and glob patterns, it's possible to only sync a subset of all files located in the folder.
        """
        return pulumi.get(self, "folder_url")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceGoogleDriveConfigurationStream']:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGoogleDriveConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaGoogleOAuth":
            suggest = "authenticate_via_google_o_auth"
        elif key == "serviceAccountKeyAuthentication":
            suggest = "service_account_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_google_o_auth: Optional['outputs.SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth'] = None,
                 service_account_key_authentication: Optional['outputs.SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication'] = None):
        if authenticate_via_google_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_google_o_auth", authenticate_via_google_o_auth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaGoogleOAuth")
    def authenticate_via_google_o_auth(self) -> Optional['outputs.SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth']:
        return pulumi.get(self, "authenticate_via_google_o_auth")

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional['outputs.SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication']:
        return pulumi.get(self, "service_account_key_authentication")


@pulumi.output_type
class SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: Client ID for the Google Drive API
        :param str client_secret: Client Secret for the Google Drive API
        :param str refresh_token: Refresh Token for the Google Drive API
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID for the Google Drive API
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client Secret for the Google Drive API
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token for the Google Drive API
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountInfo":
            suggest = "service_account_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_info: str):
        """
        :param str service_account_info: The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        pulumi.set(__self__, "service_account_info", service_account_info)

    @property
    @pulumi.getter(name="serviceAccountInfo")
    def service_account_info(self) -> str:
        """
        The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        return pulumi.get(self, "service_account_info")


@pulumi.output_type
class SourceGoogleDriveConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceGoogleDriveConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceGoogleDriveConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceGoogleDriveConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFormat":
            suggest = "avro_format"
        elif key == "csvFormat":
            suggest = "csv_format"
        elif key == "documentFileTypeFormatExperimental":
            suggest = "document_file_type_format_experimental"
        elif key == "jsonlFormat":
            suggest = "jsonl_format"
        elif key == "parquetFormat":
            suggest = "parquet_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_format: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatAvroFormat'] = None,
                 csv_format: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormat'] = None,
                 document_file_type_format_experimental: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental'] = None,
                 jsonl_format: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatJsonlFormat'] = None,
                 parquet_format: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatParquetFormat'] = None):
        """
        :param 'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs' document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatAvroFormat']:
        return pulumi.get(self, "avro_format")

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental']:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatJsonlFormat']:
        return pulumi.get(self, "jsonl_format")

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatParquetFormat']:
        return pulumi.get(self, "parquet_format")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatAvroFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleAsString":
            suggest = "double_as_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormatAvroFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_as_string: Optional[bool] = None):
        """
        :param bool double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[bool]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnprocessableFiles":
            suggest = "skip_unprocessable_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processing: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing'] = None,
                 skip_unprocessable_files: Optional[bool] = None,
                 strategy: Optional[str] = None):
        """
        :param 'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs' processing: Processing configuration
        :param bool skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param str strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing']:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[bool]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing(dict):
    def __init__(__self__, *,
                 local: Optional['outputs.SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal'] = None):
        """
        :param 'SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs' local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal']:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatJsonlFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceGoogleDriveConfigurationStreamFormatParquetFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalAsFloat":
            suggest = "decimal_as_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleDriveConfigurationStreamFormatParquetFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleDriveConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleDriveConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_as_float: Optional[bool] = None):
        """
        :param bool decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[bool]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")


@pulumi.output_type
class SourceGooglePagespeedInsightsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGooglePagespeedInsightsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGooglePagespeedInsightsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGooglePagespeedInsightsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence[str],
                 strategies: Sequence[str],
                 urls: Sequence[str],
                 api_key: Optional[str] = None):
        """
        :param Sequence[str] categories: Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
        :param Sequence[str] strategies: The analyses strategy to use. Either "desktop" or "mobile".
        :param Sequence[str] urls: The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
        :param str api_key: Google PageSpeed API Key. See <a href="https://developers.google.com/speed/docs/insights/v5/get-started#APIKey">here</a>. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "strategies", strategies)
        pulumi.set(__self__, "urls", urls)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter
    def categories(self) -> Sequence[str]:
        """
        Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def strategies(self) -> Sequence[str]:
        """
        The analyses strategy to use. Either "desktop" or "mobile".
        """
        return pulumi.get(self, "strategies")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        """
        The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
        """
        return pulumi.get(self, "urls")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Google PageSpeed API Key. See <a href="https://developers.google.com/speed/docs/insights/v5/get-started#APIKey">here</a>. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceGoogleSearchConsoleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteUrls":
            suggest = "site_urls"
        elif key == "customReports":
            suggest = "custom_reports"
        elif key == "customReportsArrays":
            suggest = "custom_reports_arrays"
        elif key == "dataState":
            suggest = "data_state"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSearchConsoleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSearchConsoleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSearchConsoleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization: 'outputs.SourceGoogleSearchConsoleConfigurationAuthorization',
                 site_urls: Sequence[str],
                 custom_reports: Optional[str] = None,
                 custom_reports_arrays: Optional[Sequence['outputs.SourceGoogleSearchConsoleConfigurationCustomReportsArray']] = None,
                 data_state: Optional[str] = None,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param Sequence[str] site_urls: The URLs of the website property attached to your GSC account. Learn more about properties <a href="https://support.google.com/webmasters/answer/34592?hl=en">here</a>.
        :param str custom_reports: (DEPRCATED) A JSON array describing the custom reports you want to sync from Google Search Console. See our <a href='https://docs.airbyte.com/integrations/sources/google-search-console'>documentation</a> for more information on formulating custom reports.
        :param Sequence['SourceGoogleSearchConsoleConfigurationCustomReportsArrayArgs'] custom_reports_arrays: You can add your Custom Analytics report by creating one.
        :param str data_state: If set to 'final', the returned data will include only finalized, stable data. If set to 'all', fresh data will be included. When using Incremental sync mode, we do not recommend setting this parameter to 'all' as it may cause data loss. More information can be found in our <a href='https://docs.airbyte.com/integrations/source/google-search-console'>full documentation</a>. must be one of ["final", "all"]; Default: "final"
        :param str end_date: UTC date in the format YYYY-MM-DD. Any data created after this date will not be replicated. Must be greater or equal to the start date field. Leaving this field blank will replicate all data from the start date onward.
        :param str start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. Default: "2021-01-01"
        """
        pulumi.set(__self__, "authorization", authorization)
        pulumi.set(__self__, "site_urls", site_urls)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if custom_reports_arrays is not None:
            pulumi.set(__self__, "custom_reports_arrays", custom_reports_arrays)
        if data_state is not None:
            pulumi.set(__self__, "data_state", data_state)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def authorization(self) -> 'outputs.SourceGoogleSearchConsoleConfigurationAuthorization':
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> Sequence[str]:
        """
        The URLs of the website property attached to your GSC account. Learn more about properties <a href="https://support.google.com/webmasters/answer/34592?hl=en">here</a>.
        """
        return pulumi.get(self, "site_urls")

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[str]:
        """
        (DEPRCATED) A JSON array describing the custom reports you want to sync from Google Search Console. See our <a href='https://docs.airbyte.com/integrations/sources/google-search-console'>documentation</a> for more information on formulating custom reports.
        """
        return pulumi.get(self, "custom_reports")

    @property
    @pulumi.getter(name="customReportsArrays")
    def custom_reports_arrays(self) -> Optional[Sequence['outputs.SourceGoogleSearchConsoleConfigurationCustomReportsArray']]:
        """
        You can add your Custom Analytics report by creating one.
        """
        return pulumi.get(self, "custom_reports_arrays")

    @property
    @pulumi.getter(name="dataState")
    def data_state(self) -> Optional[str]:
        """
        If set to 'final', the returned data will include only finalized, stable data. If set to 'all', fresh data will be included. When using Incremental sync mode, we do not recommend setting this parameter to 'all' as it may cause data loss. More information can be found in our <a href='https://docs.airbyte.com/integrations/source/google-search-console'>full documentation</a>. must be one of ["final", "all"]; Default: "final"
        """
        return pulumi.get(self, "data_state")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        UTC date in the format YYYY-MM-DD. Any data created after this date will not be replicated. Must be greater or equal to the start date field. Leaving this field blank will replicate all data from the start date onward.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. Default: "2021-01-01"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceGoogleSearchConsoleConfigurationAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth":
            suggest = "o_auth"
        elif key == "serviceAccountKeyAuthentication":
            suggest = "service_account_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSearchConsoleConfigurationAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSearchConsoleConfigurationAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSearchConsoleConfigurationAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth: Optional['outputs.SourceGoogleSearchConsoleConfigurationAuthorizationOAuth'] = None,
                 service_account_key_authentication: Optional['outputs.SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication'] = None):
        if o_auth is not None:
            pulumi.set(__self__, "o_auth", o_auth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="oAuth")
    def o_auth(self) -> Optional['outputs.SourceGoogleSearchConsoleConfigurationAuthorizationOAuth']:
        return pulumi.get(self, "o_auth")

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional['outputs.SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication']:
        return pulumi.get(self, "service_account_key_authentication")


@pulumi.output_type
class SourceGoogleSearchConsoleConfigurationAuthorizationOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSearchConsoleConfigurationAuthorizationOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSearchConsoleConfigurationAuthorizationOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSearchConsoleConfigurationAuthorizationOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 access_token: Optional[str] = None):
        """
        :param str client_id: The client ID of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        :param str client_secret: The client secret of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        :param str refresh_token: The token for obtaining a new access token. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        :param str access_token: Access token for making authenticated requests. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token for obtaining a new access token. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Access token for making authenticated requests. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountInfo":
            suggest = "service_account_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 service_account_info: str):
        """
        :param str email: The email of the user which has permissions to access the Google Workspace Admin APIs.
        :param str service_account_info: The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">here</a>.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "service_account_info", service_account_info)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email of the user which has permissions to access the Google Workspace Admin APIs.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="serviceAccountInfo")
    def service_account_info(self) -> str:
        """
        The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">here</a>.
        """
        return pulumi.get(self, "service_account_info")


@pulumi.output_type
class SourceGoogleSearchConsoleConfigurationCustomReportsArray(dict):
    def __init__(__self__, *,
                 dimensions: Sequence[str],
                 name: str):
        """
        :param Sequence[str] dimensions: A list of available dimensions. Please note, that for technical reasons `date` is the default dimension which will be included in your query whether you specify it or not. Primary key will consist of your custom dimensions and the default dimension along with `site_url` and `search_type`.
        :param str name: The name of the custom report, this name would be used as stream name
        """
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence[str]:
        """
        A list of available dimensions. Please note, that for technical reasons `date` is the default dimension which will be included in your query whether you specify it or not. Primary key will consist of your custom dimensions and the default dimension along with `site_url` and `search_type`.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the custom report, this name would be used as stream name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SourceGoogleSheetsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spreadsheetId":
            suggest = "spreadsheet_id"
        elif key == "batchSize":
            suggest = "batch_size"
        elif key == "namesConversion":
            suggest = "names_conversion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSheetsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSheetsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSheetsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceGoogleSheetsConfigurationCredentials',
                 spreadsheet_id: str,
                 batch_size: Optional[int] = None,
                 names_conversion: Optional[bool] = None):
        """
        :param 'SourceGoogleSheetsConfigurationCredentialsArgs' credentials: Credentials for connecting to the Google Sheets API
        :param str spreadsheet_id: Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
        :param int batch_size: Default value is 200. An integer representing row batch size for each sent request to Google Sheets API. Row batch size means how many rows are processed from the google sheet, for example default value 200 would process rows 1-201, then 201-401 and so on. Based on <a href='https://developers.google.com/sheets/api/limits'>Google Sheets API limits documentation</a>, it is possible to send up to 300 requests per minute, but each individual request has to be processed under 180 seconds, otherwise the request returns a timeout error. In regards to this information, consider network speed and number of columns of the google sheet when deciding a batch_size value. Default value should cover most of the cases, but if a google sheet has over 100,000 records or more, consider increasing batch_size value. Default: 200
        :param bool names_conversion: Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based. Default: false
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "spreadsheet_id", spreadsheet_id)
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if names_conversion is not None:
            pulumi.set(__self__, "names_conversion", names_conversion)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceGoogleSheetsConfigurationCredentials':
        """
        Credentials for connecting to the Google Sheets API
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="spreadsheetId")
    def spreadsheet_id(self) -> str:
        """
        Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
        """
        return pulumi.get(self, "spreadsheet_id")

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[int]:
        """
        Default value is 200. An integer representing row batch size for each sent request to Google Sheets API. Row batch size means how many rows are processed from the google sheet, for example default value 200 would process rows 1-201, then 201-401 and so on. Based on <a href='https://developers.google.com/sheets/api/limits'>Google Sheets API limits documentation</a>, it is possible to send up to 300 requests per minute, but each individual request has to be processed under 180 seconds, otherwise the request returns a timeout error. In regards to this information, consider network speed and number of columns of the google sheet when deciding a batch_size value. Default value should cover most of the cases, but if a google sheet has over 100,000 records or more, consider increasing batch_size value. Default: 200
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="namesConversion")
    def names_conversion(self) -> Optional[bool]:
        """
        Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based. Default: false
        """
        return pulumi.get(self, "names_conversion")


@pulumi.output_type
class SourceGoogleSheetsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaGoogleOAuth":
            suggest = "authenticate_via_google_o_auth"
        elif key == "serviceAccountKeyAuthentication":
            suggest = "service_account_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSheetsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSheetsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSheetsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_google_o_auth: Optional['outputs.SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth'] = None,
                 service_account_key_authentication: Optional['outputs.SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication'] = None):
        if authenticate_via_google_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_google_o_auth", authenticate_via_google_o_auth)
        if service_account_key_authentication is not None:
            pulumi.set(__self__, "service_account_key_authentication", service_account_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaGoogleOAuth")
    def authenticate_via_google_o_auth(self) -> Optional['outputs.SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth']:
        return pulumi.get(self, "authenticate_via_google_o_auth")

    @property
    @pulumi.getter(name="serviceAccountKeyAuthentication")
    def service_account_key_authentication(self) -> Optional['outputs.SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication']:
        return pulumi.get(self, "service_account_key_authentication")


@pulumi.output_type
class SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: Enter your Google application's Client ID. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        :param str client_secret: Enter your Google application's Client Secret. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        :param str refresh_token: Enter your Google application's refresh token. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Enter your Google application's Client ID. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Enter your Google application's Client Secret. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Enter your Google application's refresh token. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountInfo":
            suggest = "service_account_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_info: str):
        """
        :param str service_account_info: The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        pulumi.set(__self__, "service_account_info", service_account_info)

    @property
    @pulumi.getter(name="serviceAccountInfo")
    def service_account_info(self) -> str:
        """
        The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
        """
        return pulumi.get(self, "service_account_info")


@pulumi.output_type
class SourceGoogleWebfontsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "prettyPrint":
            suggest = "pretty_print"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGoogleWebfontsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGoogleWebfontsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGoogleWebfontsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 alt: Optional[str] = None,
                 pretty_print: Optional[str] = None,
                 sort: Optional[str] = None):
        """
        :param str api_key: API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
        :param str alt: Optional, Available params- json, media, proto
        :param str pretty_print: Optional, boolean type
        :param str sort: Optional, to find how to sort
        """
        pulumi.set(__self__, "api_key", api_key)
        if alt is not None:
            pulumi.set(__self__, "alt", alt)
        if pretty_print is not None:
            pulumi.set(__self__, "pretty_print", pretty_print)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def alt(self) -> Optional[str]:
        """
        Optional, Available params- json, media, proto
        """
        return pulumi.get(self, "alt")

    @property
    @pulumi.getter(name="prettyPrint")
    def pretty_print(self) -> Optional[str]:
        """
        Optional, boolean type
        """
        return pulumi.get(self, "pretty_print")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        Optional, to find how to sort
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class SourceGreenhouseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGreenhouseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGreenhouseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGreenhouseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Greenhouse API Key. See the <a href="https://docs.airbyte.com/integrations/sources/greenhouse">docs</a> for more information on how to generate this key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Greenhouse API Key. See the <a href="https://docs.airbyte.com/integrations/sources/greenhouse">docs</a> for more information on how to generate this key.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceGridlyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "gridId":
            suggest = "grid_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceGridlyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceGridlyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceGridlyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 grid_id: str):
        """
        :param str grid_id: ID of a grid, or can be ID of a branch
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "grid_id", grid_id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="gridId")
    def grid_id(self) -> str:
        """
        ID of a grid, or can be ID of a branch
        """
        return pulumi.get(self, "grid_id")


@pulumi.output_type
class SourceHarvestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "replicationStartDate":
            suggest = "replication_start_date"
        elif key == "replicationEndDate":
            suggest = "replication_end_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHarvestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHarvestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHarvestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 replication_start_date: str,
                 credentials: Optional['outputs.SourceHarvestConfigurationCredentials'] = None,
                 replication_end_date: Optional[str] = None):
        """
        :param str account_id: Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
        :param str replication_start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param 'SourceHarvestConfigurationCredentialsArgs' credentials: Choose how to authenticate to Harvest.
        :param str replication_end_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "replication_start_date", replication_start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if replication_end_date is not None:
            pulumi.set(__self__, "replication_end_date", replication_end_date)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="replicationStartDate")
    def replication_start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "replication_start_date")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceHarvestConfigurationCredentials']:
        """
        Choose how to authenticate to Harvest.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="replicationEndDate")
    def replication_end_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "replication_end_date")


@pulumi.output_type
class SourceHarvestConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaHarvestOAuth":
            suggest = "authenticate_via_harvest_o_auth"
        elif key == "authenticateWithPersonalAccessToken":
            suggest = "authenticate_with_personal_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHarvestConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHarvestConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHarvestConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_harvest_o_auth: Optional['outputs.SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth'] = None,
                 authenticate_with_personal_access_token: Optional['outputs.SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken'] = None):
        if authenticate_via_harvest_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_harvest_o_auth", authenticate_via_harvest_o_auth)
        if authenticate_with_personal_access_token is not None:
            pulumi.set(__self__, "authenticate_with_personal_access_token", authenticate_with_personal_access_token)

    @property
    @pulumi.getter(name="authenticateViaHarvestOAuth")
    def authenticate_via_harvest_o_auth(self) -> Optional['outputs.SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth']:
        return pulumi.get(self, "authenticate_via_harvest_o_auth")

    @property
    @pulumi.getter(name="authenticateWithPersonalAccessToken")
    def authenticate_with_personal_access_token(self) -> Optional['outputs.SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken']:
        return pulumi.get(self, "authenticate_with_personal_access_token")


@pulumi.output_type
class SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 additional_properties: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Harvest developer application.
        :param str client_secret: The Client Secret of your Harvest developer application.
        :param str refresh_token: Refresh Token to renew the expired Access Token.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Harvest developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Harvest developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 additional_properties: Optional[str] = None):
        """
        :param str api_token: Log into Harvest and then create new <a href="https://id.getharvest.com/developers"> personal access token</a>.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_token", api_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Log into Harvest and then create new <a href="https://id.getharvest.com/developers"> personal access token</a>.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceHubplannerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHubplannerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHubplannerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHubplannerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceHubspotConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableExperimentalStreams":
            suggest = "enable_experimental_streams"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHubspotConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHubspotConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHubspotConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceHubspotConfigurationCredentials',
                 enable_experimental_streams: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceHubspotConfigurationCredentialsArgs' credentials: Choose how to authenticate to HubSpot.
        :param bool enable_experimental_streams: If enabled then experimental streams become available for sync. Default: false
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If not set, "2006-06-01T00:00:00Z" (Hubspot creation date) will be used as start date. It's recommended to provide relevant to your data start date value to optimize synchronization.
        """
        pulumi.set(__self__, "credentials", credentials)
        if enable_experimental_streams is not None:
            pulumi.set(__self__, "enable_experimental_streams", enable_experimental_streams)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceHubspotConfigurationCredentials':
        """
        Choose how to authenticate to HubSpot.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="enableExperimentalStreams")
    def enable_experimental_streams(self) -> Optional[bool]:
        """
        If enabled then experimental streams become available for sync. Default: false
        """
        return pulumi.get(self, "enable_experimental_streams")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If not set, "2006-06-01T00:00:00Z" (Hubspot creation date) will be used as start date. It's recommended to provide relevant to your data start date value to optimize synchronization.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceHubspotConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth":
            suggest = "o_auth"
        elif key == "privateApp":
            suggest = "private_app"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHubspotConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHubspotConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHubspotConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth: Optional['outputs.SourceHubspotConfigurationCredentialsOAuth'] = None,
                 private_app: Optional['outputs.SourceHubspotConfigurationCredentialsPrivateApp'] = None):
        if o_auth is not None:
            pulumi.set(__self__, "o_auth", o_auth)
        if private_app is not None:
            pulumi.set(__self__, "private_app", private_app)

    @property
    @pulumi.getter(name="oAuth")
    def o_auth(self) -> Optional['outputs.SourceHubspotConfigurationCredentialsOAuth']:
        return pulumi.get(self, "o_auth")

    @property
    @pulumi.getter(name="privateApp")
    def private_app(self) -> Optional['outputs.SourceHubspotConfigurationCredentialsPrivateApp']:
        return pulumi.get(self, "private_app")


@pulumi.output_type
class SourceHubspotConfigurationCredentialsOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHubspotConfigurationCredentialsOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHubspotConfigurationCredentialsOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHubspotConfigurationCredentialsOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The Client ID of your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this ID.
        :param str client_secret: The client secret for your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this secret.
        :param str refresh_token: Refresh token to renew an expired access token. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this token.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this ID.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret for your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh token to renew an expired access token. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this token.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceHubspotConfigurationCredentialsPrivateApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceHubspotConfigurationCredentialsPrivateApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceHubspotConfigurationCredentialsPrivateApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceHubspotConfigurationCredentialsPrivateApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: HubSpot Access token. See the <a href="https://developers.hubspot.com/docs/api/private-apps">Hubspot docs</a> if you need help finding this token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        HubSpot Access token. See the <a href="https://developers.hubspot.com/docs/api/private-apps">Hubspot docs</a> if you need help finding this token.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceInsightlyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceInsightlyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceInsightlyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceInsightlyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 token: str):
        """
        :param str start_date: The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
        :param str token: Your Insightly API token.
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Your Insightly API token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class SourceInstagramConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceInstagramConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceInstagramConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceInstagramConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str access_token: The value of the access token generated with <b>instagram_basic, instagram_manage_insights, pages_show_list, pages_read_engagement, Instagram Public Content Access</b> permissions. See the <a href="https://docs.airbyte.com/integrations/sources/instagram/#step-1-set-up-instagram">docs</a> for more information
        :param str client_id: The Client ID for your Oauth application
        :param str client_secret: The Client Secret for your Oauth application
        :param str start_date: The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The value of the access token generated with <b>instagram_basic, instagram_manage_insights, pages_show_list, pages_read_engagement, Instagram Public Content Access</b> permissions. See the <a href="https://docs.airbyte.com/integrations/sources/instagram/#step-1-set-up-instagram">docs</a> for more information
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID for your Oauth application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret for your Oauth application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceInstatusConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceInstatusConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceInstatusConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceInstatusConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Instatus REST API key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Instatus REST API key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceIntercomConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceIntercomConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceIntercomConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceIntercomConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 start_date: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: Access token for making authenticated requests. See the <a href="https://developers.intercom.com/building-apps/docs/authentication-types#how-to-get-your-access-token">Intercom docs</a> for more information.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param str client_id: Client Id for your Intercom application.
        :param str client_secret: Client Secret for your Intercom application.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "start_date", start_date)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access token for making authenticated requests. See the <a href="https://developers.intercom.com/building-apps/docs/authentication-types#how-to-get-your-access-token">Intercom docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client Id for your Intercom application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Client Secret for your Intercom application.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceIp2whoisConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceIp2whoisConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceIp2whoisConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceIp2whoisConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[str] = None,
                 domain: Optional[str] = None):
        """
        :param str api_key: Your API Key. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        :param str domain: Domain name. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        Your API Key. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain name. See <a href="https://www.ip2whois.com/developers-api">here</a>.
        """
        return pulumi.get(self, "domain")


@pulumi.output_type
class SourceIterableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceIterableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceIterableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceIterableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str):
        """
        :param str api_key: Iterable API Key. See the <a href=\\"https://docs.airbyte.com/integrations/sources/iterable\\">docs</a>  for more information on how to obtain this key.
        :param str start_date: The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z.  All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Iterable API Key. See the <a href=\\"https://docs.airbyte.com/integrations/sources/iterable\\">docs</a>  for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z.  All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceJiraConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "enableExperimentalStreams":
            suggest = "enable_experimental_streams"
        elif key == "expandIssueChangelog":
            suggest = "expand_issue_changelog"
        elif key == "expandIssueTransition":
            suggest = "expand_issue_transition"
        elif key == "issuesStreamExpandWiths":
            suggest = "issues_stream_expand_withs"
        elif key == "lookbackWindowMinutes":
            suggest = "lookback_window_minutes"
        elif key == "renderFields":
            suggest = "render_fields"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceJiraConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceJiraConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceJiraConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 domain: str,
                 email: str,
                 enable_experimental_streams: Optional[bool] = None,
                 expand_issue_changelog: Optional[bool] = None,
                 expand_issue_transition: Optional[bool] = None,
                 issues_stream_expand_withs: Optional[Sequence[str]] = None,
                 lookback_window_minutes: Optional[int] = None,
                 projects: Optional[Sequence[str]] = None,
                 render_fields: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param str api_token: Jira API Token. See the <a href="https://docs.airbyte.com/integrations/sources/jira">docs</a> for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
        :param str domain: The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
        :param str email: The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
        :param bool enable_experimental_streams: Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info. Default: false
        :param bool expand_issue_changelog: (DEPRECATED) Expand the changelog when replicating issues. Default: false
        :param bool expand_issue_transition: (DEPRECATED) Expand the transitions when replicating issues. Default: false
        :param Sequence[str] issues_stream_expand_withs: Select fields to Expand the `Issues` stream when replicating with:
        :param int lookback_window_minutes: When set to N, the connector will always refresh resources created within the past N minutes. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        :param Sequence[str] projects: List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
        :param bool render_fields: (DEPRECATED) Render issue fields in HTML format in addition to Jira JSON-like format. Default: false
        :param str start_date: The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the <a href="https://docs.airbyte.com/integrations/sources/jira/">documentation</a>.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "email", email)
        if enable_experimental_streams is not None:
            pulumi.set(__self__, "enable_experimental_streams", enable_experimental_streams)
        if expand_issue_changelog is not None:
            pulumi.set(__self__, "expand_issue_changelog", expand_issue_changelog)
        if expand_issue_transition is not None:
            pulumi.set(__self__, "expand_issue_transition", expand_issue_transition)
        if issues_stream_expand_withs is not None:
            pulumi.set(__self__, "issues_stream_expand_withs", issues_stream_expand_withs)
        if lookback_window_minutes is not None:
            pulumi.set(__self__, "lookback_window_minutes", lookback_window_minutes)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if render_fields is not None:
            pulumi.set(__self__, "render_fields", render_fields)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Jira API Token. See the <a href="https://docs.airbyte.com/integrations/sources/jira">docs</a> for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="enableExperimentalStreams")
    def enable_experimental_streams(self) -> Optional[bool]:
        """
        Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info. Default: false
        """
        return pulumi.get(self, "enable_experimental_streams")

    @property
    @pulumi.getter(name="expandIssueChangelog")
    def expand_issue_changelog(self) -> Optional[bool]:
        """
        (DEPRECATED) Expand the changelog when replicating issues. Default: false
        """
        return pulumi.get(self, "expand_issue_changelog")

    @property
    @pulumi.getter(name="expandIssueTransition")
    def expand_issue_transition(self) -> Optional[bool]:
        """
        (DEPRECATED) Expand the transitions when replicating issues. Default: false
        """
        return pulumi.get(self, "expand_issue_transition")

    @property
    @pulumi.getter(name="issuesStreamExpandWiths")
    def issues_stream_expand_withs(self) -> Optional[Sequence[str]]:
        """
        Select fields to Expand the `Issues` stream when replicating with:
        """
        return pulumi.get(self, "issues_stream_expand_withs")

    @property
    @pulumi.getter(name="lookbackWindowMinutes")
    def lookback_window_minutes(self) -> Optional[int]:
        """
        When set to N, the connector will always refresh resources created within the past N minutes. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        """
        return pulumi.get(self, "lookback_window_minutes")

    @property
    @pulumi.getter
    def projects(self) -> Optional[Sequence[str]]:
        """
        List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
        """
        return pulumi.get(self, "projects")

    @property
    @pulumi.getter(name="renderFields")
    def render_fields(self) -> Optional[bool]:
        """
        (DEPRECATED) Render issue fields in HTML format in addition to Jira JSON-like format. Default: false
        """
        return pulumi.get(self, "render_fields")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the <a href="https://docs.airbyte.com/integrations/sources/jira/">documentation</a>.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceK6CloudConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceK6CloudConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceK6CloudConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceK6CloudConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: Your API Token. See <a href="https://k6.io/docs/cloud/integrations/token/">here</a>. The key is case sensitive.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Your API Token. See <a href="https://k6.io/docs/cloud/integrations/token/">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class SourceKlarnaConfiguration(dict):
    def __init__(__self__, *,
                 password: str,
                 region: str,
                 username: str,
                 playground: Optional[bool] = None):
        """
        :param str password: A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
        :param str region: Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'. must be one of ["eu", "us", "oc"]
        :param str username: Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
        :param bool playground: Propertie defining if connector is used against playground or production environment. Default: false
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "username", username)
        if playground is not None:
            pulumi.set(__self__, "playground", playground)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'us', 'oc'. must be one of ["eu", "us", "oc"]
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def playground(self) -> Optional[bool]:
        """
        Propertie defining if connector is used against playground or production environment. Default: false
        """
        return pulumi.get(self, "playground")


@pulumi.output_type
class SourceKlaviyoConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKlaviyoConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKlaviyoConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKlaviyoConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: Optional[str] = None):
        """
        :param str api_key: Klaviyo API Key. See our <a href="https://docs.airbyte.com/integrations/sources/klaviyo">docs</a> if you need help finding this key.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This field is optional - if not provided, all data will be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Klaviyo API Key. See our <a href="https://docs.airbyte.com/integrations/sources/klaviyo">docs</a> if you need help finding this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This field is optional - if not provided, all data will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceKyveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "poolIds":
            suggest = "pool_ids"
        elif key == "startIds":
            suggest = "start_ids"
        elif key == "maxPages":
            suggest = "max_pages"
        elif key == "pageSize":
            suggest = "page_size"
        elif key == "urlBase":
            suggest = "url_base"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKyveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKyveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKyveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pool_ids: str,
                 start_ids: str,
                 max_pages: Optional[int] = None,
                 page_size: Optional[int] = None,
                 url_base: Optional[str] = None):
        """
        :param str pool_ids: The IDs of the KYVE storage pool you want to archive. (Comma separated)
        :param str start_ids: The start-id defines, from which bundle id the pipeline should start to extract the data. (Comma separated)
        :param int max_pages: The maximum amount of pages to go trough. Set to 'null' for all pages.
        :param int page_size: The pagesize for pagination, smaller numbers are used in integration tests. Default: 100
        :param str url_base: URL to the KYVE Chain API. Default: "https://api.kyve.network"
        """
        pulumi.set(__self__, "pool_ids", pool_ids)
        pulumi.set(__self__, "start_ids", start_ids)
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if page_size is not None:
            pulumi.set(__self__, "page_size", page_size)
        if url_base is not None:
            pulumi.set(__self__, "url_base", url_base)

    @property
    @pulumi.getter(name="poolIds")
    def pool_ids(self) -> str:
        """
        The IDs of the KYVE storage pool you want to archive. (Comma separated)
        """
        return pulumi.get(self, "pool_ids")

    @property
    @pulumi.getter(name="startIds")
    def start_ids(self) -> str:
        """
        The start-id defines, from which bundle id the pipeline should start to extract the data. (Comma separated)
        """
        return pulumi.get(self, "start_ids")

    @property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[int]:
        """
        The maximum amount of pages to go trough. Set to 'null' for all pages.
        """
        return pulumi.get(self, "max_pages")

    @property
    @pulumi.getter(name="pageSize")
    def page_size(self) -> Optional[int]:
        """
        The pagesize for pagination, smaller numbers are used in integration tests. Default: 100
        """
        return pulumi.get(self, "page_size")

    @property
    @pulumi.getter(name="urlBase")
    def url_base(self) -> Optional[str]:
        """
        URL to the KYVE Chain API. Default: "https://api.kyve.network"
        """
        return pulumi.get(self, "url_base")


@pulumi.output_type
class SourceLaunchdarklyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLaunchdarklyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLaunchdarklyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLaunchdarklyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: Your Access token. See <a href="https://apidocs.launchdarkly.com/#section/Overview/Authentication">here</a>.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Your Access token. See <a href="https://apidocs.launchdarkly.com/#section/Overview/Authentication">here</a>.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceLemlistConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLemlistConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLemlistConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLemlistConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Lemlist API key,
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Lemlist API key,
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceLeverHiringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLeverHiringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLeverHiringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLeverHiringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 credentials: Optional['outputs.SourceLeverHiringConfigurationCredentials'] = None,
                 environment: Optional[str] = None):
        """
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
        :param 'SourceLeverHiringConfigurationCredentialsArgs' credentials: Choose how to authenticate to Lever Hiring.
        :param str environment: The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use. must be one of ["Production", "Sandbox"]; Default: "Sandbox"
        """
        pulumi.set(__self__, "start_date", start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceLeverHiringConfigurationCredentials']:
        """
        Choose how to authenticate to Lever Hiring.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use. must be one of ["Production", "Sandbox"]; Default: "Sandbox"
        """
        return pulumi.get(self, "environment")


@pulumi.output_type
class SourceLeverHiringConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaLeverApiKey":
            suggest = "authenticate_via_lever_api_key"
        elif key == "authenticateViaLeverOAuth":
            suggest = "authenticate_via_lever_o_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLeverHiringConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLeverHiringConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLeverHiringConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_lever_api_key: Optional['outputs.SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey'] = None,
                 authenticate_via_lever_o_auth: Optional['outputs.SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth'] = None):
        if authenticate_via_lever_api_key is not None:
            pulumi.set(__self__, "authenticate_via_lever_api_key", authenticate_via_lever_api_key)
        if authenticate_via_lever_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_lever_o_auth", authenticate_via_lever_o_auth)

    @property
    @pulumi.getter(name="authenticateViaLeverApiKey")
    def authenticate_via_lever_api_key(self) -> Optional['outputs.SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey']:
        return pulumi.get(self, "authenticate_via_lever_api_key")

    @property
    @pulumi.getter(name="authenticateViaLeverOAuth")
    def authenticate_via_lever_o_auth(self) -> Optional['outputs.SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth']:
        return pulumi.get(self, "authenticate_via_lever_o_auth")


@pulumi.output_type
class SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: The Api Key of your Lever Hiring account.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The Api Key of your Lever Hiring account.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshToken":
            suggest = "refresh_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 refresh_token: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str refresh_token: The token for obtaining new access token.
        :param str client_id: The Client ID of your Lever Hiring developer application.
        :param str client_secret: The Client Secret of your Lever Hiring developer application.
        """
        pulumi.set(__self__, "refresh_token", refresh_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token for obtaining new access token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of your Lever Hiring developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of your Lever Hiring developer application.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceLinkedinAdsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "accountIds":
            suggest = "account_ids"
        elif key == "adAnalyticsReports":
            suggest = "ad_analytics_reports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinAdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinAdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinAdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 account_ids: Optional[Sequence[int]] = None,
                 ad_analytics_reports: Optional[Sequence['outputs.SourceLinkedinAdsConfigurationAdAnalyticsReport']] = None,
                 credentials: Optional['outputs.SourceLinkedinAdsConfigurationCredentials'] = None):
        """
        :param str start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        :param Sequence[int] account_ids: Specify the account IDs to pull data from, separated by a space. Leave this field empty if you want to pull the data from all accounts accessible by the authenticated user. See the <a href="https://www.linkedin.com/help/linkedin/answer/a424270/find-linkedin-ads-account-details?lang=en">LinkedIn docs</a> to locate these IDs.
        """
        pulumi.set(__self__, "start_date", start_date)
        if account_ids is not None:
            pulumi.set(__self__, "account_ids", account_ids)
        if ad_analytics_reports is not None:
            pulumi.set(__self__, "ad_analytics_reports", ad_analytics_reports)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="accountIds")
    def account_ids(self) -> Optional[Sequence[int]]:
        """
        Specify the account IDs to pull data from, separated by a space. Leave this field empty if you want to pull the data from all accounts accessible by the authenticated user. See the <a href="https://www.linkedin.com/help/linkedin/answer/a424270/find-linkedin-ads-account-details?lang=en">LinkedIn docs</a> to locate these IDs.
        """
        return pulumi.get(self, "account_ids")

    @property
    @pulumi.getter(name="adAnalyticsReports")
    def ad_analytics_reports(self) -> Optional[Sequence['outputs.SourceLinkedinAdsConfigurationAdAnalyticsReport']]:
        return pulumi.get(self, "ad_analytics_reports")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceLinkedinAdsConfigurationCredentials']:
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceLinkedinAdsConfigurationAdAnalyticsReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pivotBy":
            suggest = "pivot_by"
        elif key == "timeGranularity":
            suggest = "time_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinAdsConfigurationAdAnalyticsReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinAdsConfigurationAdAnalyticsReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinAdsConfigurationAdAnalyticsReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 pivot_by: str,
                 time_granularity: str):
        """
        :param str name: The name for the custom report.
        :param str pivot_by: Choose a category to pivot your analytics report around. This selection will organize your data based on the chosen attribute, allowing you to analyze trends and performance from different perspectives. must be one of ["COMPANY", "ACCOUNT", "SHARE", "CAMPAIGN", "CREATIVE", "CAMPAIGN_GROUP", "CONVERSION", "CONVERSATION_NODE", "CONVERSATION_NODE_OPTION_INDEX", "SERVING_LOCATION", "CARD_INDEX", "MEMBER_COMPANY_SIZE", "MEMBER_INDUSTRY", "MEMBER_SENIORITY", "MEMBER_JOB_TITLE", "MEMBER_JOB_FUNCTION", "MEMBER_COUNTRY_V2", "MEMBER_REGION_V2", "MEMBER_COMPANY", "PLACEMENT_NAME", "IMPRESSION_DEVICE_TYPE"]
        :param str time_granularity: Choose how to group the data in your report by time. The options are:<br>- 'ALL': A single result summarizing the entire time range.<br>- 'DAILY': Group results by each day.<br>- 'MONTHLY': Group results by each month.<br>- 'YEARLY': Group results by each year.<br>Selecting a time grouping helps you analyze trends and patterns over different time periods. must be one of ["ALL", "DAILY", "MONTHLY", "YEARLY"]
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pivot_by", pivot_by)
        pulumi.set(__self__, "time_granularity", time_granularity)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the custom report.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pivotBy")
    def pivot_by(self) -> str:
        """
        Choose a category to pivot your analytics report around. This selection will organize your data based on the chosen attribute, allowing you to analyze trends and performance from different perspectives. must be one of ["COMPANY", "ACCOUNT", "SHARE", "CAMPAIGN", "CREATIVE", "CAMPAIGN_GROUP", "CONVERSION", "CONVERSATION_NODE", "CONVERSATION_NODE_OPTION_INDEX", "SERVING_LOCATION", "CARD_INDEX", "MEMBER_COMPANY_SIZE", "MEMBER_INDUSTRY", "MEMBER_SENIORITY", "MEMBER_JOB_TITLE", "MEMBER_JOB_FUNCTION", "MEMBER_COUNTRY_V2", "MEMBER_REGION_V2", "MEMBER_COMPANY", "PLACEMENT_NAME", "IMPRESSION_DEVICE_TYPE"]
        """
        return pulumi.get(self, "pivot_by")

    @property
    @pulumi.getter(name="timeGranularity")
    def time_granularity(self) -> str:
        """
        Choose how to group the data in your report by time. The options are:<br>- 'ALL': A single result summarizing the entire time range.<br>- 'DAILY': Group results by each day.<br>- 'MONTHLY': Group results by each month.<br>- 'YEARLY': Group results by each year.<br>Selecting a time grouping helps you analyze trends and patterns over different time periods. must be one of ["ALL", "DAILY", "MONTHLY", "YEARLY"]
        """
        return pulumi.get(self, "time_granularity")


@pulumi.output_type
class SourceLinkedinAdsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinAdsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinAdsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinAdsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional['outputs.SourceLinkedinAdsConfigurationCredentialsAccessToken'] = None,
                 o_auth20: Optional['outputs.SourceLinkedinAdsConfigurationCredentialsOAuth20'] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.SourceLinkedinAdsConfigurationCredentialsAccessToken']:
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceLinkedinAdsConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceLinkedinAdsConfigurationCredentialsAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinAdsConfigurationCredentialsAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinAdsConfigurationCredentialsAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinAdsConfigurationCredentialsAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: The access token generated for your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The access token generated for your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceLinkedinAdsConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinAdsConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinAdsConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinAdsConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The client ID of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        :param str client_secret: The client secret of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        :param str refresh_token: The key to refresh the expired access token. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The key to refresh the expired access token. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceLinkedinPagesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinPagesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinPagesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinPagesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 org_id: str,
                 credentials: Optional['outputs.SourceLinkedinPagesConfigurationCredentials'] = None):
        """
        :param str org_id: Specify the Organization ID
        """
        pulumi.set(__self__, "org_id", org_id)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Specify the Organization ID
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceLinkedinPagesConfigurationCredentials']:
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceLinkedinPagesConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinPagesConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinPagesConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinPagesConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional['outputs.SourceLinkedinPagesConfigurationCredentialsAccessToken'] = None,
                 o_auth20: Optional['outputs.SourceLinkedinPagesConfigurationCredentialsOAuth20'] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.SourceLinkedinPagesConfigurationCredentialsAccessToken']:
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceLinkedinPagesConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceLinkedinPagesConfigurationCredentialsAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinPagesConfigurationCredentialsAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinPagesConfigurationCredentialsAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinPagesConfigurationCredentialsAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceLinkedinPagesConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinkedinPagesConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinkedinPagesConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinkedinPagesConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The client ID of the LinkedIn developer application.
        :param str client_secret: The client secret of the LinkedIn developer application.
        :param str refresh_token: The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID of the LinkedIn developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret of the LinkedIn developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceLinnworksConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "applicationSecret":
            suggest = "application_secret"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLinnworksConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLinnworksConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLinnworksConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: str,
                 application_secret: str,
                 start_date: str,
                 token: str):
        """
        :param str application_id: Linnworks Application ID
        :param str application_secret: Linnworks Application Secret
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "application_secret", application_secret)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        Linnworks Application ID
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationSecret")
    def application_secret(self) -> str:
        """
        Linnworks Application Secret
        """
        return pulumi.get(self, "application_secret")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def token(self) -> str:
        return pulumi.get(self, "token")


@pulumi.output_type
class SourceLokaliseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLokaliseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLokaliseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLokaliseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 project_id: str):
        """
        :param str api_key: Lokalise API Key with read-access. Available at Profile settings > API tokens. See <a href="https://docs.lokalise.com/en/articles/1929556-api-tokens">here</a>.
        :param str project_id: Lokalise project ID. Available at Project Settings > General.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Lokalise API Key with read-access. Available at Profile settings > API tokens. See <a href="https://docs.lokalise.com/en/articles/1929556-api-tokens">here</a>.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Lokalise project ID. Available at Project Settings > General.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class SourceMailchimpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataCenter":
            suggest = "data_center"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMailchimpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMailchimpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMailchimpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceMailchimpConfigurationCredentials'] = None,
                 data_center: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str data_center: Technical fields used to identify datacenter to send request to
        :param str start_date: The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if data_center is not None:
            pulumi.set(__self__, "data_center", data_center)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceMailchimpConfigurationCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="dataCenter")
    def data_center(self) -> Optional[str]:
        """
        Technical fields used to identify datacenter to send request to
        """
        return pulumi.get(self, "data_center")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMailchimpConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMailchimpConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMailchimpConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMailchimpConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.SourceMailchimpConfigurationCredentialsApiKey'] = None,
                 o_auth20: Optional['outputs.SourceMailchimpConfigurationCredentialsOAuth20'] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.SourceMailchimpConfigurationCredentialsApiKey']:
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceMailchimpConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceMailchimpConfigurationCredentialsApiKey(dict):
    def __init__(__self__, *,
                 apikey: str):
        """
        :param str apikey: Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
        """
        pulumi.set(__self__, "apikey", apikey)

    @property
    @pulumi.getter
    def apikey(self) -> str:
        """
        Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "apikey")


@pulumi.output_type
class SourceMailchimpConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMailchimpConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMailchimpConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMailchimpConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: An access token generated using the above client ID and secret.
        :param str client_id: The Client ID of your OAuth application.
        :param str client_secret: The Client Secret of your OAuth application.
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        An access token generated using the above client ID and secret.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceMailgunConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "domainRegion":
            suggest = "domain_region"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMailgunConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMailgunConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMailgunConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key: str,
                 domain_region: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str private_key: Primary account API key to access your Mailgun data.
        :param str domain_region: Domain region code. 'EU' or 'US' are possible values. The default is 'US'. Default: "US"
        :param str start_date: UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
        """
        pulumi.set(__self__, "private_key", private_key)
        if domain_region is not None:
            pulumi.set(__self__, "domain_region", domain_region)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        Primary account API key to access your Mailgun data.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="domainRegion")
    def domain_region(self) -> Optional[str]:
        """
        Domain region code. 'EU' or 'US' are possible values. The default is 'US'. Default: "US"
        """
        return pulumi.get(self, "domain_region")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMailjetSmsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMailjetSmsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMailjetSmsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMailjetSmsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token: str,
                 end_date: Optional[int] = None,
                 start_date: Optional[int] = None):
        """
        :param str token: Your access token. See <a href="https://dev.mailjet.com/sms/reference/overview/authentication">here</a>.
        :param int end_date: Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
        :param int start_date: Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
        """
        pulumi.set(__self__, "token", token)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Your access token. See <a href="https://dev.mailjet.com/sms/reference/overview/authentication">here</a>.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[int]:
        """
        Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[int]:
        """
        Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMarketoConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "domainUrl":
            suggest = "domain_url"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMarketoConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMarketoConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMarketoConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 domain_url: str,
                 start_date: str):
        """
        :param str client_id: The Client ID of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        :param str client_secret: The Client Secret of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        :param str domain_url: Your Marketo Base URL. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "domain_url", domain_url)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="domainUrl")
    def domain_url(self) -> str:
        """
        Your Marketo Base URL. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "domain_url")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMetabaseConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceApiUrl":
            suggest = "instance_api_url"
        elif key == "sessionToken":
            suggest = "session_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMetabaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMetabaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMetabaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_api_url: str,
                 password: Optional[str] = None,
                 session_token: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str instance_api_url: URL to your metabase instance API
        :param str session_token: To generate your session token, you need to run the following command: ``` curl -X POST \\
                 -H "Content-Type: application/json" \\
                 -d '{"username": "person@metabase.com", "password": "fakepassword"}' \\
                 http://localhost:3000/api/session
               ``` Then copy the value of the `id` field returned by a successful call to that API.
               Note that by default, sessions are good for 14 days and needs to be regenerated.
        """
        pulumi.set(__self__, "instance_api_url", instance_api_url)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="instanceApiUrl")
    def instance_api_url(self) -> str:
        """
        URL to your metabase instance API
        """
        return pulumi.get(self, "instance_api_url")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        To generate your session token, you need to run the following command: ``` curl -X POST \\
          -H "Content-Type: application/json" \\
          -d '{"username": "person@metabase.com", "password": "fakepassword"}' \\
          http://localhost:3000/api/session
        ``` Then copy the value of the `id` field returned by a successful call to that API.
        Note that by default, sessions are good for 14 days and needs to be regenerated.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class SourceMicrosoftOnedriveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "driveName":
            suggest = "drive_name"
        elif key == "folderPath":
            suggest = "folder_path"
        elif key == "searchScope":
            suggest = "search_scope"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceMicrosoftOnedriveConfigurationCredentials',
                 streams: Sequence['outputs.SourceMicrosoftOnedriveConfigurationStream'],
                 drive_name: Optional[str] = None,
                 folder_path: Optional[str] = None,
                 search_scope: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceMicrosoftOnedriveConfigurationCredentialsArgs' credentials: Credentials for connecting to the One Drive API
        :param Sequence['SourceMicrosoftOnedriveConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str drive_name: Name of the Microsoft OneDrive drive where the file(s) exist. Default: "OneDrive"
        :param str folder_path: Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        :param str search_scope: Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "streams", streams)
        if drive_name is not None:
            pulumi.set(__self__, "drive_name", drive_name)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if search_scope is not None:
            pulumi.set(__self__, "search_scope", search_scope)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceMicrosoftOnedriveConfigurationCredentials':
        """
        Credentials for connecting to the One Drive API
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceMicrosoftOnedriveConfigurationStream']:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="driveName")
    def drive_name(self) -> Optional[str]:
        """
        Name of the Microsoft OneDrive drive where the file(s) exist. Default: "OneDrive"
        """
        return pulumi.get(self, "drive_name")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[str]:
        """
        Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter(name="searchScope")
    def search_scope(self) -> Optional[str]:
        """
        Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        """
        return pulumi.get(self, "search_scope")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaMicrosoftOAuth":
            suggest = "authenticate_via_microsoft_o_auth"
        elif key == "serviceKeyAuthentication":
            suggest = "service_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_microsoft_o_auth: Optional['outputs.SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth'] = None,
                 service_key_authentication: Optional['outputs.SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication'] = None):
        """
        :param 'SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs' authenticate_via_microsoft_o_auth: OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
               This class uses pydantic for data validation and settings management.
        :param 'SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthenticationArgs' service_key_authentication: ServiceCredentials class for service key authentication.
               This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        if authenticate_via_microsoft_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_microsoft_o_auth", authenticate_via_microsoft_o_auth)
        if service_key_authentication is not None:
            pulumi.set(__self__, "service_key_authentication", service_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaMicrosoftOAuth")
    def authenticate_via_microsoft_o_auth(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth']:
        """
        OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
        This class uses pydantic for data validation and settings management.
        """
        return pulumi.get(self, "authenticate_via_microsoft_o_auth")

    @property
    @pulumi.getter(name="serviceKeyAuthentication")
    def service_key_authentication(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication']:
        """
        ServiceCredentials class for service key authentication.
        This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        return pulumi.get(self, "service_key_authentication")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 tenant_id: str):
        """
        :param str client_id: Client ID of your Microsoft developer application
        :param str client_secret: Client Secret of your Microsoft developer application
        :param str refresh_token: Refresh Token of your Microsoft developer application
        :param str tenant_id: Tenant ID of the Microsoft OneDrive user
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token of your Microsoft developer application
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID of the Microsoft OneDrive user
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 tenant_id: str,
                 user_principal_name: str):
        """
        :param str client_id: Client ID of your Microsoft developer application
        :param str client_secret: Client Secret of your Microsoft developer application
        :param str tenant_id: Tenant ID of the Microsoft OneDrive user
        :param str user_principal_name: Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID of the Microsoft OneDrive user
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> str:
        """
        Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceMicrosoftOnedriveConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceMicrosoftOnedriveConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceMicrosoftOnedriveConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFormat":
            suggest = "avro_format"
        elif key == "csvFormat":
            suggest = "csv_format"
        elif key == "documentFileTypeFormatExperimental":
            suggest = "document_file_type_format_experimental"
        elif key == "jsonlFormat":
            suggest = "jsonl_format"
        elif key == "parquetFormat":
            suggest = "parquet_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_format: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat'] = None,
                 csv_format: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat'] = None,
                 document_file_type_format_experimental: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental'] = None,
                 jsonl_format: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormat'] = None,
                 parquet_format: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat'] = None):
        """
        :param 'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs' document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat']:
        return pulumi.get(self, "avro_format")

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental']:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormat']:
        return pulumi.get(self, "jsonl_format")

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat']:
        return pulumi.get(self, "parquet_format")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleAsString":
            suggest = "double_as_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_as_string: Optional[bool] = None):
        """
        :param bool double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[bool]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnprocessableFiles":
            suggest = "skip_unprocessable_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processing: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing'] = None,
                 skip_unprocessable_files: Optional[bool] = None,
                 strategy: Optional[str] = None):
        """
        :param 'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs' processing: Processing configuration
        :param bool skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param str strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing']:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[bool]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing(dict):
    def __init__(__self__, *,
                 local: Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal'] = None):
        """
        :param 'SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs' local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal']:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalAsFloat":
            suggest = "decimal_as_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_as_float: Optional[bool] = None):
        """
        :param bool decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[bool]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")


@pulumi.output_type
class SourceMicrosoftSharepointConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderPath":
            suggest = "folder_path"
        elif key == "searchScope":
            suggest = "search_scope"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceMicrosoftSharepointConfigurationCredentials',
                 streams: Sequence['outputs.SourceMicrosoftSharepointConfigurationStream'],
                 folder_path: Optional[str] = None,
                 search_scope: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceMicrosoftSharepointConfigurationCredentialsArgs' credentials: Credentials for connecting to the One Drive API
        :param Sequence['SourceMicrosoftSharepointConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str folder_path: Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        :param str search_scope: Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' for all SharePoint drives the user can access, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "streams", streams)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if search_scope is not None:
            pulumi.set(__self__, "search_scope", search_scope)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceMicrosoftSharepointConfigurationCredentials':
        """
        Credentials for connecting to the One Drive API
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceMicrosoftSharepointConfigurationStream']:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[str]:
        """
        Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter(name="searchScope")
    def search_scope(self) -> Optional[str]:
        """
        Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' for all SharePoint drives the user can access, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]; Default: "ALL"
        """
        return pulumi.get(self, "search_scope")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaMicrosoftOAuth":
            suggest = "authenticate_via_microsoft_o_auth"
        elif key == "serviceKeyAuthentication":
            suggest = "service_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_microsoft_o_auth: Optional['outputs.SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth'] = None,
                 service_key_authentication: Optional['outputs.SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication'] = None):
        """
        :param 'SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuthArgs' authenticate_via_microsoft_o_auth: OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
               This class uses pydantic for data validation and settings management.
        :param 'SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthenticationArgs' service_key_authentication: ServiceCredentials class for service key authentication.
               This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        if authenticate_via_microsoft_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_microsoft_o_auth", authenticate_via_microsoft_o_auth)
        if service_key_authentication is not None:
            pulumi.set(__self__, "service_key_authentication", service_key_authentication)

    @property
    @pulumi.getter(name="authenticateViaMicrosoftOAuth")
    def authenticate_via_microsoft_o_auth(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth']:
        """
        OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
        This class uses pydantic for data validation and settings management.
        """
        return pulumi.get(self, "authenticate_via_microsoft_o_auth")

    @property
    @pulumi.getter(name="serviceKeyAuthentication")
    def service_key_authentication(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication']:
        """
        ServiceCredentials class for service key authentication.
        This class is structured similarly to OAuthCredentials but for a different authentication method.
        """
        return pulumi.get(self, "service_key_authentication")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 tenant_id: str,
                 refresh_token: Optional[str] = None):
        """
        :param str client_id: Client ID of your Microsoft developer application
        :param str client_secret: Client Secret of your Microsoft developer application
        :param str tenant_id: Tenant ID of the Microsoft SharePoint user
        :param str refresh_token: Refresh Token of your Microsoft developer application
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID of the Microsoft SharePoint user
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        Refresh Token of your Microsoft developer application
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "userPrincipalName":
            suggest = "user_principal_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 tenant_id: str,
                 user_principal_name: str):
        """
        :param str client_id: Client ID of your Microsoft developer application
        :param str client_secret: Client Secret of your Microsoft developer application
        :param str tenant_id: Tenant ID of the Microsoft SharePoint user
        :param str user_principal_name: Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID of your Microsoft developer application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Client Secret of your Microsoft developer application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Tenant ID of the Microsoft SharePoint user
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> str:
        """
        Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
        """
        return pulumi.get(self, "user_principal_name")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceMicrosoftSharepointConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceMicrosoftSharepointConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceMicrosoftSharepointConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFormat":
            suggest = "avro_format"
        elif key == "csvFormat":
            suggest = "csv_format"
        elif key == "documentFileTypeFormatExperimental":
            suggest = "document_file_type_format_experimental"
        elif key == "jsonlFormat":
            suggest = "jsonl_format"
        elif key == "parquetFormat":
            suggest = "parquet_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_format: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat'] = None,
                 csv_format: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat'] = None,
                 document_file_type_format_experimental: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental'] = None,
                 jsonl_format: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormat'] = None,
                 parquet_format: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat'] = None):
        """
        :param 'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs' document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat']:
        return pulumi.get(self, "avro_format")

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental']:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormat']:
        return pulumi.get(self, "jsonl_format")

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat']:
        return pulumi.get(self, "parquet_format")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleAsString":
            suggest = "double_as_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_as_string: Optional[bool] = None):
        """
        :param bool double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[bool]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "ignoreErrorsOnFieldsMismatch":
            suggest = "ignore_errors_on_fields_mismatch"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 ignore_errors_on_fields_mismatch: Optional[bool] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param bool ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[bool]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnprocessableFiles":
            suggest = "skip_unprocessable_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processing: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing'] = None,
                 skip_unprocessable_files: Optional[bool] = None,
                 strategy: Optional[str] = None):
        """
        :param 'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs' processing: Processing configuration
        :param bool skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param str strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing']:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[bool]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing(dict):
    def __init__(__self__, *,
                 local: Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal'] = None):
        """
        :param 'SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs' local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal']:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalAsFloat":
            suggest = "decimal_as_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_as_float: Optional[bool] = None):
        """
        :param bool decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[bool]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")


@pulumi.output_type
class SourceMicrosoftTeamsConfiguration(dict):
    def __init__(__self__, *,
                 period: str,
                 credentials: Optional['outputs.SourceMicrosoftTeamsConfigurationCredentials'] = None):
        """
        :param str period: Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
        :param 'SourceMicrosoftTeamsConfigurationCredentialsArgs' credentials: Choose how to authenticate to Microsoft
        """
        pulumi.set(__self__, "period", period)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def period(self) -> str:
        """
        Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceMicrosoftTeamsConfigurationCredentials']:
        """
        Choose how to authenticate to Microsoft
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceMicrosoftTeamsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaMicrosoft":
            suggest = "authenticate_via_microsoft"
        elif key == "authenticateViaMicrosoftOAuth20":
            suggest = "authenticate_via_microsoft_o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftTeamsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftTeamsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftTeamsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_microsoft: Optional['outputs.SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft'] = None,
                 authenticate_via_microsoft_o_auth20: Optional['outputs.SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20'] = None):
        if authenticate_via_microsoft is not None:
            pulumi.set(__self__, "authenticate_via_microsoft", authenticate_via_microsoft)
        if authenticate_via_microsoft_o_auth20 is not None:
            pulumi.set(__self__, "authenticate_via_microsoft_o_auth20", authenticate_via_microsoft_o_auth20)

    @property
    @pulumi.getter(name="authenticateViaMicrosoft")
    def authenticate_via_microsoft(self) -> Optional['outputs.SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft']:
        return pulumi.get(self, "authenticate_via_microsoft")

    @property
    @pulumi.getter(name="authenticateViaMicrosoftOAuth20")
    def authenticate_via_microsoft_o_auth20(self) -> Optional['outputs.SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20']:
        return pulumi.get(self, "authenticate_via_microsoft_o_auth20")


@pulumi.output_type
class SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 tenant_id: str):
        """
        :param str client_id: The Client ID of your Microsoft Teams developer application.
        :param str client_secret: The Client Secret of your Microsoft Teams developer application.
        :param str tenant_id: A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the … next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the … next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 tenant_id: str):
        """
        :param str client_id: The Client ID of your Microsoft Teams developer application.
        :param str client_secret: The Client Secret of your Microsoft Teams developer application.
        :param str refresh_token: A Refresh Token to renew the expired Access Token.
        :param str tenant_id: A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the … next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Microsoft Teams developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        A Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the … next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class SourceMixpanelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributionWindow":
            suggest = "attribution_window"
        elif key == "dateWindowSize":
            suggest = "date_window_size"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "projectTimezone":
            suggest = "project_timezone"
        elif key == "selectPropertiesByDefault":
            suggest = "select_properties_by_default"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMixpanelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMixpanelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMixpanelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceMixpanelConfigurationCredentials',
                 attribution_window: Optional[int] = None,
                 date_window_size: Optional[int] = None,
                 end_date: Optional[str] = None,
                 project_timezone: Optional[str] = None,
                 region: Optional[str] = None,
                 select_properties_by_default: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceMixpanelConfigurationCredentialsArgs' credentials: Choose how to authenticate to Mixpanel
        :param int attribution_window: A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days. (This value should be non-negative integer). Default: 5
        :param int date_window_size: Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment. (This value should be positive integer). Default: 30
        :param str end_date: The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
        :param str project_timezone: Time zone in which integer date times are stored. The project timezone may be found in the project settings in the <a href="https://help.mixpanel.com/hc/en-us/articles/115004547203-Manage-Timezones-for-Projects-in-Mixpanel">Mixpanel console</a>. Default: "US/Pacific"
        :param str region: The region of mixpanel domain instance either US or EU. must be one of ["US", "EU"]; Default: "US"
        :param bool select_properties_by_default: Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored. Default: true
        :param str start_date: The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
        """
        pulumi.set(__self__, "credentials", credentials)
        if attribution_window is not None:
            pulumi.set(__self__, "attribution_window", attribution_window)
        if date_window_size is not None:
            pulumi.set(__self__, "date_window_size", date_window_size)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if project_timezone is not None:
            pulumi.set(__self__, "project_timezone", project_timezone)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if select_properties_by_default is not None:
            pulumi.set(__self__, "select_properties_by_default", select_properties_by_default)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceMixpanelConfigurationCredentials':
        """
        Choose how to authenticate to Mixpanel
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="attributionWindow")
    def attribution_window(self) -> Optional[int]:
        """
        A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days. (This value should be non-negative integer). Default: 5
        """
        return pulumi.get(self, "attribution_window")

    @property
    @pulumi.getter(name="dateWindowSize")
    def date_window_size(self) -> Optional[int]:
        """
        Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment. (This value should be positive integer). Default: 30
        """
        return pulumi.get(self, "date_window_size")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="projectTimezone")
    def project_timezone(self) -> Optional[str]:
        """
        Time zone in which integer date times are stored. The project timezone may be found in the project settings in the <a href="https://help.mixpanel.com/hc/en-us/articles/115004547203-Manage-Timezones-for-Projects-in-Mixpanel">Mixpanel console</a>. Default: "US/Pacific"
        """
        return pulumi.get(self, "project_timezone")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The region of mixpanel domain instance either US or EU. must be one of ["US", "EU"]; Default: "US"
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="selectPropertiesByDefault")
    def select_properties_by_default(self) -> Optional[bool]:
        """
        Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored. Default: true
        """
        return pulumi.get(self, "select_properties_by_default")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceMixpanelConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectSecret":
            suggest = "project_secret"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMixpanelConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMixpanelConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMixpanelConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_secret: Optional['outputs.SourceMixpanelConfigurationCredentialsProjectSecret'] = None,
                 service_account: Optional['outputs.SourceMixpanelConfigurationCredentialsServiceAccount'] = None):
        if project_secret is not None:
            pulumi.set(__self__, "project_secret", project_secret)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @property
    @pulumi.getter(name="projectSecret")
    def project_secret(self) -> Optional['outputs.SourceMixpanelConfigurationCredentialsProjectSecret']:
        return pulumi.get(self, "project_secret")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional['outputs.SourceMixpanelConfigurationCredentialsServiceAccount']:
        return pulumi.get(self, "service_account")


@pulumi.output_type
class SourceMixpanelConfigurationCredentialsProjectSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiSecret":
            suggest = "api_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMixpanelConfigurationCredentialsProjectSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMixpanelConfigurationCredentialsProjectSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMixpanelConfigurationCredentialsProjectSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_secret: str):
        """
        :param str api_secret: Mixpanel project secret. See the <a href="https://developer.mixpanel.com/reference/project-secret#managing-a-projects-secret">docs</a> for more information on how to obtain this.
        """
        pulumi.set(__self__, "api_secret", api_secret)

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> str:
        """
        Mixpanel project secret. See the <a href="https://developer.mixpanel.com/reference/project-secret#managing-a-projects-secret">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "api_secret")


@pulumi.output_type
class SourceMixpanelConfigurationCredentialsServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMixpanelConfigurationCredentialsServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMixpanelConfigurationCredentialsServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMixpanelConfigurationCredentialsServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: int,
                 secret: str,
                 username: str):
        """
        :param int project_id: Your project ID number. See the <a href="https://help.mixpanel.com/hc/en-us/articles/115004490503-Project-Settings#project-id">docs</a> for more information on how to obtain this.
        :param str secret: Mixpanel Service Account Secret. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        :param str username: Mixpanel Service Account Username. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> int:
        """
        Your project ID number. See the <a href="https://help.mixpanel.com/hc/en-us/articles/115004490503-Project-Settings#project-id">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        Mixpanel Service Account Secret. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Mixpanel Service Account Username. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SourceMondayConfiguration(dict):
    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceMondayConfigurationCredentials'] = None):
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceMondayConfigurationCredentials']:
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceMondayConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMondayConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMondayConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMondayConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.SourceMondayConfigurationCredentialsApiToken'] = None,
                 o_auth20: Optional['outputs.SourceMondayConfigurationCredentialsOAuth20'] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.SourceMondayConfigurationCredentialsApiToken']:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceMondayConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceMondayConfigurationCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMondayConfigurationCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMondayConfigurationCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMondayConfigurationCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: API Token for making authenticated requests.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        API Token for making authenticated requests.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class SourceMondayConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMondayConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMondayConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMondayConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str,
                 subdomain: Optional[str] = None):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The Client ID of your OAuth application.
        :param str client_secret: The Client Secret of your OAuth application.
        :param str subdomain: Slug/subdomain of the account, or the first part of the URL that comes before .monday.com. Default: ""
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Slug/subdomain of the account, or the first part of the URL that comes before .monday.com. Default: ""
        """
        return pulumi.get(self, "subdomain")


@pulumi.output_type
class SourceMongodbInternalPocConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSource":
            suggest = "auth_source"
        elif key == "connectionString":
            suggest = "connection_string"
        elif key == "replicaSet":
            suggest = "replica_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMongodbInternalPocConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMongodbInternalPocConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMongodbInternalPocConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_source: Optional[str] = None,
                 connection_string: Optional[str] = None,
                 password: Optional[str] = None,
                 replica_set: Optional[str] = None,
                 user: Optional[str] = None):
        """
        :param str auth_source: The authentication source where the user information is stored. Default: "admin"
        :param str connection_string: The connection string of the database that you want to replicate..
        :param str password: The password associated with this username.
        :param str replica_set: The name of the replica set to be replicated.
        :param str user: The username which is used to access the database.
        """
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[str]:
        """
        The authentication source where the user information is stored. Default: "admin"
        """
        return pulumi.get(self, "auth_source")

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        """
        The connection string of the database that you want to replicate..
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[str]:
        """
        The name of the replica set to be replicated.
        """
        return pulumi.get(self, "replica_set")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class SourceMongodbV2Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseConfig":
            suggest = "database_config"
        elif key == "discoverSampleSize":
            suggest = "discover_sample_size"
        elif key == "initialWaitingSeconds":
            suggest = "initial_waiting_seconds"
        elif key == "invalidCdcCursorPositionBehavior":
            suggest = "invalid_cdc_cursor_position_behavior"
        elif key == "queueSize":
            suggest = "queue_size"
        elif key == "updateCaptureMode":
            suggest = "update_capture_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMongodbV2Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMongodbV2Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMongodbV2Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_config: 'outputs.SourceMongodbV2ConfigurationDatabaseConfig',
                 discover_sample_size: Optional[int] = None,
                 initial_waiting_seconds: Optional[int] = None,
                 invalid_cdc_cursor_position_behavior: Optional[str] = None,
                 queue_size: Optional[int] = None,
                 update_capture_mode: Optional[str] = None):
        """
        :param 'SourceMongodbV2ConfigurationDatabaseConfigArgs' database_config: Configures the MongoDB cluster type.
        :param int discover_sample_size: The maximum number of documents to sample when attempting to discover the unique fields for a collection. Default: 10000
        :param int initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Default: 300
        :param str invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param int queue_size: The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        :param str update_capture_mode: Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images. must be one of ["Lookup", "Post Image"]; Default: "Lookup"
        """
        pulumi.set(__self__, "database_config", database_config)
        if discover_sample_size is not None:
            pulumi.set(__self__, "discover_sample_size", discover_sample_size)
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)
        if update_capture_mode is not None:
            pulumi.set(__self__, "update_capture_mode", update_capture_mode)

    @property
    @pulumi.getter(name="databaseConfig")
    def database_config(self) -> 'outputs.SourceMongodbV2ConfigurationDatabaseConfig':
        """
        Configures the MongoDB cluster type.
        """
        return pulumi.get(self, "database_config")

    @property
    @pulumi.getter(name="discoverSampleSize")
    def discover_sample_size(self) -> Optional[int]:
        """
        The maximum number of documents to sample when attempting to discover the unique fields for a collection. Default: 10000
        """
        return pulumi.get(self, "discover_sample_size")

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[int]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Default: 300
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[str]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[int]:
        """
        The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        return pulumi.get(self, "queue_size")

    @property
    @pulumi.getter(name="updateCaptureMode")
    def update_capture_mode(self) -> Optional[str]:
        """
        Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images. must be one of ["Lookup", "Post Image"]; Default: "Lookup"
        """
        return pulumi.get(self, "update_capture_mode")


@pulumi.output_type
class SourceMongodbV2ConfigurationDatabaseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mongoDbAtlasReplicaSet":
            suggest = "mongo_db_atlas_replica_set"
        elif key == "selfManagedReplicaSet":
            suggest = "self_managed_replica_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMongodbV2ConfigurationDatabaseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMongodbV2ConfigurationDatabaseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMongodbV2ConfigurationDatabaseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mongo_db_atlas_replica_set: Optional['outputs.SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet'] = None,
                 self_managed_replica_set: Optional['outputs.SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet'] = None):
        """
        :param 'SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSetArgs' mongo_db_atlas_replica_set: MongoDB Atlas-hosted cluster configured as a replica set
        :param 'SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSetArgs' self_managed_replica_set: MongoDB self-hosted cluster configured as a replica set
        """
        if mongo_db_atlas_replica_set is not None:
            pulumi.set(__self__, "mongo_db_atlas_replica_set", mongo_db_atlas_replica_set)
        if self_managed_replica_set is not None:
            pulumi.set(__self__, "self_managed_replica_set", self_managed_replica_set)

    @property
    @pulumi.getter(name="mongoDbAtlasReplicaSet")
    def mongo_db_atlas_replica_set(self) -> Optional['outputs.SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet']:
        """
        MongoDB Atlas-hosted cluster configured as a replica set
        """
        return pulumi.get(self, "mongo_db_atlas_replica_set")

    @property
    @pulumi.getter(name="selfManagedReplicaSet")
    def self_managed_replica_set(self) -> Optional['outputs.SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet']:
        """
        MongoDB self-hosted cluster configured as a replica set
        """
        return pulumi.get(self, "self_managed_replica_set")


@pulumi.output_type
class SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "authSource":
            suggest = "auth_source"
        elif key == "schemaEnforced":
            suggest = "schema_enforced"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: str,
                 database: str,
                 password: str,
                 username: str,
                 additional_properties: Optional[str] = None,
                 auth_source: Optional[str] = None,
                 schema_enforced: Optional[bool] = None):
        """
        :param str connection_string: The connection string of the cluster that you want to replicate.
        :param str database: The name of the MongoDB database that contains the collection(s) to replicate.
        :param str password: The password associated with this username.
        :param str username: The username which is used to access the database.
        :param str additional_properties: Parsed as JSON.
        :param str auth_source: The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details. Default: "admin"
        :param bool schema_enforced: When enabled, syncs will validate and structure records against the stream's schema. Default: true
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if schema_enforced is not None:
            pulumi.set(__self__, "schema_enforced", schema_enforced)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        The connection string of the cluster that you want to replicate.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the MongoDB database that contains the collection(s) to replicate.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[str]:
        """
        The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details. Default: "admin"
        """
        return pulumi.get(self, "auth_source")

    @property
    @pulumi.getter(name="schemaEnforced")
    def schema_enforced(self) -> Optional[bool]:
        """
        When enabled, syncs will validate and structure records against the stream's schema. Default: true
        """
        return pulumi.get(self, "schema_enforced")


@pulumi.output_type
class SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "authSource":
            suggest = "auth_source"
        elif key == "schemaEnforced":
            suggest = "schema_enforced"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: str,
                 database: str,
                 additional_properties: Optional[str] = None,
                 auth_source: Optional[str] = None,
                 password: Optional[str] = None,
                 schema_enforced: Optional[bool] = None,
                 username: Optional[str] = None):
        """
        :param str connection_string: The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
        :param str database: The name of the MongoDB database that contains the collection(s) to replicate.
        :param str additional_properties: Parsed as JSON.
        :param str auth_source: The authentication source where the user information is stored. Default: "admin"
        :param str password: The password associated with this username.
        :param bool schema_enforced: When enabled, syncs will validate and structure records against the stream's schema. Default: true
        :param str username: The username which is used to access the database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "database", database)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if auth_source is not None:
            pulumi.set(__self__, "auth_source", auth_source)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if schema_enforced is not None:
            pulumi.set(__self__, "schema_enforced", schema_enforced)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        """
        The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
        """
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the MongoDB database that contains the collection(s) to replicate.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="authSource")
    def auth_source(self) -> Optional[str]:
        """
        The authentication source where the user information is stored. Default: "admin"
        """
        return pulumi.get(self, "auth_source")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with this username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="schemaEnforced")
    def schema_enforced(self) -> Optional[bool]:
        """
        When enabled, syncs will validate and structure records against the stream's schema. Default: true
        """
        return pulumi.get(self, "schema_enforced")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SourceMssqlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "replicationMethod":
            suggest = "replication_method"
        elif key == "sslMethod":
            suggest = "ssl_method"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 password: str,
                 port: int,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 replication_method: Optional['outputs.SourceMssqlConfigurationReplicationMethod'] = None,
                 schemas: Optional[Sequence[str]] = None,
                 ssl_method: Optional['outputs.SourceMssqlConfigurationSslMethod'] = None,
                 tunnel_method: Optional['outputs.SourceMssqlConfigurationTunnelMethod'] = None):
        """
        :param str database: The name of the database.
        :param str host: The hostname of the database.
        :param str password: The password associated with the username.
        :param int port: The port of the database.
        :param str username: The username which is used to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param 'SourceMssqlConfigurationReplicationMethodArgs' replication_method: Configures how data is extracted from the database.
        :param Sequence[str] schemas: The list of schemas to sync from. Defaults to user. Case sensitive.
        :param 'SourceMssqlConfigurationSslMethodArgs' ssl_method: The encryption method which is used when communicating with the database.
        :param 'SourceMssqlConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if replication_method is not None:
            pulumi.set(__self__, "replication_method", replication_method)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if ssl_method is not None:
            pulumi.set(__self__, "ssl_method", ssl_method)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port of the database.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter(name="replicationMethod")
    def replication_method(self) -> Optional['outputs.SourceMssqlConfigurationReplicationMethod']:
        """
        Configures how data is extracted from the database.
        """
        return pulumi.get(self, "replication_method")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence[str]]:
        """
        The list of schemas to sync from. Defaults to user. Case sensitive.
        """
        return pulumi.get(self, "schemas")

    @property
    @pulumi.getter(name="sslMethod")
    def ssl_method(self) -> Optional['outputs.SourceMssqlConfigurationSslMethod']:
        """
        The encryption method which is used when communicating with the database.
        """
        return pulumi.get(self, "ssl_method")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.SourceMssqlConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class SourceMssqlConfigurationReplicationMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readChangesUsingChangeDataCaptureCdc":
            suggest = "read_changes_using_change_data_capture_cdc"
        elif key == "scanChangesWithUserDefinedCursor":
            suggest = "scan_changes_with_user_defined_cursor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationReplicationMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationReplicationMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationReplicationMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_changes_using_change_data_capture_cdc: Optional['outputs.SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc'] = None,
                 scan_changes_with_user_defined_cursor: Optional['outputs.SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor'] = None):
        """
        :param 'SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdcArgs' read_changes_using_change_data_capture_cdc: <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
        :param 'SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs' scan_changes_with_user_defined_cursor: Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        if read_changes_using_change_data_capture_cdc is not None:
            pulumi.set(__self__, "read_changes_using_change_data_capture_cdc", read_changes_using_change_data_capture_cdc)
        if scan_changes_with_user_defined_cursor is not None:
            pulumi.set(__self__, "scan_changes_with_user_defined_cursor", scan_changes_with_user_defined_cursor)

    @property
    @pulumi.getter(name="readChangesUsingChangeDataCaptureCdc")
    def read_changes_using_change_data_capture_cdc(self) -> Optional['outputs.SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc']:
        """
        <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
        """
        return pulumi.get(self, "read_changes_using_change_data_capture_cdc")

    @property
    @pulumi.getter(name="scanChangesWithUserDefinedCursor")
    def scan_changes_with_user_defined_cursor(self) -> Optional['outputs.SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor']:
        """
        Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        return pulumi.get(self, "scan_changes_with_user_defined_cursor")


@pulumi.output_type
class SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialWaitingSeconds":
            suggest = "initial_waiting_seconds"
        elif key == "invalidCdcCursorPositionBehavior":
            suggest = "invalid_cdc_cursor_position_behavior"
        elif key == "queueSize":
            suggest = "queue_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_waiting_seconds: Optional[int] = None,
                 invalid_cdc_cursor_position_behavior: Optional[str] = None,
                 queue_size: Optional[int] = None):
        """
        :param int initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        :param str invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param int queue_size: The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[int]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[str]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[int]:
        """
        The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        return pulumi.get(self, "queue_size")


@pulumi.output_type
class SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMssqlConfigurationSslMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedTrustServerCertificate":
            suggest = "encrypted_trust_server_certificate"
        elif key == "encryptedVerifyCertificate":
            suggest = "encrypted_verify_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationSslMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationSslMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationSslMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted_trust_server_certificate: Optional['outputs.SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificate'] = None,
                 encrypted_verify_certificate: Optional['outputs.SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate'] = None,
                 unencrypted: Optional['outputs.SourceMssqlConfigurationSslMethodUnencrypted'] = None):
        """
        :param 'SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificateArgs' encrypted_trust_server_certificate: Use the certificate provided by the server without verification. (For testing purposes only!)
        :param 'SourceMssqlConfigurationSslMethodEncryptedVerifyCertificateArgs' encrypted_verify_certificate: Verify and use the certificate provided by the server.
        :param 'SourceMssqlConfigurationSslMethodUnencryptedArgs' unencrypted: Data transfer will not be encrypted.
        """
        if encrypted_trust_server_certificate is not None:
            pulumi.set(__self__, "encrypted_trust_server_certificate", encrypted_trust_server_certificate)
        if encrypted_verify_certificate is not None:
            pulumi.set(__self__, "encrypted_verify_certificate", encrypted_verify_certificate)
        if unencrypted is not None:
            pulumi.set(__self__, "unencrypted", unencrypted)

    @property
    @pulumi.getter(name="encryptedTrustServerCertificate")
    def encrypted_trust_server_certificate(self) -> Optional['outputs.SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificate']:
        """
        Use the certificate provided by the server without verification. (For testing purposes only!)
        """
        return pulumi.get(self, "encrypted_trust_server_certificate")

    @property
    @pulumi.getter(name="encryptedVerifyCertificate")
    def encrypted_verify_certificate(self) -> Optional['outputs.SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate']:
        """
        Verify and use the certificate provided by the server.
        """
        return pulumi.get(self, "encrypted_verify_certificate")

    @property
    @pulumi.getter
    def unencrypted(self) -> Optional['outputs.SourceMssqlConfigurationSslMethodUnencrypted']:
        """
        Data transfer will not be encrypted.
        """
        return pulumi.get(self, "unencrypted")


@pulumi.output_type
class SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificate(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostNameInCertificate":
            suggest = "host_name_in_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 host_name_in_certificate: Optional[str] = None):
        """
        :param str certificate: certificate of the server, or of the CA that signed the server certificate
        :param str host_name_in_certificate: Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if host_name_in_certificate is not None:
            pulumi.set(__self__, "host_name_in_certificate", host_name_in_certificate)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        """
        certificate of the server, or of the CA that signed the server certificate
        """
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter(name="hostNameInCertificate")
    def host_name_in_certificate(self) -> Optional[str]:
        """
        Specifies the host name of the server. The value of this property must match the subject property of the certificate.
        """
        return pulumi.get(self, "host_name_in_certificate")


@pulumi.output_type
class SourceMssqlConfigurationSslMethodUnencrypted(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMssqlConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.SourceMssqlConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.SourceMssqlConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.SourceMssqlConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.SourceMssqlConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.SourceMssqlConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.SourceMssqlConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class SourceMssqlConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMssqlConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceMssqlConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMssqlConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMssqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMssqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceMyHoursConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "logsBatchSize":
            suggest = "logs_batch_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMyHoursConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMyHoursConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMyHoursConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email: str,
                 password: str,
                 start_date: str,
                 logs_batch_size: Optional[int] = None):
        """
        :param str email: Your My Hours username
        :param str password: The password associated to the username
        :param str start_date: Start date for collecting time logs
        :param int logs_batch_size: Pagination size used for retrieving logs in days. Default: 30
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "start_date", start_date)
        if logs_batch_size is not None:
            pulumi.set(__self__, "logs_batch_size", logs_batch_size)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        Your My Hours username
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated to the username
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start date for collecting time logs
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="logsBatchSize")
    def logs_batch_size(self) -> Optional[int]:
        """
        Pagination size used for retrieving logs in days. Default: 30
        """
        return pulumi.get(self, "logs_batch_size")


@pulumi.output_type
class SourceMysqlConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationMethod":
            suggest = "replication_method"
        elif key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 replication_method: 'outputs.SourceMysqlConfigurationReplicationMethod',
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 ssl_mode: Optional['outputs.SourceMysqlConfigurationSslMode'] = None,
                 tunnel_method: Optional['outputs.SourceMysqlConfigurationTunnelMethod'] = None):
        """
        :param str database: The database name.
        :param str host: The host name of the database.
        :param 'SourceMysqlConfigurationReplicationMethodArgs' replication_method: Configures how data is extracted from the database.
        :param str username: The username which is used to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
        :param str password: The password associated with the username.
        :param int port: The port to connect to. Default: 3306
        :param 'SourceMysqlConfigurationSslModeArgs' ssl_mode: SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
        :param 'SourceMysqlConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "replication_method", replication_method)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database name.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host name of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="replicationMethod")
    def replication_method(self) -> 'outputs.SourceMysqlConfigurationReplicationMethod':
        """
        Configures how data is extracted from the database.
        """
        return pulumi.get(self, "replication_method")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3). For more information read about <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-jdbc-url-format.html">JDBC URL parameters</a>.
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port to connect to. Default: 3306
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional['outputs.SourceMysqlConfigurationSslMode']:
        """
        SSL connection modes. Read more <a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-using-ssl.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.SourceMysqlConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class SourceMysqlConfigurationReplicationMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readChangesUsingBinaryLogCdc":
            suggest = "read_changes_using_binary_log_cdc"
        elif key == "scanChangesWithUserDefinedCursor":
            suggest = "scan_changes_with_user_defined_cursor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationReplicationMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationReplicationMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationReplicationMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 read_changes_using_binary_log_cdc: Optional['outputs.SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc'] = None,
                 scan_changes_with_user_defined_cursor: Optional['outputs.SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor'] = None):
        """
        :param 'SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdcArgs' read_changes_using_binary_log_cdc: <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the MySQL <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">binary log</a>. This must be enabled on your database.
        :param 'SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs' scan_changes_with_user_defined_cursor: Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        if read_changes_using_binary_log_cdc is not None:
            pulumi.set(__self__, "read_changes_using_binary_log_cdc", read_changes_using_binary_log_cdc)
        if scan_changes_with_user_defined_cursor is not None:
            pulumi.set(__self__, "scan_changes_with_user_defined_cursor", scan_changes_with_user_defined_cursor)

    @property
    @pulumi.getter(name="readChangesUsingBinaryLogCdc")
    def read_changes_using_binary_log_cdc(self) -> Optional['outputs.SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc']:
        """
        <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the MySQL <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">binary log</a>. This must be enabled on your database.
        """
        return pulumi.get(self, "read_changes_using_binary_log_cdc")

    @property
    @pulumi.getter(name="scanChangesWithUserDefinedCursor")
    def scan_changes_with_user_defined_cursor(self) -> Optional['outputs.SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor']:
        """
        Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        return pulumi.get(self, "scan_changes_with_user_defined_cursor")


@pulumi.output_type
class SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialWaitingSeconds":
            suggest = "initial_waiting_seconds"
        elif key == "invalidCdcCursorPositionBehavior":
            suggest = "invalid_cdc_cursor_position_behavior"
        elif key == "serverTimeZone":
            suggest = "server_time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationReplicationMethodReadChangesUsingBinaryLogCdc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_waiting_seconds: Optional[int] = None,
                 invalid_cdc_cursor_position_behavior: Optional[str] = None,
                 server_time_zone: Optional[str] = None):
        """
        :param int initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        :param str invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param str server_time_zone: Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
        """
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if server_time_zone is not None:
            pulumi.set(__self__, "server_time_zone", server_time_zone)

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[int]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[str]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @property
    @pulumi.getter(name="serverTimeZone")
    def server_time_zone(self) -> Optional[str]:
        """
        Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
        """
        return pulumi.get(self, "server_time_zone")


@pulumi.output_type
class SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMysqlConfigurationSslMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCa":
            suggest = "verify_ca"
        elif key == "verifyIdentity":
            suggest = "verify_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationSslMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationSslMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationSslMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred: Optional['outputs.SourceMysqlConfigurationSslModePreferred'] = None,
                 required: Optional['outputs.SourceMysqlConfigurationSslModeRequired'] = None,
                 verify_ca: Optional['outputs.SourceMysqlConfigurationSslModeVerifyCa'] = None,
                 verify_identity: Optional['outputs.SourceMysqlConfigurationSslModeVerifyIdentity'] = None):
        """
        :param 'SourceMysqlConfigurationSslModePreferredArgs' preferred: Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
        :param 'SourceMysqlConfigurationSslModeRequiredArgs' required: Always connect with SSL. If the MySQL server doesn’t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
        :param 'SourceMysqlConfigurationSslModeVerifyCaArgs' verify_ca: Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
        :param 'SourceMysqlConfigurationSslModeVerifyIdentityArgs' verify_identity: Always connect with SSL. Verify both CA and Hostname.
        """
        if preferred is not None:
            pulumi.set(__self__, "preferred", preferred)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_identity is not None:
            pulumi.set(__self__, "verify_identity", verify_identity)

    @property
    @pulumi.getter
    def preferred(self) -> Optional['outputs.SourceMysqlConfigurationSslModePreferred']:
        """
        Automatically attempt SSL connection. If the MySQL server does not support SSL, continue with a regular connection.
        """
        return pulumi.get(self, "preferred")

    @property
    @pulumi.getter
    def required(self) -> Optional['outputs.SourceMysqlConfigurationSslModeRequired']:
        """
        Always connect with SSL. If the MySQL server doesn’t support SSL, the connection will not be established. Certificate Authority (CA) and Hostname are not verified.
        """
        return pulumi.get(self, "required")

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional['outputs.SourceMysqlConfigurationSslModeVerifyCa']:
        """
        Always connect with SSL. Verifies CA, but allows connection even if Hostname does not match.
        """
        return pulumi.get(self, "verify_ca")

    @property
    @pulumi.getter(name="verifyIdentity")
    def verify_identity(self) -> Optional['outputs.SourceMysqlConfigurationSslModeVerifyIdentity']:
        """
        Always connect with SSL. Verify both CA and Hostname.
        """
        return pulumi.get(self, "verify_identity")


@pulumi.output_type
class SourceMysqlConfigurationSslModePreferred(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMysqlConfigurationSslModeRequired(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMysqlConfigurationSslModeVerifyCa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationSslModeVerifyCa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationSslModeVerifyCa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationSslModeVerifyCa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_certificate: Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        :param str client_key: Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        :param str client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class SourceMysqlConfigurationSslModeVerifyIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationSslModeVerifyIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationSslModeVerifyIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationSslModeVerifyIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str client_certificate: Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        :param str client_key: Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        :param str client_key_password: Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Client certificate (this is not a required field, but if you want to use it, you will need to add the <b>Client key</b> as well)
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key (this is not a required field, but if you want to use it, you will need to add the <b>Client certificate</b> as well)
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class SourceMysqlConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.SourceMysqlConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.SourceMysqlConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.SourceMysqlConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.SourceMysqlConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.SourceMysqlConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.SourceMysqlConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class SourceMysqlConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceMysqlConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceMysqlConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceNetsuiteConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerKey":
            suggest = "consumer_key"
        elif key == "consumerSecret":
            suggest = "consumer_secret"
        elif key == "startDatetime":
            suggest = "start_datetime"
        elif key == "tokenKey":
            suggest = "token_key"
        elif key == "tokenSecret":
            suggest = "token_secret"
        elif key == "objectTypes":
            suggest = "object_types"
        elif key == "windowInDays":
            suggest = "window_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceNetsuiteConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceNetsuiteConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceNetsuiteConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_key: str,
                 consumer_secret: str,
                 realm: str,
                 start_datetime: str,
                 token_key: str,
                 token_secret: str,
                 object_types: Optional[Sequence[str]] = None,
                 window_in_days: Optional[int] = None):
        """
        :param str consumer_key: Consumer key associated with your integration
        :param str consumer_secret: Consumer secret associated with your integration
        :param str realm: Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
        :param str start_datetime: Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
        :param str token_key: Access token key
        :param str token_secret: Access token secret
        :param Sequence[str] object_types: The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
        :param int window_in_days: The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data. Default: 30
        """
        pulumi.set(__self__, "consumer_key", consumer_key)
        pulumi.set(__self__, "consumer_secret", consumer_secret)
        pulumi.set(__self__, "realm", realm)
        pulumi.set(__self__, "start_datetime", start_datetime)
        pulumi.set(__self__, "token_key", token_key)
        pulumi.set(__self__, "token_secret", token_secret)
        if object_types is not None:
            pulumi.set(__self__, "object_types", object_types)
        if window_in_days is not None:
            pulumi.set(__self__, "window_in_days", window_in_days)

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        Consumer key associated with your integration
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> str:
        """
        Consumer secret associated with your integration
        """
        return pulumi.get(self, "consumer_secret")

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="startDatetime")
    def start_datetime(self) -> str:
        """
        Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
        """
        return pulumi.get(self, "start_datetime")

    @property
    @pulumi.getter(name="tokenKey")
    def token_key(self) -> str:
        """
        Access token key
        """
        return pulumi.get(self, "token_key")

    @property
    @pulumi.getter(name="tokenSecret")
    def token_secret(self) -> str:
        """
        Access token secret
        """
        return pulumi.get(self, "token_secret")

    @property
    @pulumi.getter(name="objectTypes")
    def object_types(self) -> Optional[Sequence[str]]:
        """
        The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
        """
        return pulumi.get(self, "object_types")

    @property
    @pulumi.getter(name="windowInDays")
    def window_in_days(self) -> Optional[int]:
        """
        The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data. Default: 30
        """
        return pulumi.get(self, "window_in_days")


@pulumi.output_type
class SourceNotionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceNotionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceNotionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceNotionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceNotionConfigurationCredentials'] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceNotionConfigurationCredentialsArgs' credentials: Choose either OAuth (recommended for Airbyte Cloud) or Access Token. See our <a href='https://docs.airbyte.com/integrations/sources/notion#setup-guide'>docs</a> for more information.
        :param str start_date: UTC date and time in the format YYYY-MM-DDTHH:MM:SS.000Z. During incremental sync, any data generated before this date will not be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceNotionConfigurationCredentials']:
        """
        Choose either OAuth (recommended for Airbyte Cloud) or Access Token. See our <a href='https://docs.airbyte.com/integrations/sources/notion#setup-guide'>docs</a> for more information.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format YYYY-MM-DDTHH:MM:SS.000Z. During incremental sync, any data generated before this date will not be replicated. If left blank, the start date will be set to 2 years before the present date.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceNotionConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceNotionConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceNotionConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceNotionConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional['outputs.SourceNotionConfigurationCredentialsAccessToken'] = None,
                 o_auth20: Optional['outputs.SourceNotionConfigurationCredentialsOAuth20'] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.SourceNotionConfigurationCredentialsAccessToken']:
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceNotionConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceNotionConfigurationCredentialsAccessToken(dict):
    def __init__(__self__, *,
                 token: str):
        """
        :param str token: The Access Token for your private Notion integration. See the <a href='https://docs.airbyte.com/integrations/sources/notion#step-1-create-an-integration-in-notion'>docs</a> for more information on how to obtain this token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The Access Token for your private Notion integration. See the <a href='https://docs.airbyte.com/integrations/sources/notion#step-1-create-an-integration-in-notion'>docs</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class SourceNotionConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceNotionConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceNotionConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceNotionConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str):
        """
        :param str access_token: The Access Token received by completing the OAuth flow for your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        :param str client_id: The Client ID of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        :param str client_secret: The Client Secret of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The Access Token received by completing the OAuth flow for your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceNytimesConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "shareType":
            suggest = "share_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceNytimesConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceNytimesConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceNytimesConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 period: int,
                 start_date: str,
                 end_date: Optional[str] = None,
                 share_type: Optional[str] = None):
        """
        :param str api_key: API Key
        :param int period: Period of time (in days). must be one of ["1", "7", "30"]
        :param str start_date: Start date to begin the article retrieval (format YYYY-MM)
        :param str end_date: End date to stop the article retrieval (format YYYY-MM)
        :param str share_type: Share Type. must be one of ["facebook"]
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if share_type is not None:
            pulumi.set(__self__, "share_type", share_type)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def period(self) -> int:
        """
        Period of time (in days). must be one of ["1", "7", "30"]
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start date to begin the article retrieval (format YYYY-MM)
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        End date to stop the article retrieval (format YYYY-MM)
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="shareType")
    def share_type(self) -> Optional[str]:
        """
        Share Type. must be one of ["facebook"]
        """
        return pulumi.get(self, "share_type")


@pulumi.output_type
class SourceOktaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOktaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOktaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOktaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceOktaConfigurationCredentials'] = None,
                 domain: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str domain: The Okta domain. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to find it.
        :param str start_date: UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceOktaConfigurationCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The Okta domain. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to find it.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceOktaConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOktaConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOktaConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOktaConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.SourceOktaConfigurationCredentialsApiToken'] = None,
                 o_auth20: Optional['outputs.SourceOktaConfigurationCredentialsOAuth20'] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.SourceOktaConfigurationCredentialsApiToken']:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceOktaConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceOktaConfigurationCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOktaConfigurationCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOktaConfigurationCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOktaConfigurationCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: An Okta token. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to generate it.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        An Okta token. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class SourceOktaConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOktaConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOktaConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOktaConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The Client ID of your OAuth application.
        :param str client_secret: The Client Secret of your OAuth application.
        :param str refresh_token: Refresh Token to obtain new Access Token, when it's expired.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token to obtain new Access Token, when it's expired.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceOmnisendConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOmnisendConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOmnisendConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOmnisendConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: API Key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceOnesignalConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outcomeNames":
            suggest = "outcome_names"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "userAuthKey":
            suggest = "user_auth_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOnesignalConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOnesignalConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOnesignalConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Sequence['outputs.SourceOnesignalConfigurationApplication'],
                 outcome_names: str,
                 start_date: str,
                 user_auth_key: str):
        """
        :param Sequence['SourceOnesignalConfigurationApplicationArgs'] applications: Applications keys, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys">docs</a> for more information on how to obtain this data
        :param str outcome_names: Comma-separated list of names and the value (sum/count) for the returned outcome data. See the <a href="https://documentation.onesignal.com/reference/view-outcomes">docs</a> for more details
        :param str start_date: The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        :param str user_auth_key: OneSignal User Auth Key, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys#user-auth-key">docs</a> for more information on how to obtain this key.
        """
        pulumi.set(__self__, "applications", applications)
        pulumi.set(__self__, "outcome_names", outcome_names)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "user_auth_key", user_auth_key)

    @property
    @pulumi.getter
    def applications(self) -> Sequence['outputs.SourceOnesignalConfigurationApplication']:
        """
        Applications keys, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys">docs</a> for more information on how to obtain this data
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="outcomeNames")
    def outcome_names(self) -> str:
        """
        Comma-separated list of names and the value (sum/count) for the returned outcome data. See the <a href="https://documentation.onesignal.com/reference/view-outcomes">docs</a> for more details
        """
        return pulumi.get(self, "outcome_names")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="userAuthKey")
    def user_auth_key(self) -> str:
        """
        OneSignal User Auth Key, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys#user-auth-key">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "user_auth_key")


@pulumi.output_type
class SourceOnesignalConfigurationApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appApiKey":
            suggest = "app_api_key"
        elif key == "appId":
            suggest = "app_id"
        elif key == "appName":
            suggest = "app_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOnesignalConfigurationApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOnesignalConfigurationApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOnesignalConfigurationApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_api_key: str,
                 app_id: str,
                 app_name: Optional[str] = None):
        pulumi.set(__self__, "app_api_key", app_api_key)
        pulumi.set(__self__, "app_id", app_id)
        if app_name is not None:
            pulumi.set(__self__, "app_name", app_name)

    @property
    @pulumi.getter(name="appApiKey")
    def app_api_key(self) -> str:
        return pulumi.get(self, "app_api_key")

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter(name="appName")
    def app_name(self) -> Optional[str]:
        return pulumi.get(self, "app_name")


@pulumi.output_type
class SourceOracleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionData":
            suggest = "connection_data"
        elif key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption: 'outputs.SourceOracleConfigurationEncryption',
                 host: str,
                 username: str,
                 connection_data: Optional['outputs.SourceOracleConfigurationConnectionData'] = None,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 schemas: Optional[Sequence[str]] = None,
                 tunnel_method: Optional['outputs.SourceOracleConfigurationTunnelMethod'] = None):
        """
        :param 'SourceOracleConfigurationEncryptionArgs' encryption: The encryption method with is used when communicating with the database.
        :param str host: Hostname of the database.
        :param str username: The username which is used to access the database.
        :param 'SourceOracleConfigurationConnectionDataArgs' connection_data: Connect data that will be used for DB connection
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str password: The password associated with the username.
        :param int port: Port of the database.
               Oracle Corporations recommends the following port numbers:
               1521 - Default listening port for client connections to the listener. 
               2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
               Default: 1521
        :param Sequence[str] schemas: The list of schemas to sync from. Defaults to user. Case sensitive.
        :param 'SourceOracleConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "encryption", encryption)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if connection_data is not None:
            pulumi.set(__self__, "connection_data", connection_data)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def encryption(self) -> 'outputs.SourceOracleConfigurationEncryption':
        """
        The encryption method with is used when communicating with the database.
        """
        return pulumi.get(self, "encryption")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username which is used to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="connectionData")
    def connection_data(self) -> Optional['outputs.SourceOracleConfigurationConnectionData']:
        """
        Connect data that will be used for DB connection
        """
        return pulumi.get(self, "connection_data")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database.
        Oracle Corporations recommends the following port numbers:
        1521 - Default listening port for client connections to the listener. 
        2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
        Default: 1521
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence[str]]:
        """
        The list of schemas to sync from. Defaults to user. Case sensitive.
        """
        return pulumi.get(self, "schemas")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.SourceOracleConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class SourceOracleConfigurationConnectionData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"
        elif key == "systemIdsid":
            suggest = "system_idsid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationConnectionData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationConnectionData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationConnectionData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: Optional['outputs.SourceOracleConfigurationConnectionDataServiceName'] = None,
                 system_idsid: Optional['outputs.SourceOracleConfigurationConnectionDataSystemIdsid'] = None):
        """
        :param 'SourceOracleConfigurationConnectionDataServiceNameArgs' service_name: Use service name
        :param 'SourceOracleConfigurationConnectionDataSystemIdsidArgs' system_idsid: Use SID (Oracle System Identifier)
        """
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if system_idsid is not None:
            pulumi.set(__self__, "system_idsid", system_idsid)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional['outputs.SourceOracleConfigurationConnectionDataServiceName']:
        """
        Use service name
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="systemIdsid")
    def system_idsid(self) -> Optional['outputs.SourceOracleConfigurationConnectionDataSystemIdsid']:
        """
        Use SID (Oracle System Identifier)
        """
        return pulumi.get(self, "system_idsid")


@pulumi.output_type
class SourceOracleConfigurationConnectionDataServiceName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationConnectionDataServiceName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationConnectionDataServiceName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationConnectionDataServiceName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: str):
        pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class SourceOracleConfigurationConnectionDataSystemIdsid(dict):
    def __init__(__self__, *,
                 sid: str):
        pulumi.set(__self__, "sid", sid)

    @property
    @pulumi.getter
    def sid(self) -> str:
        return pulumi.get(self, "sid")


@pulumi.output_type
class SourceOracleConfigurationEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nativeNetworkEncryptionNne":
            suggest = "native_network_encryption_nne"
        elif key == "tlsEncryptedVerifyCertificate":
            suggest = "tls_encrypted_verify_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 native_network_encryption_nne: Optional['outputs.SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne'] = None,
                 tls_encrypted_verify_certificate: Optional['outputs.SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate'] = None):
        """
        :param 'SourceOracleConfigurationEncryptionNativeNetworkEncryptionNneArgs' native_network_encryption_nne: The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
        :param 'SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificateArgs' tls_encrypted_verify_certificate: Verify and use the certificate provided by the server.
        """
        if native_network_encryption_nne is not None:
            pulumi.set(__self__, "native_network_encryption_nne", native_network_encryption_nne)
        if tls_encrypted_verify_certificate is not None:
            pulumi.set(__self__, "tls_encrypted_verify_certificate", tls_encrypted_verify_certificate)

    @property
    @pulumi.getter(name="nativeNetworkEncryptionNne")
    def native_network_encryption_nne(self) -> Optional['outputs.SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne']:
        """
        The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
        """
        return pulumi.get(self, "native_network_encryption_nne")

    @property
    @pulumi.getter(name="tlsEncryptedVerifyCertificate")
    def tls_encrypted_verify_certificate(self) -> Optional['outputs.SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate']:
        """
        Verify and use the certificate provided by the server.
        """
        return pulumi.get(self, "tls_encrypted_verify_certificate")


@pulumi.output_type
class SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionAlgorithm":
            suggest = "encryption_algorithm"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_algorithm: Optional[str] = None):
        """
        :param str encryption_algorithm: This parameter defines what encryption algorithm is used. must be one of ["AES256", "RC4_56", "3DES168"]; Default: "AES256"
        """
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)

    @property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[str]:
        """
        This parameter defines what encryption algorithm is used. must be one of ["AES256", "RC4_56", "3DES168"]; Default: "AES256"
        """
        return pulumi.get(self, "encryption_algorithm")


@pulumi.output_type
class SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sslCertificate":
            suggest = "ssl_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssl_certificate: str):
        """
        :param str ssl_certificate: Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
        """
        pulumi.set(__self__, "ssl_certificate", ssl_certificate)

    @property
    @pulumi.getter(name="sslCertificate")
    def ssl_certificate(self) -> str:
        """
        Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
        """
        return pulumi.get(self, "ssl_certificate")


@pulumi.output_type
class SourceOracleConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.SourceOracleConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.SourceOracleConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.SourceOracleConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.SourceOracleConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.SourceOracleConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.SourceOracleConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class SourceOracleConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceOracleConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceOracleConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOracleConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOracleConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOracleConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourceOrbConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "lookbackWindowDays":
            suggest = "lookback_window_days"
        elif key == "numericEventPropertiesKeys":
            suggest = "numeric_event_properties_keys"
        elif key == "planId":
            suggest = "plan_id"
        elif key == "stringEventPropertiesKeys":
            suggest = "string_event_properties_keys"
        elif key == "subscriptionUsageGroupingKey":
            suggest = "subscription_usage_grouping_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOrbConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOrbConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOrbConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str,
                 end_date: Optional[str] = None,
                 lookback_window_days: Optional[int] = None,
                 numeric_event_properties_keys: Optional[Sequence[str]] = None,
                 plan_id: Optional[str] = None,
                 string_event_properties_keys: Optional[Sequence[str]] = None,
                 subscription_usage_grouping_key: Optional[str] = None):
        """
        :param str api_key: Orb API Key, issued from the Orb admin console.
        :param str start_date: UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at before this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        :param str end_date: UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at after this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        :param int lookback_window_days: When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        :param Sequence[str] numeric_event_properties_keys: Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        :param str plan_id: Orb Plan ID to filter subscriptions that should have usage fetched.
        :param Sequence[str] string_event_properties_keys: Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        :param str subscription_usage_grouping_key: Property key name to group subscription usage by.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if lookback_window_days is not None:
            pulumi.set(__self__, "lookback_window_days", lookback_window_days)
        if numeric_event_properties_keys is not None:
            pulumi.set(__self__, "numeric_event_properties_keys", numeric_event_properties_keys)
        if plan_id is not None:
            pulumi.set(__self__, "plan_id", plan_id)
        if string_event_properties_keys is not None:
            pulumi.set(__self__, "string_event_properties_keys", string_event_properties_keys)
        if subscription_usage_grouping_key is not None:
            pulumi.set(__self__, "subscription_usage_grouping_key", subscription_usage_grouping_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Orb API Key, issued from the Orb admin console.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at before this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at after this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="lookbackWindowDays")
    def lookback_window_days(self) -> Optional[int]:
        """
        When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced. Default: 0
        """
        return pulumi.get(self, "lookback_window_days")

    @property
    @pulumi.getter(name="numericEventPropertiesKeys")
    def numeric_event_properties_keys(self) -> Optional[Sequence[str]]:
        """
        Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        """
        return pulumi.get(self, "numeric_event_properties_keys")

    @property
    @pulumi.getter(name="planId")
    def plan_id(self) -> Optional[str]:
        """
        Orb Plan ID to filter subscriptions that should have usage fetched.
        """
        return pulumi.get(self, "plan_id")

    @property
    @pulumi.getter(name="stringEventPropertiesKeys")
    def string_event_properties_keys(self) -> Optional[Sequence[str]]:
        """
        Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
        """
        return pulumi.get(self, "string_event_properties_keys")

    @property
    @pulumi.getter(name="subscriptionUsageGroupingKey")
    def subscription_usage_grouping_key(self) -> Optional[str]:
        """
        Property key name to group subscription usage by.
        """
        return pulumi.get(self, "subscription_usage_grouping_key")


@pulumi.output_type
class SourceOrbitConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOrbitConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOrbitConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOrbitConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 workspace: str,
                 start_date: Optional[str] = None):
        """
        :param str api_token: Authorizes you to work with Orbit workspaces associated with the token.
        :param str workspace: The unique name of the workspace that your API token is associated with.
        :param str start_date: Date in the format 2022-06-26. Only load members whose last activities are after this date.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "workspace", workspace)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Authorizes you to work with Orbit workspaces associated with the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter
    def workspace(self) -> str:
        """
        The unique name of the workspace that your API token is associated with.
        """
        return pulumi.get(self, "workspace")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        Date in the format 2022-06-26. Only load members whose last activities are after this date.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceOutbrainAmplifyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "geoLocationBreakdown":
            suggest = "geo_location_breakdown"
        elif key == "reportGranularity":
            suggest = "report_granularity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOutbrainAmplifyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOutbrainAmplifyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOutbrainAmplifyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceOutbrainAmplifyConfigurationCredentials',
                 start_date: str,
                 end_date: Optional[str] = None,
                 geo_location_breakdown: Optional[str] = None,
                 report_granularity: Optional[str] = None):
        """
        :param 'SourceOutbrainAmplifyConfigurationCredentialsArgs' credentials: Credentials for making authenticated requests requires either username/password or access_token.
        :param str start_date: Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
        :param str end_date: Date in the format YYYY-MM-DD.
        :param str geo_location_breakdown: The granularity used for geo location data in reports. must be one of ["country", "region", "subregion"]
        :param str report_granularity: The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>. must be one of ["daily", "weekly", "monthly"]
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if geo_location_breakdown is not None:
            pulumi.set(__self__, "geo_location_breakdown", geo_location_breakdown)
        if report_granularity is not None:
            pulumi.set(__self__, "report_granularity", report_granularity)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceOutbrainAmplifyConfigurationCredentials':
        """
        Credentials for making authenticated requests requires either username/password or access_token.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        Date in the format YYYY-MM-DD.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="geoLocationBreakdown")
    def geo_location_breakdown(self) -> Optional[str]:
        """
        The granularity used for geo location data in reports. must be one of ["country", "region", "subregion"]
        """
        return pulumi.get(self, "geo_location_breakdown")

    @property
    @pulumi.getter(name="reportGranularity")
    def report_granularity(self) -> Optional[str]:
        """
        The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>. must be one of ["daily", "weekly", "monthly"]
        """
        return pulumi.get(self, "report_granularity")


@pulumi.output_type
class SourceOutbrainAmplifyConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOutbrainAmplifyConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOutbrainAmplifyConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOutbrainAmplifyConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional['outputs.SourceOutbrainAmplifyConfigurationCredentialsAccessToken'] = None,
                 username_password: Optional['outputs.SourceOutbrainAmplifyConfigurationCredentialsUsernamePassword'] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.SourceOutbrainAmplifyConfigurationCredentialsAccessToken']:
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.SourceOutbrainAmplifyConfigurationCredentialsUsernamePassword']:
        return pulumi.get(self, "username_password")


@pulumi.output_type
class SourceOutbrainAmplifyConfigurationCredentialsAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOutbrainAmplifyConfigurationCredentialsAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOutbrainAmplifyConfigurationCredentialsAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOutbrainAmplifyConfigurationCredentialsAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceOutbrainAmplifyConfigurationCredentialsUsernamePassword(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Add Password for authentication.
        :param str username: Add Username for authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Add Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Add Username for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SourceOutreachConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "redirectUri":
            suggest = "redirect_uri"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceOutreachConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceOutreachConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceOutreachConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 redirect_uri: str,
                 refresh_token: str,
                 start_date: str):
        """
        :param str client_id: The Client ID of your Outreach developer application.
        :param str client_secret: The Client Secret of your Outreach developer application.
        :param str redirect_uri: A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
        :param str refresh_token: The token for obtaining the new access token.
        :param str start_date: The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "redirect_uri", redirect_uri)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Outreach developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Outreach developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> str:
        """
        A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
        """
        return pulumi.get(self, "redirect_uri")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token for obtaining the new access token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourcePaypalTransactionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "disputeStartDate":
            suggest = "dispute_start_date"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "isSandbox":
            suggest = "is_sandbox"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePaypalTransactionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePaypalTransactionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePaypalTransactionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 start_date: str,
                 dispute_start_date: Optional[str] = None,
                 end_date: Optional[str] = None,
                 is_sandbox: Optional[bool] = None,
                 refresh_token: Optional[str] = None,
                 time_window: Optional[int] = None):
        """
        :param str client_id: The Client ID of your Paypal developer application.
        :param str client_secret: The Client Secret of your Paypal developer application.
        :param str start_date: Start Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. Date must be in range from 3 years till 12 hrs before present time.
        :param str dispute_start_date: Start Date parameter for the list dispute endpoint in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This Start Date must be in range within 180 days before present time, and requires ONLY 3 miliseconds(mandatory). If you don't use this option, it defaults to a start date set 180 days in the past.
        :param str end_date: End Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This can be help you select specific range of time, mainly for test purposes  or data integrity tests. When this is not used, now_utc() is used by the streams. This does not apply to Disputes and Product streams.
        :param bool is_sandbox: Determines whether to use the sandbox or production environment. Default: false
        :param str refresh_token: The key to refresh the expired access token.
        :param int time_window: The number of days per request. Must be a number between 1 and 31. Default: 7
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "start_date", start_date)
        if dispute_start_date is not None:
            pulumi.set(__self__, "dispute_start_date", dispute_start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if is_sandbox is not None:
            pulumi.set(__self__, "is_sandbox", is_sandbox)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Paypal developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Paypal developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. Date must be in range from 3 years till 12 hrs before present time.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="disputeStartDate")
    def dispute_start_date(self) -> Optional[str]:
        """
        Start Date parameter for the list dispute endpoint in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This Start Date must be in range within 180 days before present time, and requires ONLY 3 miliseconds(mandatory). If you don't use this option, it defaults to a start date set 180 days in the past.
        """
        return pulumi.get(self, "dispute_start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        End Date for data extraction in <a href=\\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\\">ISO format</a>. This can be help you select specific range of time, mainly for test purposes  or data integrity tests. When this is not used, now_utc() is used by the streams. This does not apply to Disputes and Product streams.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="isSandbox")
    def is_sandbox(self) -> Optional[bool]:
        """
        Determines whether to use the sandbox or production environment. Default: false
        """
        return pulumi.get(self, "is_sandbox")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        The key to refresh the expired access token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[int]:
        """
        The number of days per request. Must be a number between 1 and 31. Default: 7
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class SourcePaystackConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "lookbackWindowDays":
            suggest = "lookback_window_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePaystackConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePaystackConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePaystackConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key: str,
                 start_date: str,
                 lookback_window_days: Optional[int] = None):
        """
        :param str secret_key: The Paystack API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.paystack.com/#/settings/developer">here</a>).
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param int lookback_window_days: When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation. Default: 0
        """
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)
        if lookback_window_days is not None:
            pulumi.set(__self__, "lookback_window_days", lookback_window_days)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        The Paystack API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.paystack.com/#/settings/developer">here</a>).
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="lookbackWindowDays")
    def lookback_window_days(self) -> Optional[int]:
        """
        When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation. Default: 0
        """
        return pulumi.get(self, "lookback_window_days")


@pulumi.output_type
class SourcePendoConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePendoConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePendoConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePendoConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourcePersistiqConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePersistiqConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePersistiqConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePersistiqConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: PersistIq API Key. See the <a href="https://apidocs.persistiq.com/#authentication">docs</a> for more information on where to find that key.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        PersistIq API Key. See the <a href="https://apidocs.persistiq.com/#authentication">docs</a> for more information on where to find that key.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourcePexelsApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePexelsApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePexelsApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePexelsApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 query: str,
                 color: Optional[str] = None,
                 locale: Optional[str] = None,
                 orientation: Optional[str] = None,
                 size: Optional[str] = None):
        """
        :param str api_key: API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
        :param str query: Optional, the search query, Example Ocean, Tigers, Pears, etc.
        :param str color: Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
        :param str locale: Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
        :param str orientation: Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
        :param str size: Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query", query)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if orientation is not None:
            pulumi.set(__self__, "orientation", orientation)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Optional, the search query, Example Ocean, Tigers, Pears, etc.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def locale(self) -> Optional[str]:
        """
        Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
        """
        return pulumi.get(self, "locale")

    @property
    @pulumi.getter
    def orientation(self) -> Optional[str]:
        """
        Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
        """
        return pulumi.get(self, "orientation")

    @property
    @pulumi.getter
    def size(self) -> Optional[str]:
        """
        Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
        """
        return pulumi.get(self, "size")


@pulumi.output_type
class SourcePinterestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customReports":
            suggest = "custom_reports"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePinterestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePinterestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePinterestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourcePinterestConfigurationCredentials'] = None,
                 custom_reports: Optional[Sequence['outputs.SourcePinterestConfigurationCustomReport']] = None,
                 start_date: Optional[str] = None,
                 statuses: Optional[Sequence[str]] = None):
        """
        :param Sequence['SourcePinterestConfigurationCustomReportArgs'] custom_reports: A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        :param str start_date: A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
        :param Sequence[str] statuses: For the ads, ad_groups, and campaigns streams, specifying a status will filter out records that do not match the specified ones. If a status is not specified, the source will default to records with a status of either ACTIVE or PAUSED.
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_reports is not None:
            pulumi.set(__self__, "custom_reports", custom_reports)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourcePinterestConfigurationCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customReports")
    def custom_reports(self) -> Optional[Sequence['outputs.SourcePinterestConfigurationCustomReport']]:
        """
        A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
        """
        return pulumi.get(self, "custom_reports")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence[str]]:
        """
        For the ads, ad_groups, and campaigns streams, specifying a status will filter out records that do not match the specified ones. If a status is not specified, the source will default to records with a status of either ACTIVE or PAUSED.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class SourcePinterestConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePinterestConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePinterestConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePinterestConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The Client ID of your OAuth application
        :param str client_secret: The Client Secret of your OAuth application.
        :param str refresh_token: Refresh Token to obtain new Access Token, when it's expired.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your OAuth application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token to obtain new Access Token, when it's expired.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourcePinterestConfigurationCustomReport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributionTypes":
            suggest = "attribution_types"
        elif key == "clickWindowDays":
            suggest = "click_window_days"
        elif key == "conversionReportTime":
            suggest = "conversion_report_time"
        elif key == "engagementWindowDays":
            suggest = "engagement_window_days"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "viewWindowDays":
            suggest = "view_window_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePinterestConfigurationCustomReport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePinterestConfigurationCustomReport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePinterestConfigurationCustomReport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence[str],
                 name: str,
                 attribution_types: Optional[Sequence[str]] = None,
                 click_window_days: Optional[int] = None,
                 conversion_report_time: Optional[str] = None,
                 engagement_window_days: Optional[int] = None,
                 granularity: Optional[str] = None,
                 level: Optional[str] = None,
                 start_date: Optional[str] = None,
                 view_window_days: Optional[int] = None):
        """
        :param Sequence[str] columns: A list of chosen columns
        :param str name: The name value of report
        :param Sequence[str] attribution_types: List of types of attribution for the conversion report
        :param int click_window_days: Number of days to use as the conversion attribution window for a pin click action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: 30
        :param str conversion_report_time: The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.. must be one of ["TIME_OF_AD_ACTION", "TIME_OF_CONVERSION"]; Default: "TIME_OF_AD_ACTION"
        :param int engagement_window_days: Number of days to use as the conversion attribution window for an engagement action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        :param str granularity: Chosen granularity for API. must be one of ["TOTAL", "DAY", "HOUR", "WEEK", "MONTH"]; Default: "TOTAL"
        :param str level: Chosen level for API. must be one of ["ADVERTISER", "ADVERTISER_TARGETING", "CAMPAIGN", "CAMPAIGN_TARGETING", "AD_GROUP", "AD_GROUP_TARGETING", "PIN_PROMOTION", "PIN_PROMOTION_TARGETING", "KEYWORD", "PRODUCT_GROUP", "PRODUCT_GROUP_TARGETING", "PRODUCT_ITEM"]; Default: "ADVERTISER"
        :param str start_date: A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by report api (913 days from today).
        :param int view_window_days: Number of days to use as the conversion attribution window for a view action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "name", name)
        if attribution_types is not None:
            pulumi.set(__self__, "attribution_types", attribution_types)
        if click_window_days is not None:
            pulumi.set(__self__, "click_window_days", click_window_days)
        if conversion_report_time is not None:
            pulumi.set(__self__, "conversion_report_time", conversion_report_time)
        if engagement_window_days is not None:
            pulumi.set(__self__, "engagement_window_days", engagement_window_days)
        if granularity is not None:
            pulumi.set(__self__, "granularity", granularity)
        if level is not None:
            pulumi.set(__self__, "level", level)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if view_window_days is not None:
            pulumi.set(__self__, "view_window_days", view_window_days)

    @property
    @pulumi.getter
    def columns(self) -> Sequence[str]:
        """
        A list of chosen columns
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name value of report
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="attributionTypes")
    def attribution_types(self) -> Optional[Sequence[str]]:
        """
        List of types of attribution for the conversion report
        """
        return pulumi.get(self, "attribution_types")

    @property
    @pulumi.getter(name="clickWindowDays")
    def click_window_days(self) -> Optional[int]:
        """
        Number of days to use as the conversion attribution window for a pin click action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: 30
        """
        return pulumi.get(self, "click_window_days")

    @property
    @pulumi.getter(name="conversionReportTime")
    def conversion_report_time(self) -> Optional[str]:
        """
        The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.. must be one of ["TIME_OF_AD_ACTION", "TIME_OF_CONVERSION"]; Default: "TIME_OF_AD_ACTION"
        """
        return pulumi.get(self, "conversion_report_time")

    @property
    @pulumi.getter(name="engagementWindowDays")
    def engagement_window_days(self) -> Optional[int]:
        """
        Number of days to use as the conversion attribution window for an engagement action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        """
        return pulumi.get(self, "engagement_window_days")

    @property
    @pulumi.getter
    def granularity(self) -> Optional[str]:
        """
        Chosen granularity for API. must be one of ["TOTAL", "DAY", "HOUR", "WEEK", "MONTH"]; Default: "TOTAL"
        """
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def level(self) -> Optional[str]:
        """
        Chosen level for API. must be one of ["ADVERTISER", "ADVERTISER_TARGETING", "CAMPAIGN", "CAMPAIGN_TARGETING", "AD_GROUP", "AD_GROUP_TARGETING", "PIN_PROMOTION", "PIN_PROMOTION_TARGETING", "KEYWORD", "PRODUCT_GROUP", "PRODUCT_GROUP_TARGETING", "PRODUCT_ITEM"]; Default: "ADVERTISER"
        """
        return pulumi.get(self, "level")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by report api (913 days from today).
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="viewWindowDays")
    def view_window_days(self) -> Optional[int]:
        """
        Number of days to use as the conversion attribution window for a view action. must be one of ["0", "1", "7", "14", "30", "60"]; Default: [30]
        """
        return pulumi.get(self, "view_window_days")


@pulumi.output_type
class SourcePipedriveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "replicationStartDate":
            suggest = "replication_start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePipedriveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePipedriveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePipedriveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 replication_start_date: str):
        """
        :param str api_token: The Pipedrive API Token.
        :param str replication_start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "replication_start_date", replication_start_date)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The Pipedrive API Token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="replicationStartDate")
    def replication_start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
        """
        return pulumi.get(self, "replication_start_date")


@pulumi.output_type
class SourcePocketConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "consumerKey":
            suggest = "consumer_key"
        elif key == "contentType":
            suggest = "content_type"
        elif key == "detailType":
            suggest = "detail_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePocketConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePocketConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePocketConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 consumer_key: str,
                 content_type: Optional[str] = None,
                 detail_type: Optional[str] = None,
                 domain: Optional[str] = None,
                 favorite: Optional[bool] = None,
                 search: Optional[str] = None,
                 since: Optional[str] = None,
                 sort: Optional[str] = None,
                 state: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str access_token: The user's Pocket access token.
        :param str consumer_key: Your application's Consumer Key.
        :param str content_type: Select the content type of the items to retrieve. must be one of ["article", "video", "image"]
        :param str detail_type: Select the granularity of the information about each item. must be one of ["simple", "complete"]
        :param str domain: Only return items from a particular `domain`.
        :param bool favorite: Retrieve only favorited items. Default: false
        :param str search: Only return items whose title or url contain the `search` string.
        :param str since: Only return items modified since the given timestamp.
        :param str sort: Sort retrieved items by the given criteria. must be one of ["newest", "oldest", "title", "site"]
        :param str state: Select the state of the items to retrieve. must be one of ["unread", "archive", "all"]
        :param str tag: Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "consumer_key", consumer_key)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if detail_type is not None:
            pulumi.set(__self__, "detail_type", detail_type)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if favorite is not None:
            pulumi.set(__self__, "favorite", favorite)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if since is not None:
            pulumi.set(__self__, "since", since)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The user's Pocket access token.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> str:
        """
        Your application's Consumer Key.
        """
        return pulumi.get(self, "consumer_key")

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        Select the content type of the items to retrieve. must be one of ["article", "video", "image"]
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="detailType")
    def detail_type(self) -> Optional[str]:
        """
        Select the granularity of the information about each item. must be one of ["simple", "complete"]
        """
        return pulumi.get(self, "detail_type")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Only return items from a particular `domain`.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def favorite(self) -> Optional[bool]:
        """
        Retrieve only favorited items. Default: false
        """
        return pulumi.get(self, "favorite")

    @property
    @pulumi.getter
    def search(self) -> Optional[str]:
        """
        Only return items whose title or url contain the `search` string.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def since(self) -> Optional[str]:
        """
        Only return items modified since the given timestamp.
        """
        return pulumi.get(self, "since")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        Sort retrieved items by the given criteria. must be one of ["newest", "oldest", "title", "site"]
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        Select the state of the items to retrieve. must be one of ["unread", "archive", "all"]
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class SourcePokeapiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pokemonName":
            suggest = "pokemon_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePokeapiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePokeapiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePokeapiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pokemon_name: str):
        """
        :param str pokemon_name: Pokemon requested from the API. must be one of ["bulbasaur", "ivysaur", "venusaur", "charmander", "charmeleon", "charizard", "squirtle", "wartortle", "blastoise", "caterpie", "metapod", "butterfree", "weedle", "kakuna", "beedrill", "pidgey", "pidgeotto", "pidgeot", "rattata", "raticate", "spearow", "fearow", "ekans", "arbok", "pikachu", "raichu", "sandshrew", "sandslash", "nidoranf", "nidorina", "nidoqueen", "nidoranm", "nidorino", "nidoking", "clefairy", "clefable", "vulpix", "ninetales", "jigglypuff", "wigglytuff", "zubat", "golbat", "oddish", "gloom", "vileplume", "paras", "parasect", "venonat", "venomoth", "diglett", "dugtrio", "meowth", "persian", "psyduck", "golduck", "mankey", "primeape", "growlithe", "arcanine", "poliwag", "poliwhirl", "poliwrath", "abra", "kadabra", "alakazam", "machop", "machoke", "machamp", "bellsprout", "weepinbell", "victreebel", "tentacool", "tentacruel", "geodude", "graveler", "golem", "ponyta", "rapidash", "slowpoke", "slowbro", "magnemite", "magneton", "farfetchd", "doduo", "dodrio", "seel", "dewgong", "grimer", "muk", "shellder", "cloyster", "gastly", "haunter", "gengar", "onix", "drowzee", "hypno", "krabby", "kingler", "voltorb", "electrode", "exeggcute", "exeggutor", "cubone", "marowak", "hitmonlee", "hitmonchan", "lickitung", "koffing", "weezing", "rhyhorn", "rhydon", "chansey", "tangela", "kangaskhan", "horsea", "seadra", "goldeen", "seaking", "staryu", "starmie", "mrmime", "scyther", "jynx", "electabuzz", "magmar", "pinsir", "tauros", "magikarp", "gyarados", "lapras", "ditto", "eevee", "vaporeon", "jolteon", "flareon", "porygon", "omanyte", "omastar", "kabuto", "kabutops", "aerodactyl", "snorlax", "articuno", "zapdos", "moltres", "dratini", "dragonair", "dragonite", "mewtwo", "mew", "chikorita", "bayleef", "meganium", "cyndaquil", "quilava", "typhlosion", "totodile", "croconaw", "feraligatr", "sentret", "furret", "hoothoot", "noctowl", "ledyba", "ledian", "spinarak", "ariados", "crobat", "chinchou", "lanturn", "pichu", "cleffa", "igglybuff", "togepi", "togetic", "natu", "xatu", "mareep", "flaaffy", "ampharos", "bellossom", "marill", "azumarill", "sudowoodo", "politoed", "hoppip", "skiploom", "jumpluff", "aipom", "sunkern", "sunflora", "yanma", "wooper", "quagsire", "espeon", "umbreon", "murkrow", "slowking", "misdreavus", "unown", "wobbuffet", "girafarig", "pineco", "forretress", "dunsparce", "gligar", "steelix", "snubbull", "granbull", "qwilfish", "scizor", "shuckle", "heracross", "sneasel", "teddiursa", "ursaring", "slugma", "magcargo", "swinub", "piloswine", "corsola", "remoraid", "octillery", "delibird", "mantine", "skarmory", "houndour", "houndoom", "kingdra", "phanpy", "donphan", "porygon2", "stantler", "smeargle", "tyrogue", "hitmontop", "smoochum", "elekid", "magby", "miltank", "blissey", "raikou", "entei", "suicune", "larvitar", "pupitar", "tyranitar", "lugia", "ho-oh", "celebi", "treecko", "grovyle", "sceptile", "torchic", "combusken", "blaziken", "mudkip", "marshtomp", "swampert", "poochyena", "mightyena", "zigzagoon", "linoone", "wurmple", "silcoon", "beautifly", "cascoon", "dustox", "lotad", "lombre", "ludicolo", "seedot", "nuzleaf", "shiftry", "taillow", "swellow", "wingull", "pelipper", "ralts", "kirlia", "gardevoir", "surskit", "masquerain", "shroomish", "breloom", "slakoth", "vigoroth", "slaking", "nincada", "ninjask", "shedinja", "whismur", "loudred", "exploud", "makuhita", "hariyama", "azurill", "nosepass", "skitty", "delcatty", "sableye", "mawile", "aron", "lairon", "aggron", "meditite", "medicham", "electrike", "manectric", "plusle", "minun", "volbeat", "illumise", "roselia", "gulpin", "swalot", "carvanha", "sharpedo", "wailmer", "wailord", "numel", "camerupt", "torkoal", "spoink", "grumpig", "spinda", "trapinch", "vibrava", "flygon", "cacnea", "cacturne", "swablu", "altaria", "zangoose", "seviper", "lunatone", "solrock", "barboach", "whiscash", "corphish", "crawdaunt", "baltoy", "claydol", "lileep", "cradily", "anorith", "armaldo", "feebas", "milotic", "castform", "kecleon", "shuppet", "banette", "duskull", "dusclops", "tropius", "chimecho", "absol", "wynaut", "snorunt", "glalie", "spheal", "sealeo", "walrein", "clamperl", "huntail", "gorebyss", "relicanth", "luvdisc", "bagon", "shelgon", "salamence", "beldum", "metang", "metagross", "regirock", "regice", "registeel", "latias", "latios", "kyogre", "groudon", "rayquaza", "jirachi", "deoxys", "turtwig", "grotle", "torterra", "chimchar", "monferno", "infernape", "piplup", "prinplup", "empoleon", "starly", "staravia", "staraptor", "bidoof", "bibarel", "kricketot", "kricketune", "shinx", "luxio", "luxray", "budew", "roserade", "cranidos", "rampardos", "shieldon", "bastiodon", "burmy", "wormadam", "mothim", "combee", "vespiquen", "pachirisu", "buizel", "floatzel", "cherubi", "cherrim", "shellos", "gastrodon", "ambipom", "drifloon", "drifblim", "buneary", "lopunny", "mismagius", "honchkrow", "glameow", "purugly", "chingling", "stunky", "skuntank", "bronzor", "bronzong", "bonsly", "mimejr", "happiny", "chatot", "spiritomb", "gible", "gabite", "garchomp", "munchlax", "riolu", "lucario", "hippopotas", "hippowdon", "skorupi", "drapion", "croagunk", "toxicroak", "carnivine", "finneon", "lumineon", "mantyke", "snover", "abomasnow", "weavile", "magnezone", "lickilicky", "rhyperior", "tangrowth", "electivire", "magmortar", "togekiss", "yanmega", "leafeon", "glaceon", "gliscor", "mamoswine", "porygon-z", "gallade", "probopass", "dusknoir", "froslass", "rotom", "uxie", "mesprit", "azelf", "dialga", "palkia", "heatran", "regigigas", "giratina", "cresselia", "phione", "manaphy", "darkrai", "shaymin", "arceus", "victini", "snivy", "servine", "serperior", "tepig", "pignite", "emboar", "oshawott", "dewott", "samurott", "patrat", "watchog", "lillipup", "herdier", "stoutland", "purrloin", "liepard", "pansage", "simisage", "pansear", "simisear", "panpour", "simipour", "munna", "musharna", "pidove", "tranquill", "unfezant", "blitzle", "zebstrika", "roggenrola", "boldore", "gigalith", "woobat", "swoobat", "drilbur", "excadrill", "audino", "timburr", "gurdurr", "conkeldurr", "tympole", "palpitoad", "seismitoad", "throh", "sawk", "sewaddle", "swadloon", "leavanny", "venipede", "whirlipede", "scolipede", "cottonee", "whimsicott", "petilil", "lilligant", "basculin", "sandile", "krokorok", "krookodile", "darumaka", "darmanitan", "maractus", "dwebble", "crustle", "scraggy", "scrafty", "sigilyph", "yamask", "cofagrigus", "tirtouga", "carracosta", "archen", "archeops", "trubbish", "garbodor", "zorua", "zoroark", "minccino", "cinccino", "gothita", "gothorita", "gothitelle", "solosis", "duosion", "reuniclus", "ducklett", "swanna", "vanillite", "vanillish", "vanilluxe", "deerling", "sawsbuck", "emolga", "karrablast", "escavalier", "foongus", "amoonguss", "frillish", "jellicent", "alomomola", "joltik", "galvantula", "ferroseed", "ferrothorn", "klink", "klang", "klinklang", "tynamo", "eelektrik", "eelektross", "elgyem", "beheeyem", "litwick", "lampent", "chandelure", "axew", "fraxure", "haxorus", "cubchoo", "beartic", "cryogonal", "shelmet", "accelgor", "stunfisk", "mienfoo", "mienshao", "druddigon", "golett", "golurk", "pawniard", "bisharp", "bouffalant", "rufflet", "braviary", "vullaby", "mandibuzz", "heatmor", "durant", "deino", "zweilous", "hydreigon", "larvesta", "volcarona", "cobalion", "terrakion", "virizion", "tornadus", "thundurus", "reshiram", "zekrom", "landorus", "kyurem", "keldeo", "meloetta", "genesect", "chespin", "quilladin", "chesnaught", "fennekin", "braixen", "delphox", "froakie", "frogadier", "greninja", "bunnelby", "diggersby", "fletchling", "fletchinder", "talonflame", "scatterbug", "spewpa", "vivillon", "litleo", "pyroar", "flabebe", "floette", "florges", "skiddo", "gogoat", "pancham", "pangoro", "furfrou", "espurr", "meowstic", "honedge", "doublade", "aegislash", "spritzee", "aromatisse", "swirlix", "slurpuff", "inkay", "malamar", "binacle", "barbaracle", "skrelp", "dragalge", "clauncher", "clawitzer", "helioptile", "heliolisk", "tyrunt", "tyrantrum", "amaura", "aurorus", "sylveon", "hawlucha", "dedenne", "carbink", "goomy", "sliggoo", "goodra", "klefki", "phantump", "trevenant", "pumpkaboo", "gourgeist", "bergmite", "avalugg", "noibat", "noivern", "xerneas", "yveltal", "zygarde", "diancie", "hoopa", "volcanion", "rowlet", "dartrix", "decidueye", "litten", "torracat", "incineroar", "popplio", "brionne", "primarina", "pikipek", "trumbeak", "toucannon", "yungoos", "gumshoos", "grubbin", "charjabug", "vikavolt", "crabrawler", "crabominable", "oricorio", "cutiefly", "ribombee", "rockruff", "lycanroc", "wishiwashi", "mareanie", "toxapex", "mudbray", "mudsdale", "dewpider", "araquanid", "fomantis", "lurantis", "morelull", "shiinotic", "salandit", "salazzle", "stufful", "bewear", "bounsweet", "steenee", "tsareena", "comfey", "oranguru", "passimian", "wimpod", "golisopod", "sandygast", "palossand", "pyukumuku", "typenull", "silvally", "minior", "komala", "turtonator", "togedemaru", "mimikyu", "bruxish", "drampa", "dhelmise", "jangmo-o", "hakamo-o", "kommo-o", "tapukoko", "tapulele", "tapubulu", "tapufini", "cosmog", "cosmoem", "solgaleo", "lunala", "nihilego", "buzzwole", "pheromosa", "xurkitree", "celesteela", "kartana", "guzzlord", "necrozma", "magearna", "marshadow", "poipole", "naganadel", "stakataka", "blacephalon", "zeraora", "meltan", "melmetal", "grookey", "thwackey", "rillaboom", "scorbunny", "raboot", "cinderace", "sobble", "drizzile", "inteleon", "skwovet", "greedent", "rookidee", "corvisquire", "corviknight", "blipbug", "dottler", "orbeetle", "nickit", "thievul", "gossifleur", "eldegoss", "wooloo", "dubwool", "chewtle", "drednaw", "yamper", "boltund", "rolycoly", "carkol", "coalossal", "applin", "flapple", "appletun", "silicobra", "sandaconda", "cramorant", "arrokuda", "barraskewda", "toxel", "toxtricity", "sizzlipede", "centiskorch", "clobbopus", "grapploct", "sinistea", "polteageist", "hatenna", "hattrem", "hatterene", "impidimp", "morgrem", "grimmsnarl", "obstagoon", "perrserker", "cursola", "sirfetchd", "mrrime", "runerigus", "milcery", "alcremie", "falinks", "pincurchin", "snom", "frosmoth", "stonjourner", "eiscue", "indeedee", "morpeko", "cufant", "copperajah", "dracozolt", "arctozolt", "dracovish", "arctovish", "duraludon", "dreepy", "drakloak", "dragapult", "zacian", "zamazenta", "eternatus", "kubfu", "urshifu", "zarude", "regieleki", "regidrago", "glastrier", "spectrier", "calyrex"]
        """
        pulumi.set(__self__, "pokemon_name", pokemon_name)

    @property
    @pulumi.getter(name="pokemonName")
    def pokemon_name(self) -> str:
        """
        Pokemon requested from the API. must be one of ["bulbasaur", "ivysaur", "venusaur", "charmander", "charmeleon", "charizard", "squirtle", "wartortle", "blastoise", "caterpie", "metapod", "butterfree", "weedle", "kakuna", "beedrill", "pidgey", "pidgeotto", "pidgeot", "rattata", "raticate", "spearow", "fearow", "ekans", "arbok", "pikachu", "raichu", "sandshrew", "sandslash", "nidoranf", "nidorina", "nidoqueen", "nidoranm", "nidorino", "nidoking", "clefairy", "clefable", "vulpix", "ninetales", "jigglypuff", "wigglytuff", "zubat", "golbat", "oddish", "gloom", "vileplume", "paras", "parasect", "venonat", "venomoth", "diglett", "dugtrio", "meowth", "persian", "psyduck", "golduck", "mankey", "primeape", "growlithe", "arcanine", "poliwag", "poliwhirl", "poliwrath", "abra", "kadabra", "alakazam", "machop", "machoke", "machamp", "bellsprout", "weepinbell", "victreebel", "tentacool", "tentacruel", "geodude", "graveler", "golem", "ponyta", "rapidash", "slowpoke", "slowbro", "magnemite", "magneton", "farfetchd", "doduo", "dodrio", "seel", "dewgong", "grimer", "muk", "shellder", "cloyster", "gastly", "haunter", "gengar", "onix", "drowzee", "hypno", "krabby", "kingler", "voltorb", "electrode", "exeggcute", "exeggutor", "cubone", "marowak", "hitmonlee", "hitmonchan", "lickitung", "koffing", "weezing", "rhyhorn", "rhydon", "chansey", "tangela", "kangaskhan", "horsea", "seadra", "goldeen", "seaking", "staryu", "starmie", "mrmime", "scyther", "jynx", "electabuzz", "magmar", "pinsir", "tauros", "magikarp", "gyarados", "lapras", "ditto", "eevee", "vaporeon", "jolteon", "flareon", "porygon", "omanyte", "omastar", "kabuto", "kabutops", "aerodactyl", "snorlax", "articuno", "zapdos", "moltres", "dratini", "dragonair", "dragonite", "mewtwo", "mew", "chikorita", "bayleef", "meganium", "cyndaquil", "quilava", "typhlosion", "totodile", "croconaw", "feraligatr", "sentret", "furret", "hoothoot", "noctowl", "ledyba", "ledian", "spinarak", "ariados", "crobat", "chinchou", "lanturn", "pichu", "cleffa", "igglybuff", "togepi", "togetic", "natu", "xatu", "mareep", "flaaffy", "ampharos", "bellossom", "marill", "azumarill", "sudowoodo", "politoed", "hoppip", "skiploom", "jumpluff", "aipom", "sunkern", "sunflora", "yanma", "wooper", "quagsire", "espeon", "umbreon", "murkrow", "slowking", "misdreavus", "unown", "wobbuffet", "girafarig", "pineco", "forretress", "dunsparce", "gligar", "steelix", "snubbull", "granbull", "qwilfish", "scizor", "shuckle", "heracross", "sneasel", "teddiursa", "ursaring", "slugma", "magcargo", "swinub", "piloswine", "corsola", "remoraid", "octillery", "delibird", "mantine", "skarmory", "houndour", "houndoom", "kingdra", "phanpy", "donphan", "porygon2", "stantler", "smeargle", "tyrogue", "hitmontop", "smoochum", "elekid", "magby", "miltank", "blissey", "raikou", "entei", "suicune", "larvitar", "pupitar", "tyranitar", "lugia", "ho-oh", "celebi", "treecko", "grovyle", "sceptile", "torchic", "combusken", "blaziken", "mudkip", "marshtomp", "swampert", "poochyena", "mightyena", "zigzagoon", "linoone", "wurmple", "silcoon", "beautifly", "cascoon", "dustox", "lotad", "lombre", "ludicolo", "seedot", "nuzleaf", "shiftry", "taillow", "swellow", "wingull", "pelipper", "ralts", "kirlia", "gardevoir", "surskit", "masquerain", "shroomish", "breloom", "slakoth", "vigoroth", "slaking", "nincada", "ninjask", "shedinja", "whismur", "loudred", "exploud", "makuhita", "hariyama", "azurill", "nosepass", "skitty", "delcatty", "sableye", "mawile", "aron", "lairon", "aggron", "meditite", "medicham", "electrike", "manectric", "plusle", "minun", "volbeat", "illumise", "roselia", "gulpin", "swalot", "carvanha", "sharpedo", "wailmer", "wailord", "numel", "camerupt", "torkoal", "spoink", "grumpig", "spinda", "trapinch", "vibrava", "flygon", "cacnea", "cacturne", "swablu", "altaria", "zangoose", "seviper", "lunatone", "solrock", "barboach", "whiscash", "corphish", "crawdaunt", "baltoy", "claydol", "lileep", "cradily", "anorith", "armaldo", "feebas", "milotic", "castform", "kecleon", "shuppet", "banette", "duskull", "dusclops", "tropius", "chimecho", "absol", "wynaut", "snorunt", "glalie", "spheal", "sealeo", "walrein", "clamperl", "huntail", "gorebyss", "relicanth", "luvdisc", "bagon", "shelgon", "salamence", "beldum", "metang", "metagross", "regirock", "regice", "registeel", "latias", "latios", "kyogre", "groudon", "rayquaza", "jirachi", "deoxys", "turtwig", "grotle", "torterra", "chimchar", "monferno", "infernape", "piplup", "prinplup", "empoleon", "starly", "staravia", "staraptor", "bidoof", "bibarel", "kricketot", "kricketune", "shinx", "luxio", "luxray", "budew", "roserade", "cranidos", "rampardos", "shieldon", "bastiodon", "burmy", "wormadam", "mothim", "combee", "vespiquen", "pachirisu", "buizel", "floatzel", "cherubi", "cherrim", "shellos", "gastrodon", "ambipom", "drifloon", "drifblim", "buneary", "lopunny", "mismagius", "honchkrow", "glameow", "purugly", "chingling", "stunky", "skuntank", "bronzor", "bronzong", "bonsly", "mimejr", "happiny", "chatot", "spiritomb", "gible", "gabite", "garchomp", "munchlax", "riolu", "lucario", "hippopotas", "hippowdon", "skorupi", "drapion", "croagunk", "toxicroak", "carnivine", "finneon", "lumineon", "mantyke", "snover", "abomasnow", "weavile", "magnezone", "lickilicky", "rhyperior", "tangrowth", "electivire", "magmortar", "togekiss", "yanmega", "leafeon", "glaceon", "gliscor", "mamoswine", "porygon-z", "gallade", "probopass", "dusknoir", "froslass", "rotom", "uxie", "mesprit", "azelf", "dialga", "palkia", "heatran", "regigigas", "giratina", "cresselia", "phione", "manaphy", "darkrai", "shaymin", "arceus", "victini", "snivy", "servine", "serperior", "tepig", "pignite", "emboar", "oshawott", "dewott", "samurott", "patrat", "watchog", "lillipup", "herdier", "stoutland", "purrloin", "liepard", "pansage", "simisage", "pansear", "simisear", "panpour", "simipour", "munna", "musharna", "pidove", "tranquill", "unfezant", "blitzle", "zebstrika", "roggenrola", "boldore", "gigalith", "woobat", "swoobat", "drilbur", "excadrill", "audino", "timburr", "gurdurr", "conkeldurr", "tympole", "palpitoad", "seismitoad", "throh", "sawk", "sewaddle", "swadloon", "leavanny", "venipede", "whirlipede", "scolipede", "cottonee", "whimsicott", "petilil", "lilligant", "basculin", "sandile", "krokorok", "krookodile", "darumaka", "darmanitan", "maractus", "dwebble", "crustle", "scraggy", "scrafty", "sigilyph", "yamask", "cofagrigus", "tirtouga", "carracosta", "archen", "archeops", "trubbish", "garbodor", "zorua", "zoroark", "minccino", "cinccino", "gothita", "gothorita", "gothitelle", "solosis", "duosion", "reuniclus", "ducklett", "swanna", "vanillite", "vanillish", "vanilluxe", "deerling", "sawsbuck", "emolga", "karrablast", "escavalier", "foongus", "amoonguss", "frillish", "jellicent", "alomomola", "joltik", "galvantula", "ferroseed", "ferrothorn", "klink", "klang", "klinklang", "tynamo", "eelektrik", "eelektross", "elgyem", "beheeyem", "litwick", "lampent", "chandelure", "axew", "fraxure", "haxorus", "cubchoo", "beartic", "cryogonal", "shelmet", "accelgor", "stunfisk", "mienfoo", "mienshao", "druddigon", "golett", "golurk", "pawniard", "bisharp", "bouffalant", "rufflet", "braviary", "vullaby", "mandibuzz", "heatmor", "durant", "deino", "zweilous", "hydreigon", "larvesta", "volcarona", "cobalion", "terrakion", "virizion", "tornadus", "thundurus", "reshiram", "zekrom", "landorus", "kyurem", "keldeo", "meloetta", "genesect", "chespin", "quilladin", "chesnaught", "fennekin", "braixen", "delphox", "froakie", "frogadier", "greninja", "bunnelby", "diggersby", "fletchling", "fletchinder", "talonflame", "scatterbug", "spewpa", "vivillon", "litleo", "pyroar", "flabebe", "floette", "florges", "skiddo", "gogoat", "pancham", "pangoro", "furfrou", "espurr", "meowstic", "honedge", "doublade", "aegislash", "spritzee", "aromatisse", "swirlix", "slurpuff", "inkay", "malamar", "binacle", "barbaracle", "skrelp", "dragalge", "clauncher", "clawitzer", "helioptile", "heliolisk", "tyrunt", "tyrantrum", "amaura", "aurorus", "sylveon", "hawlucha", "dedenne", "carbink", "goomy", "sliggoo", "goodra", "klefki", "phantump", "trevenant", "pumpkaboo", "gourgeist", "bergmite", "avalugg", "noibat", "noivern", "xerneas", "yveltal", "zygarde", "diancie", "hoopa", "volcanion", "rowlet", "dartrix", "decidueye", "litten", "torracat", "incineroar", "popplio", "brionne", "primarina", "pikipek", "trumbeak", "toucannon", "yungoos", "gumshoos", "grubbin", "charjabug", "vikavolt", "crabrawler", "crabominable", "oricorio", "cutiefly", "ribombee", "rockruff", "lycanroc", "wishiwashi", "mareanie", "toxapex", "mudbray", "mudsdale", "dewpider", "araquanid", "fomantis", "lurantis", "morelull", "shiinotic", "salandit", "salazzle", "stufful", "bewear", "bounsweet", "steenee", "tsareena", "comfey", "oranguru", "passimian", "wimpod", "golisopod", "sandygast", "palossand", "pyukumuku", "typenull", "silvally", "minior", "komala", "turtonator", "togedemaru", "mimikyu", "bruxish", "drampa", "dhelmise", "jangmo-o", "hakamo-o", "kommo-o", "tapukoko", "tapulele", "tapubulu", "tapufini", "cosmog", "cosmoem", "solgaleo", "lunala", "nihilego", "buzzwole", "pheromosa", "xurkitree", "celesteela", "kartana", "guzzlord", "necrozma", "magearna", "marshadow", "poipole", "naganadel", "stakataka", "blacephalon", "zeraora", "meltan", "melmetal", "grookey", "thwackey", "rillaboom", "scorbunny", "raboot", "cinderace", "sobble", "drizzile", "inteleon", "skwovet", "greedent", "rookidee", "corvisquire", "corviknight", "blipbug", "dottler", "orbeetle", "nickit", "thievul", "gossifleur", "eldegoss", "wooloo", "dubwool", "chewtle", "drednaw", "yamper", "boltund", "rolycoly", "carkol", "coalossal", "applin", "flapple", "appletun", "silicobra", "sandaconda", "cramorant", "arrokuda", "barraskewda", "toxel", "toxtricity", "sizzlipede", "centiskorch", "clobbopus", "grapploct", "sinistea", "polteageist", "hatenna", "hattrem", "hatterene", "impidimp", "morgrem", "grimmsnarl", "obstagoon", "perrserker", "cursola", "sirfetchd", "mrrime", "runerigus", "milcery", "alcremie", "falinks", "pincurchin", "snom", "frosmoth", "stonjourner", "eiscue", "indeedee", "morpeko", "cufant", "copperajah", "dracozolt", "arctozolt", "dracovish", "arctovish", "duraludon", "dreepy", "drakloak", "dragapult", "zacian", "zamazenta", "eternatus", "kubfu", "urshifu", "zarude", "regieleki", "regidrago", "glastrier", "spectrier", "calyrex"]
        """
        return pulumi.get(self, "pokemon_name")


@pulumi.output_type
class SourcePolygonStockApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "stocksTicker":
            suggest = "stocks_ticker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePolygonStockApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePolygonStockApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePolygonStockApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 end_date: str,
                 multiplier: int,
                 start_date: str,
                 stocks_ticker: str,
                 timespan: str,
                 adjusted: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None):
        """
        :param str api_key: Your API ACCESS Key
        :param str end_date: The target date for the aggregate window.
        :param int multiplier: The size of the timespan multiplier.
        :param str start_date: The beginning date for the aggregate window.
        :param str stocks_ticker: The exchange symbol that this item is traded under.
        :param str timespan: The size of the time window.
        :param str adjusted: Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
        :param int limit: The target date for the aggregate window.
        :param str sort: Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "multiplier", multiplier)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "stocks_ticker", stocks_ticker)
        pulumi.set(__self__, "timespan", timespan)
        if adjusted is not None:
            pulumi.set(__self__, "adjusted", adjusted)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API ACCESS Key
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> str:
        """
        The target date for the aggregate window.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def multiplier(self) -> int:
        """
        The size of the timespan multiplier.
        """
        return pulumi.get(self, "multiplier")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The beginning date for the aggregate window.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="stocksTicker")
    def stocks_ticker(self) -> str:
        """
        The exchange symbol that this item is traded under.
        """
        return pulumi.get(self, "stocks_ticker")

    @property
    @pulumi.getter
    def timespan(self) -> str:
        """
        The size of the time window.
        """
        return pulumi.get(self, "timespan")

    @property
    @pulumi.getter
    def adjusted(self) -> Optional[str]:
        """
        Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
        """
        return pulumi.get(self, "adjusted")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The target date for the aggregate window.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class SourcePostgresConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"
        elif key == "replicationMethod":
            suggest = "replication_method"
        elif key == "sslMode":
            suggest = "ssl_mode"
        elif key == "tunnelMethod":
            suggest = "tunnel_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 password: Optional[str] = None,
                 port: Optional[int] = None,
                 replication_method: Optional['outputs.SourcePostgresConfigurationReplicationMethod'] = None,
                 schemas: Optional[Sequence[str]] = None,
                 ssl_mode: Optional['outputs.SourcePostgresConfigurationSslMode'] = None,
                 tunnel_method: Optional['outputs.SourcePostgresConfigurationTunnelMethod'] = None):
        """
        :param str database: Name of the database.
        :param str host: Hostname of the database.
        :param str username: Username to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        :param str password: Password associated with the username.
        :param int port: Port of the database. Default: 5432
        :param 'SourcePostgresConfigurationReplicationMethodArgs' replication_method: Configures how data is extracted from the database.
        :param Sequence[str] schemas: The list of schemas (case sensitive) to sync from. Defaults to public.
        :param 'SourcePostgresConfigurationSslModeArgs' ssl_mode: SSL connection modes. 
                 Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        :param 'SourcePostgresConfigurationTunnelMethodArgs' tunnel_method: Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if replication_method is not None:
            pulumi.set(__self__, "replication_method", replication_method)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if tunnel_method is not None:
            pulumi.set(__self__, "tunnel_method", tunnel_method)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Hostname of the database.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database. Default: 5432
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="replicationMethod")
    def replication_method(self) -> Optional['outputs.SourcePostgresConfigurationReplicationMethod']:
        """
        Configures how data is extracted from the database.
        """
        return pulumi.get(self, "replication_method")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence[str]]:
        """
        The list of schemas (case sensitive) to sync from. Defaults to public.
        """
        return pulumi.get(self, "schemas")

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional['outputs.SourcePostgresConfigurationSslMode']:
        """
        SSL connection modes. 
          Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
        """
        return pulumi.get(self, "ssl_mode")

    @property
    @pulumi.getter(name="tunnelMethod")
    def tunnel_method(self) -> Optional['outputs.SourcePostgresConfigurationTunnelMethod']:
        """
        Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
        """
        return pulumi.get(self, "tunnel_method")


@pulumi.output_type
class SourcePostgresConfigurationReplicationMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectChangesWithXminSystemColumn":
            suggest = "detect_changes_with_xmin_system_column"
        elif key == "readChangesUsingWriteAheadLogCdc":
            suggest = "read_changes_using_write_ahead_log_cdc"
        elif key == "scanChangesWithUserDefinedCursor":
            suggest = "scan_changes_with_user_defined_cursor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationReplicationMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationReplicationMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationReplicationMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detect_changes_with_xmin_system_column: Optional['outputs.SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumn'] = None,
                 read_changes_using_write_ahead_log_cdc: Optional['outputs.SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc'] = None,
                 scan_changes_with_user_defined_cursor: Optional['outputs.SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursor'] = None):
        """
        :param 'SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumnArgs' detect_changes_with_xmin_system_column: <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
        :param 'SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdcArgs' read_changes_using_write_ahead_log_cdc: <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
        :param 'SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursorArgs' scan_changes_with_user_defined_cursor: Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        if detect_changes_with_xmin_system_column is not None:
            pulumi.set(__self__, "detect_changes_with_xmin_system_column", detect_changes_with_xmin_system_column)
        if read_changes_using_write_ahead_log_cdc is not None:
            pulumi.set(__self__, "read_changes_using_write_ahead_log_cdc", read_changes_using_write_ahead_log_cdc)
        if scan_changes_with_user_defined_cursor is not None:
            pulumi.set(__self__, "scan_changes_with_user_defined_cursor", scan_changes_with_user_defined_cursor)

    @property
    @pulumi.getter(name="detectChangesWithXminSystemColumn")
    def detect_changes_with_xmin_system_column(self) -> Optional['outputs.SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumn']:
        """
        <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Only recommended for tables up to 500GB.
        """
        return pulumi.get(self, "detect_changes_with_xmin_system_column")

    @property
    @pulumi.getter(name="readChangesUsingWriteAheadLogCdc")
    def read_changes_using_write_ahead_log_cdc(self) -> Optional['outputs.SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc']:
        """
        <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
        """
        return pulumi.get(self, "read_changes_using_write_ahead_log_cdc")

    @property
    @pulumi.getter(name="scanChangesWithUserDefinedCursor")
    def scan_changes_with_user_defined_cursor(self) -> Optional['outputs.SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursor']:
        """
        Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
        """
        return pulumi.get(self, "scan_changes_with_user_defined_cursor")


@pulumi.output_type
class SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumn(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationSlot":
            suggest = "replication_slot"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "heartbeatActionQuery":
            suggest = "heartbeat_action_query"
        elif key == "initialWaitingSeconds":
            suggest = "initial_waiting_seconds"
        elif key == "invalidCdcCursorPositionBehavior":
            suggest = "invalid_cdc_cursor_position_behavior"
        elif key == "lsnCommitBehaviour":
            suggest = "lsn_commit_behaviour"
        elif key == "queueSize":
            suggest = "queue_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publication: str,
                 replication_slot: str,
                 additional_properties: Optional[str] = None,
                 heartbeat_action_query: Optional[str] = None,
                 initial_waiting_seconds: Optional[int] = None,
                 invalid_cdc_cursor_position_behavior: Optional[str] = None,
                 lsn_commit_behaviour: Optional[str] = None,
                 plugin: Optional[str] = None,
                 queue_size: Optional[int] = None):
        """
        :param str publication: A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
        :param str replication_slot: A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
        :param str additional_properties: Parsed as JSON.
        :param str heartbeat_action_query: Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting. Default: ""
        :param int initial_waiting_seconds: The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>. Default: 1200
        :param str invalid_cdc_cursor_position_behavior: Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        :param str lsn_commit_behaviour: Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync. must be one of ["While reading Data", "After loading Data in the destination"]; Default: "After loading Data in the destination"
        :param str plugin: A logical decoding plugin installed on the PostgreSQL server. must be one of ["pgoutput"]; Default: "pgoutput"
        :param int queue_size: The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        pulumi.set(__self__, "publication", publication)
        pulumi.set(__self__, "replication_slot", replication_slot)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if heartbeat_action_query is not None:
            pulumi.set(__self__, "heartbeat_action_query", heartbeat_action_query)
        if initial_waiting_seconds is not None:
            pulumi.set(__self__, "initial_waiting_seconds", initial_waiting_seconds)
        if invalid_cdc_cursor_position_behavior is not None:
            pulumi.set(__self__, "invalid_cdc_cursor_position_behavior", invalid_cdc_cursor_position_behavior)
        if lsn_commit_behaviour is not None:
            pulumi.set(__self__, "lsn_commit_behaviour", lsn_commit_behaviour)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if queue_size is not None:
            pulumi.set(__self__, "queue_size", queue_size)

    @property
    @pulumi.getter
    def publication(self) -> str:
        """
        A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
        """
        return pulumi.get(self, "publication")

    @property
    @pulumi.getter(name="replicationSlot")
    def replication_slot(self) -> str:
        """
        A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
        """
        return pulumi.get(self, "replication_slot")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="heartbeatActionQuery")
    def heartbeat_action_query(self) -> Optional[str]:
        """
        Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting. Default: ""
        """
        return pulumi.get(self, "heartbeat_action_query")

    @property
    @pulumi.getter(name="initialWaitingSeconds")
    def initial_waiting_seconds(self) -> Optional[int]:
        """
        The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-5-optional-set-up-initial-waiting-time">initial waiting time</a>. Default: 1200
        """
        return pulumi.get(self, "initial_waiting_seconds")

    @property
    @pulumi.getter(name="invalidCdcCursorPositionBehavior")
    def invalid_cdc_cursor_position_behavior(self) -> Optional[str]:
        """
        Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. must be one of ["Fail sync", "Re-sync data"]; Default: "Fail sync"
        """
        return pulumi.get(self, "invalid_cdc_cursor_position_behavior")

    @property
    @pulumi.getter(name="lsnCommitBehaviour")
    def lsn_commit_behaviour(self) -> Optional[str]:
        """
        Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync. must be one of ["While reading Data", "After loading Data in the destination"]; Default: "After loading Data in the destination"
        """
        return pulumi.get(self, "lsn_commit_behaviour")

    @property
    @pulumi.getter
    def plugin(self) -> Optional[str]:
        """
        A logical decoding plugin installed on the PostgreSQL server. must be one of ["pgoutput"]; Default: "pgoutput"
        """
        return pulumi.get(self, "plugin")

    @property
    @pulumi.getter(name="queueSize")
    def queue_size(self) -> Optional[int]:
        """
        The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
        """
        return pulumi.get(self, "queue_size")


@pulumi.output_type
class SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursor(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourcePostgresConfigurationSslMode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyCa":
            suggest = "verify_ca"
        elif key == "verifyFull":
            suggest = "verify_full"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslMode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslMode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslMode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow: Optional['outputs.SourcePostgresConfigurationSslModeAllow'] = None,
                 disable: Optional['outputs.SourcePostgresConfigurationSslModeDisable'] = None,
                 prefer: Optional['outputs.SourcePostgresConfigurationSslModePrefer'] = None,
                 require: Optional['outputs.SourcePostgresConfigurationSslModeRequire'] = None,
                 verify_ca: Optional['outputs.SourcePostgresConfigurationSslModeVerifyCa'] = None,
                 verify_full: Optional['outputs.SourcePostgresConfigurationSslModeVerifyFull'] = None):
        """
        :param 'SourcePostgresConfigurationSslModeAllowArgs' allow: Enables encryption only when required by the source database.
        :param 'SourcePostgresConfigurationSslModeDisableArgs' disable: Disables encryption of communication between Airbyte and source database.
        :param 'SourcePostgresConfigurationSslModePreferArgs' prefer: Allows unencrypted connection only if the source database does not support encryption.
        :param 'SourcePostgresConfigurationSslModeRequireArgs' require: Always require encryption. If the source database server does not support encryption, connection will fail.
        :param 'SourcePostgresConfigurationSslModeVerifyCaArgs' verify_ca: Always require encryption and verifies that the source database server has a valid SSL certificate.
        :param 'SourcePostgresConfigurationSslModeVerifyFullArgs' verify_full: This is the most secure mode. Always require encryption and verifies the identity of the source database server.
        """
        if allow is not None:
            pulumi.set(__self__, "allow", allow)
        if disable is not None:
            pulumi.set(__self__, "disable", disable)
        if prefer is not None:
            pulumi.set(__self__, "prefer", prefer)
        if require is not None:
            pulumi.set(__self__, "require", require)
        if verify_ca is not None:
            pulumi.set(__self__, "verify_ca", verify_ca)
        if verify_full is not None:
            pulumi.set(__self__, "verify_full", verify_full)

    @property
    @pulumi.getter
    def allow(self) -> Optional['outputs.SourcePostgresConfigurationSslModeAllow']:
        """
        Enables encryption only when required by the source database.
        """
        return pulumi.get(self, "allow")

    @property
    @pulumi.getter
    def disable(self) -> Optional['outputs.SourcePostgresConfigurationSslModeDisable']:
        """
        Disables encryption of communication between Airbyte and source database.
        """
        return pulumi.get(self, "disable")

    @property
    @pulumi.getter
    def prefer(self) -> Optional['outputs.SourcePostgresConfigurationSslModePrefer']:
        """
        Allows unencrypted connection only if the source database does not support encryption.
        """
        return pulumi.get(self, "prefer")

    @property
    @pulumi.getter
    def require(self) -> Optional['outputs.SourcePostgresConfigurationSslModeRequire']:
        """
        Always require encryption. If the source database server does not support encryption, connection will fail.
        """
        return pulumi.get(self, "require")

    @property
    @pulumi.getter(name="verifyCa")
    def verify_ca(self) -> Optional['outputs.SourcePostgresConfigurationSslModeVerifyCa']:
        """
        Always require encryption and verifies that the source database server has a valid SSL certificate.
        """
        return pulumi.get(self, "verify_ca")

    @property
    @pulumi.getter(name="verifyFull")
    def verify_full(self) -> Optional['outputs.SourcePostgresConfigurationSslModeVerifyFull']:
        """
        This is the most secure mode. Always require encryption and verifies the identity of the source database server.
        """
        return pulumi.get(self, "verify_full")


@pulumi.output_type
class SourcePostgresConfigurationSslModeAllow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslModeAllow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslModeAllow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslModeAllow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[str] = None):
        """
        :param str additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourcePostgresConfigurationSslModeDisable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslModeDisable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslModeDisable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslModeDisable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[str] = None):
        """
        :param str additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourcePostgresConfigurationSslModePrefer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslModePrefer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslModePrefer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslModePrefer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[str] = None):
        """
        :param str additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourcePostgresConfigurationSslModeRequire(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslModeRequire. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslModeRequire.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslModeRequire.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[str] = None):
        """
        :param str additional_properties: Parsed as JSON.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourcePostgresConfigurationSslModeVerifyCa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslModeVerifyCa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslModeVerifyCa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslModeVerifyCa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 additional_properties: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str additional_properties: Parsed as JSON.
        :param str client_certificate: Client certificate
        :param str client_key: Client key
        :param str client_key_password: Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class SourcePostgresConfigurationSslModeVerifyFull(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeyPassword":
            suggest = "client_key_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationSslModeVerifyFull. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationSslModeVerifyFull.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationSslModeVerifyFull.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: str,
                 additional_properties: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 client_key: Optional[str] = None,
                 client_key_password: Optional[str] = None):
        """
        :param str ca_certificate: CA certificate
        :param str additional_properties: Parsed as JSON.
        :param str client_certificate: Client certificate
        :param str client_key: Client key
        :param str client_key_password: Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        pulumi.set(__self__, "ca_certificate", ca_certificate)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_password is not None:
            pulumi.set(__self__, "client_key_password", client_key_password)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> str:
        """
        CA certificate
        """
        return pulumi.get(self, "ca_certificate")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Client certificate
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[str]:
        """
        Client key
        """
        return pulumi.get(self, "client_key")

    @property
    @pulumi.getter(name="clientKeyPassword")
    def client_key_password(self) -> Optional[str]:
        """
        Password for keystorage. If you do not add it - the password will be generated automatically.
        """
        return pulumi.get(self, "client_key_password")


@pulumi.output_type
class SourcePostgresConfigurationTunnelMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noTunnel":
            suggest = "no_tunnel"
        elif key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationTunnelMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationTunnelMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationTunnelMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 no_tunnel: Optional['outputs.SourcePostgresConfigurationTunnelMethodNoTunnel'] = None,
                 password_authentication: Optional['outputs.SourcePostgresConfigurationTunnelMethodPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.SourcePostgresConfigurationTunnelMethodSshKeyAuthentication'] = None):
        if no_tunnel is not None:
            pulumi.set(__self__, "no_tunnel", no_tunnel)
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="noTunnel")
    def no_tunnel(self) -> Optional['outputs.SourcePostgresConfigurationTunnelMethodNoTunnel']:
        return pulumi.get(self, "no_tunnel")

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.SourcePostgresConfigurationTunnelMethodPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.SourcePostgresConfigurationTunnelMethodSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class SourcePostgresConfigurationTunnelMethodNoTunnel(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourcePostgresConfigurationTunnelMethodPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelUserPassword":
            suggest = "tunnel_user_password"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationTunnelMethodPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationTunnelMethodPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_user_password: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host
        :param str tunnel_user_password: OS-level password for logging into the jump server host
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        pulumi.set(__self__, "tunnel_user_password", tunnel_user_password)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelUserPassword")
    def tunnel_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "tunnel_user_password")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourcePostgresConfigurationTunnelMethodSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tunnelHost":
            suggest = "tunnel_host"
        elif key == "tunnelUser":
            suggest = "tunnel_user"
        elif key == "tunnelPort":
            suggest = "tunnel_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresConfigurationTunnelMethodSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresConfigurationTunnelMethodSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key: str,
                 tunnel_host: str,
                 tunnel_user: str,
                 tunnel_port: Optional[int] = None):
        """
        :param str ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        :param str tunnel_host: Hostname of the jump server host that allows inbound ssh tunnel.
        :param str tunnel_user: OS-level username for logging into the jump server host.
        :param int tunnel_port: Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "tunnel_host", tunnel_host)
        pulumi.set(__self__, "tunnel_user", tunnel_user)
        if tunnel_port is not None:
            pulumi.set(__self__, "tunnel_port", tunnel_port)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tunnelHost")
    def tunnel_host(self) -> str:
        """
        Hostname of the jump server host that allows inbound ssh tunnel.
        """
        return pulumi.get(self, "tunnel_host")

    @property
    @pulumi.getter(name="tunnelUser")
    def tunnel_user(self) -> str:
        """
        OS-level username for logging into the jump server host.
        """
        return pulumi.get(self, "tunnel_user")

    @property
    @pulumi.getter(name="tunnelPort")
    def tunnel_port(self) -> Optional[int]:
        """
        Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
        """
        return pulumi.get(self, "tunnel_port")


@pulumi.output_type
class SourcePosthogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "baseUrl":
            suggest = "base_url"
        elif key == "eventsTimeStep":
            suggest = "events_time_step"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePosthogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePosthogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePosthogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str,
                 base_url: Optional[str] = None,
                 events_time_step: Optional[int] = None):
        """
        :param str api_key: API Key. See the <a href="https://docs.airbyte.com/integrations/sources/posthog">docs</a> for information on how to generate this key.
        :param str start_date: The date from which you'd like to replicate the data. Any data before this date will not be replicated.
        :param str base_url: Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com). Default: "https://app.posthog.com"
        :param int events_time_step: Set lower value in case of failing long running sync of events stream. Default: 30
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if events_time_step is not None:
            pulumi.set(__self__, "events_time_step", events_time_step)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key. See the <a href="https://docs.airbyte.com/integrations/sources/posthog">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate the data. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[str]:
        """
        Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com). Default: "https://app.posthog.com"
        """
        return pulumi.get(self, "base_url")

    @property
    @pulumi.getter(name="eventsTimeStep")
    def events_time_step(self) -> Optional[int]:
        """
        Set lower value in case of failing long running sync of events stream. Default: 30
        """
        return pulumi.get(self, "events_time_step")


@pulumi.output_type
class SourcePostmarkappConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xPostmarkAccountToken":
            suggest = "x_postmark_account_token"
        elif key == "xPostmarkServerToken":
            suggest = "x_postmark_server_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostmarkappConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostmarkappConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostmarkappConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x_postmark_account_token: str,
                 x_postmark_server_token: str):
        """
        :param str x_postmark_account_token: API Key for account
        :param str x_postmark_server_token: API Key for server
        """
        pulumi.set(__self__, "x_postmark_account_token", x_postmark_account_token)
        pulumi.set(__self__, "x_postmark_server_token", x_postmark_server_token)

    @property
    @pulumi.getter(name="xPostmarkAccountToken")
    def x_postmark_account_token(self) -> str:
        """
        API Key for account
        """
        return pulumi.get(self, "x_postmark_account_token")

    @property
    @pulumi.getter(name="xPostmarkServerToken")
    def x_postmark_server_token(self) -> str:
        """
        API Key for server
        """
        return pulumi.get(self, "x_postmark_server_token")


@pulumi.output_type
class SourcePrestashopConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePrestashopConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePrestashopConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePrestashopConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 start_date: str,
                 url: str):
        """
        :param str access_key: Your PrestaShop access key. See <a href="https://devdocs.prestashop.com/1.7/webservice/tutorials/creating-access/#create-an-access-key"> the docs </a> for info on how to obtain this.
        :param str start_date: The Start date in the format YYYY-MM-DD.
        :param str url: Shop URL without trailing slash.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        Your PrestaShop access key. See <a href="https://devdocs.prestashop.com/1.7/webservice/tutorials/creating-access/#create-an-access-key"> the docs </a> for info on how to obtain this.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The Start date in the format YYYY-MM-DD.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Shop URL without trailing slash.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SourcePunkApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brewedAfter":
            suggest = "brewed_after"
        elif key == "brewedBefore":
            suggest = "brewed_before"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePunkApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePunkApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePunkApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 brewed_after: str,
                 brewed_before: str,
                 id: Optional[str] = None):
        """
        :param str brewed_after: To extract specific data with Unique ID
        :param str brewed_before: To extract specific data with Unique ID
        :param str id: To extract specific data with Unique ID
        """
        pulumi.set(__self__, "brewed_after", brewed_after)
        pulumi.set(__self__, "brewed_before", brewed_before)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="brewedAfter")
    def brewed_after(self) -> str:
        """
        To extract specific data with Unique ID
        """
        return pulumi.get(self, "brewed_after")

    @property
    @pulumi.getter(name="brewedBefore")
    def brewed_before(self) -> str:
        """
        To extract specific data with Unique ID
        """
        return pulumi.get(self, "brewed_before")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        To extract specific data with Unique ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SourcePypiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectName":
            suggest = "project_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePypiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePypiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePypiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_name: str,
                 version: Optional[str] = None):
        """
        :param str project_name: Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
        :param str version: Version of the project/package.  Use it to find a particular release instead of all releases.
        """
        pulumi.set(__self__, "project_name", project_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> str:
        """
        Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
        """
        return pulumi.get(self, "project_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the project/package.  Use it to find a particular release instead of all releases.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SourceQualarooConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "surveyIds":
            suggest = "survey_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceQualarooConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceQualarooConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceQualarooConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 start_date: str,
                 token: str,
                 survey_ids: Optional[Sequence[str]] = None):
        """
        :param str key: A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param str token: A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        :param Sequence[str] survey_ids: IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)
        if survey_ids is not None:
            pulumi.set(__self__, "survey_ids", survey_ids)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="surveyIds")
    def survey_ids(self) -> Optional[Sequence[str]]:
        """
        IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
        """
        return pulumi.get(self, "survey_ids")


@pulumi.output_type
class SourceRailzConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRailzConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRailzConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRailzConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 secret_key: str,
                 start_date: str):
        """
        :param str client_id: Client ID (client_id)
        :param str secret_key: Secret key (secret_key)
        :param str start_date: Start date
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client ID (client_id)
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Secret key (secret_key)
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start date
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceRechargeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "useOrdersDeprecatedApi":
            suggest = "use_orders_deprecated_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRechargeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRechargeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRechargeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 start_date: str,
                 use_orders_deprecated_api: Optional[bool] = None):
        """
        :param str access_token: The value of the Access Token generated. See the <a href="https://docs.airbyte.com/integrations/sources/recharge">docs</a> for more information.
        :param str start_date: The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
        :param bool use_orders_deprecated_api: Define whether or not the `Orders` stream should use the deprecated `2021-01` API version, or use `2021-11`, otherwise. Default: true
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "start_date", start_date)
        if use_orders_deprecated_api is not None:
            pulumi.set(__self__, "use_orders_deprecated_api", use_orders_deprecated_api)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The value of the Access Token generated. See the <a href="https://docs.airbyte.com/integrations/sources/recharge">docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="useOrdersDeprecatedApi")
    def use_orders_deprecated_api(self) -> Optional[bool]:
        """
        Define whether or not the `Orders` stream should use the deprecated `2021-01` API version, or use `2021-11`, otherwise. Default: true
        """
        return pulumi.get(self, "use_orders_deprecated_api")


@pulumi.output_type
class SourceRecreationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryCampsites":
            suggest = "query_campsites"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRecreationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRecreationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRecreationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apikey: str,
                 query_campsites: Optional[str] = None):
        """
        :param str apikey: API Key
        """
        pulumi.set(__self__, "apikey", apikey)
        if query_campsites is not None:
            pulumi.set(__self__, "query_campsites", query_campsites)

    @property
    @pulumi.getter
    def apikey(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "apikey")

    @property
    @pulumi.getter(name="queryCampsites")
    def query_campsites(self) -> Optional[str]:
        return pulumi.get(self, "query_campsites")


@pulumi.output_type
class SourceRecruiteeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "companyId":
            suggest = "company_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRecruiteeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRecruiteeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRecruiteeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 company_id: int):
        """
        :param str api_key: Recruitee API Key. See <a href="https://docs.recruitee.com/reference/getting-started#generate-api-token">here</a>.
        :param int company_id: Recruitee Company ID. You can also find this ID on the <a href="https://app.recruitee.com/#/settings/api_tokens">Recruitee API tokens page</a>.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "company_id", company_id)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Recruitee API Key. See <a href="https://docs.recruitee.com/reference/getting-started#generate-api-token">here</a>.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="companyId")
    def company_id(self) -> int:
        """
        Recruitee Company ID. You can also find this ID on the <a href="https://app.recruitee.com/#/settings/api_tokens">Recruitee API tokens page</a>.
        """
        return pulumi.get(self, "company_id")


@pulumi.output_type
class SourceRecurlyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "beginTime":
            suggest = "begin_time"
        elif key == "endTime":
            suggest = "end_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRecurlyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRecurlyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRecurlyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 begin_time: Optional[str] = None,
                 end_time: Optional[str] = None):
        """
        :param str api_key: Recurly API Key. See the  <a href="https://docs.airbyte.com/integrations/sources/recurly">docs</a> for more information on how to generate this key.
        :param str begin_time: ISO8601 timestamp from which the replication from Recurly API will start from.
        :param str end_time: ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
        """
        pulumi.set(__self__, "api_key", api_key)
        if begin_time is not None:
            pulumi.set(__self__, "begin_time", begin_time)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Recurly API Key. See the  <a href="https://docs.airbyte.com/integrations/sources/recurly">docs</a> for more information on how to generate this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="beginTime")
    def begin_time(self) -> Optional[str]:
        """
        ISO8601 timestamp from which the replication from Recurly API will start from.
        """
        return pulumi.get(self, "begin_time")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
        """
        return pulumi.get(self, "end_time")


@pulumi.output_type
class SourceRedshiftConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRedshiftConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRedshiftConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRedshiftConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 password: str,
                 username: str,
                 jdbc_url_params: Optional[str] = None,
                 port: Optional[int] = None,
                 schemas: Optional[Sequence[str]] = None):
        """
        :param str database: Name of the database.
        :param str host: Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
        :param str password: Password associated with the username.
        :param str username: Username to use to access the database.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param int port: Port of the database. Default: 5439
        :param Sequence[str] schemas: The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        Name of the database.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use to access the database.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port of the database. Default: 5439
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence[str]]:
        """
        The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
        """
        return pulumi.get(self, "schemas")


@pulumi.output_type
class SourceRetentlyConfiguration(dict):
    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceRetentlyConfigurationCredentials'] = None):
        """
        :param 'SourceRetentlyConfigurationCredentialsArgs' credentials: Choose how to authenticate to Retently
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceRetentlyConfigurationCredentials']:
        """
        Choose how to authenticate to Retently
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceRetentlyConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaRetentlyOAuth":
            suggest = "authenticate_via_retently_o_auth"
        elif key == "authenticateWithApiToken":
            suggest = "authenticate_with_api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRetentlyConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRetentlyConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRetentlyConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_retently_o_auth: Optional['outputs.SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth'] = None,
                 authenticate_with_api_token: Optional['outputs.SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken'] = None):
        if authenticate_via_retently_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_retently_o_auth", authenticate_via_retently_o_auth)
        if authenticate_with_api_token is not None:
            pulumi.set(__self__, "authenticate_with_api_token", authenticate_with_api_token)

    @property
    @pulumi.getter(name="authenticateViaRetentlyOAuth")
    def authenticate_via_retently_o_auth(self) -> Optional['outputs.SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth']:
        return pulumi.get(self, "authenticate_via_retently_o_auth")

    @property
    @pulumi.getter(name="authenticateWithApiToken")
    def authenticate_with_api_token(self) -> Optional['outputs.SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken']:
        return pulumi.get(self, "authenticate_with_api_token")


@pulumi.output_type
class SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 additional_properties: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Retently developer application.
        :param str client_secret: The Client Secret of your Retently developer application.
        :param str refresh_token: Retently Refresh Token which can be used to fetch new Bearer Tokens when the current one expires.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Retently developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Retently developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Retently Refresh Token which can be used to fetch new Bearer Tokens when the current one expires.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 additional_properties: Optional[str] = None):
        """
        :param str api_key: Retently API Token. See the <a href="https://app.retently.com/settings/api/tokens">docs</a> for more information on how to obtain this key.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_key", api_key)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Retently API Token. See the <a href="https://app.retently.com/settings/api/tokens">docs</a> for more information on how to obtain this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceRkiCovidConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceRkiCovidConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceRkiCovidConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceRkiCovidConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str):
        """
        :param str start_date: UTC date in the format 2017-01-25. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date in the format 2017-01-25. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceRssConfiguration(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: RSS Feed URL
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        RSS Feed URL
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SourceS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "pathPattern":
            suggest = "path_pattern"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 streams: Sequence['outputs.SourceS3ConfigurationStream'],
                 aws_access_key_id: Optional[str] = None,
                 aws_secret_access_key: Optional[str] = None,
                 dataset: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 format: Optional['outputs.SourceS3ConfigurationFormat'] = None,
                 path_pattern: Optional[str] = None,
                 provider: Optional['outputs.SourceS3ConfigurationProvider'] = None,
                 region_name: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 schema: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str bucket: Name of the S3 bucket where the file(s) exist.
        :param Sequence['SourceS3ConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str aws_access_key_id: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param str aws_secret_access_key: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param str dataset: Deprecated and will be removed soon. Please do not use this field anymore and use streams.name instead. The name of the stream you would like this source to output. Can contain letters, numbers, or underscores.
        :param str endpoint: Endpoint to an S3 compatible service. Leave empty to use AWS. The custom endpoint must be secure, but the 'https' prefix is not required. Default: ""
        :param 'SourceS3ConfigurationFormatArgs' format: Deprecated and will be removed soon. Please do not use this field anymore and use streams.format instead. The format of the files you'd like to replicate
        :param str path_pattern: Deprecated and will be removed soon. Please do not use this field anymore and use streams.globs instead. A regular expression which tells the connector which files to replicate. All files which match this pattern will be replicated. Use | to separate multiple patterns. See <a href="https://facelessuser.github.io/wcmatch/glob/" target="_blank">this page</a> to understand pattern syntax (GLOBSTAR and SPLIT flags are enabled). Use pattern <strong>**</strong> to pick up all files.
        :param 'SourceS3ConfigurationProviderArgs' provider: Deprecated and will be removed soon. Please do not use this field anymore and use bucket, aws_access_key_id, aws_secret_access_key and endpoint instead. Use this to load files from S3 or S3-compatible services
        :param str region_name: AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        :param str role_arn: Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        :param str schema: Deprecated and will be removed soon. Please do not use this field anymore and use streams.input_schema instead. Optionally provide a schema to enforce, as a valid JSON string. Ensure this is a mapping of <strong>{ "column" : "type" }</strong>, where types are valid <a href="https://json-schema.org/understanding-json-schema/reference/type.html" target="_blank">JSON Schema datatypes</a>. Leave as {} to auto-infer the schema. Default: "{}"
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "streams", streams)
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if path_pattern is not None:
            pulumi.set(__self__, "path_pattern", path_pattern)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the S3 bucket where the file(s) exist.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceS3ConfigurationStream']:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[str]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[str]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @property
    @pulumi.getter
    def dataset(self) -> Optional[str]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.name instead. The name of the stream you would like this source to output. Can contain letters, numbers, or underscores.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Endpoint to an S3 compatible service. Leave empty to use AWS. The custom endpoint must be secure, but the 'https' prefix is not required. Default: ""
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def format(self) -> Optional['outputs.SourceS3ConfigurationFormat']:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.format instead. The format of the files you'd like to replicate
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="pathPattern")
    def path_pattern(self) -> Optional[str]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.globs instead. A regular expression which tells the connector which files to replicate. All files which match this pattern will be replicated. Use | to separate multiple patterns. See <a href="https://facelessuser.github.io/wcmatch/glob/" target="_blank">this page</a> to understand pattern syntax (GLOBSTAR and SPLIT flags are enabled). Use pattern <strong>**</strong> to pick up all files.
        """
        return pulumi.get(self, "path_pattern")

    @property
    @pulumi.getter
    def provider(self) -> Optional['outputs.SourceS3ConfigurationProvider']:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use bucket, aws_access_key_id, aws_secret_access_key and endpoint instead. Use this to load files from S3 or S3-compatible services
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        Deprecated and will be removed soon. Please do not use this field anymore and use streams.input_schema instead. Optionally provide a schema to enforce, as a valid JSON string. Ensure this is a mapping of <strong>{ "column" : "type" }</strong>, where types are valid <a href="https://json-schema.org/understanding-json-schema/reference/type.html" target="_blank">JSON Schema datatypes</a>. Leave as {} to auto-infer the schema. Default: "{}"
        """
        return pulumi.get(self, "schema")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceS3ConfigurationFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceS3ConfigurationFormatAvro'] = None,
                 csv: Optional['outputs.SourceS3ConfigurationFormatCsv'] = None,
                 jsonl: Optional['outputs.SourceS3ConfigurationFormatJsonl'] = None,
                 parquet: Optional['outputs.SourceS3ConfigurationFormatParquet'] = None):
        """
        :param 'SourceS3ConfigurationFormatAvroArgs' avro: This connector utilises <a href="https://fastavro.readthedocs.io/en/latest/" target="_blank">fastavro</a> for Avro parsing.
        :param 'SourceS3ConfigurationFormatCsvArgs' csv: This connector utilises <a href="https: // arrow.apache.org/docs/python/generated/pyarrow.csv.open_csv.html" target="_blank">PyArrow (Apache Arrow)</a> for CSV parsing.
        :param 'SourceS3ConfigurationFormatJsonlArgs' jsonl: This connector uses <a href="https://arrow.apache.org/docs/python/json.html" target="_blank">PyArrow</a> for JSON Lines (jsonl) file parsing.
        :param 'SourceS3ConfigurationFormatParquetArgs' parquet: This connector utilises <a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetFile.html" target="_blank">PyArrow (Apache Arrow)</a> for Parquet parsing.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if jsonl is not None:
            pulumi.set(__self__, "jsonl", jsonl)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceS3ConfigurationFormatAvro']:
        """
        This connector utilises <a href="https://fastavro.readthedocs.io/en/latest/" target="_blank">fastavro</a> for Avro parsing.
        """
        return pulumi.get(self, "avro")

    @property
    @pulumi.getter
    def csv(self) -> Optional['outputs.SourceS3ConfigurationFormatCsv']:
        """
        This connector utilises <a href="https: // arrow.apache.org/docs/python/generated/pyarrow.csv.open_csv.html" target="_blank">PyArrow (Apache Arrow)</a> for CSV parsing.
        """
        return pulumi.get(self, "csv")

    @property
    @pulumi.getter
    def jsonl(self) -> Optional['outputs.SourceS3ConfigurationFormatJsonl']:
        """
        This connector uses <a href="https://arrow.apache.org/docs/python/json.html" target="_blank">PyArrow</a> for JSON Lines (jsonl) file parsing.
        """
        return pulumi.get(self, "jsonl")

    @property
    @pulumi.getter
    def parquet(self) -> Optional['outputs.SourceS3ConfigurationFormatParquet']:
        """
        This connector utilises <a href="https://arrow.apache.org/docs/python/generated/pyarrow.parquet.ParquetFile.html" target="_blank">PyArrow (Apache Arrow)</a> for Parquet parsing.
        """
        return pulumi.get(self, "parquet")


@pulumi.output_type
class SourceS3ConfigurationFormatAvro(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceS3ConfigurationFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalReaderOptions":
            suggest = "additional_reader_options"
        elif key == "advancedOptions":
            suggest = "advanced_options"
        elif key == "blockSize":
            suggest = "block_size"
        elif key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "inferDatatypes":
            suggest = "infer_datatypes"
        elif key == "newlinesInValues":
            suggest = "newlines_in_values"
        elif key == "quoteChar":
            suggest = "quote_char"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_reader_options: Optional[str] = None,
                 advanced_options: Optional[str] = None,
                 block_size: Optional[int] = None,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 infer_datatypes: Optional[bool] = None,
                 newlines_in_values: Optional[bool] = None,
                 quote_char: Optional[str] = None):
        """
        :param str additional_reader_options: Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank">detailed here</a>. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
        :param str advanced_options: Optionally add a valid JSON string here to provide additional <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank">Pyarrow ReadOptions</a>. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
        :param int block_size: The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 10000
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param bool infer_datatypes: Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings. Default: true
        :param bool newlines_in_values: Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False. Default: false
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        if additional_reader_options is not None:
            pulumi.set(__self__, "additional_reader_options", additional_reader_options)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if infer_datatypes is not None:
            pulumi.set(__self__, "infer_datatypes", infer_datatypes)
        if newlines_in_values is not None:
            pulumi.set(__self__, "newlines_in_values", newlines_in_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)

    @property
    @pulumi.getter(name="additionalReaderOptions")
    def additional_reader_options(self) -> Optional[str]:
        """
        Optionally add a valid JSON string here to provide additional options to the csv reader. Mappings must correspond to options <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ConvertOptions.html#pyarrow.csv.ConvertOptions" target="_blank">detailed here</a>. 'column_types' is used internally to handle schema so overriding that would likely cause problems.
        """
        return pulumi.get(self, "additional_reader_options")

    @property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[str]:
        """
        Optionally add a valid JSON string here to provide additional <a href="https://arrow.apache.org/docs/python/generated/pyarrow.csv.ReadOptions.html#pyarrow.csv.ReadOptions" target="_blank">Pyarrow ReadOptions</a>. Specify 'column_names' here if your CSV doesn't have header, or if you want to use custom column names. 'block_size' and 'encoding' are already used above, specify them again here will override the values above.
        """
        return pulumi.get(self, "advanced_options")

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[int]:
        """
        The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 10000
        """
        return pulumi.get(self, "block_size")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="inferDatatypes")
    def infer_datatypes(self) -> Optional[bool]:
        """
        Configures whether a schema for the source should be inferred from the current data or not. If set to false and a custom schema is set, then the manually enforced schema is used. If a schema is not manually set, and this is set to false, then all fields will be read as strings. Default: true
        """
        return pulumi.get(self, "infer_datatypes")

    @property
    @pulumi.getter(name="newlinesInValues")
    def newlines_in_values(self) -> Optional[bool]:
        """
        Whether newline characters are allowed in CSV values. Turning this on may affect performance. Leave blank to default to False. Default: false
        """
        return pulumi.get(self, "newlines_in_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")


@pulumi.output_type
class SourceS3ConfigurationFormatJsonl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockSize":
            suggest = "block_size"
        elif key == "newlinesInValues":
            suggest = "newlines_in_values"
        elif key == "unexpectedFieldBehavior":
            suggest = "unexpected_field_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationFormatJsonl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationFormatJsonl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationFormatJsonl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_size: Optional[int] = None,
                 newlines_in_values: Optional[bool] = None,
                 unexpected_field_behavior: Optional[str] = None):
        """
        :param int block_size: The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 0
        :param bool newlines_in_values: Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False. Default: false
        :param str unexpected_field_behavior: How JSON fields outside of explicit_schema (if given) are treated. Check <a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank">PyArrow documentation</a> for details. must be one of ["ignore", "infer", "error"]; Default: "infer"
        """
        if block_size is not None:
            pulumi.set(__self__, "block_size", block_size)
        if newlines_in_values is not None:
            pulumi.set(__self__, "newlines_in_values", newlines_in_values)
        if unexpected_field_behavior is not None:
            pulumi.set(__self__, "unexpected_field_behavior", unexpected_field_behavior)

    @property
    @pulumi.getter(name="blockSize")
    def block_size(self) -> Optional[int]:
        """
        The chunk size in bytes to process at a time in memory from each file. If your data is particularly wide and failing during schema detection, increasing this should solve it. Beware of raising this too high as you could hit OOM errors. Default: 0
        """
        return pulumi.get(self, "block_size")

    @property
    @pulumi.getter(name="newlinesInValues")
    def newlines_in_values(self) -> Optional[bool]:
        """
        Whether newline characters are allowed in JSON values. Turning this on may affect performance. Leave blank to default to False. Default: false
        """
        return pulumi.get(self, "newlines_in_values")

    @property
    @pulumi.getter(name="unexpectedFieldBehavior")
    def unexpected_field_behavior(self) -> Optional[str]:
        """
        How JSON fields outside of explicit_schema (if given) are treated. Check <a href="https://arrow.apache.org/docs/python/generated/pyarrow.json.ParseOptions.html" target="_blank">PyArrow documentation</a> for details. must be one of ["ignore", "infer", "error"]; Default: "infer"
        """
        return pulumi.get(self, "unexpected_field_behavior")


@pulumi.output_type
class SourceS3ConfigurationFormatParquet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSize":
            suggest = "batch_size"
        elif key == "bufferSize":
            suggest = "buffer_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationFormatParquet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationFormatParquet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationFormatParquet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size: Optional[int] = None,
                 buffer_size: Optional[int] = None,
                 columns: Optional[Sequence[str]] = None):
        """
        :param int batch_size: Maximum number of records per batch read from the input files. Batches may be smaller if there aren’t enough rows in the file. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 65536
        :param int buffer_size: Perform read buffering when deserializing individual column chunks. By default every group column will be loaded fully to memory. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 2
        :param Sequence[str] columns: If you only want to sync a subset of the columns from the file(s), add the columns you want here as a comma-delimited list. Leave it empty to sync all columns.
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if buffer_size is not None:
            pulumi.set(__self__, "buffer_size", buffer_size)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[int]:
        """
        Maximum number of records per batch read from the input files. Batches may be smaller if there aren’t enough rows in the file. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 65536
        """
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> Optional[int]:
        """
        Perform read buffering when deserializing individual column chunks. By default every group column will be loaded fully to memory. This option can help avoid out-of-memory errors if your data is particularly wide. Default: 2
        """
        return pulumi.get(self, "buffer_size")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        If you only want to sync a subset of the columns from the file(s), add the columns you want here as a comma-delimited list. Leave it empty to sync all columns.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class SourceS3ConfigurationProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: Optional[str] = None,
                 aws_secret_access_key: Optional[str] = None,
                 bucket: Optional[str] = None,
                 endpoint: Optional[str] = None,
                 path_prefix: Optional[str] = None,
                 region_name: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str aws_access_key_id: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param str aws_secret_access_key: In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        :param str bucket: Name of the S3 bucket where the file(s) exist.
        :param str endpoint: Endpoint to an S3 compatible service. Leave empty to use AWS. Default: ""
        :param str path_prefix: By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate. Default: ""
        :param str region_name: AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        :param str role_arn: Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[str]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[str]:
        """
        In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        """
        Name of the S3 bucket where the file(s) exist.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        """
        Endpoint to an S3 compatible service. Leave empty to use AWS. Default: ""
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[str]:
        """
        By providing a path-like prefix (e.g. myFolder/thisTable/) under which all the relevant files sit, we can optimize finding these in S3. This is optional but recommended if your bucket contains many folders/files which you don't need to replicate. Default: ""
        """
        return pulumi.get(self, "path_prefix")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceS3ConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "legacyPrefix":
            suggest = "legacy_prefix"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceS3ConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 legacy_prefix: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceS3ConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str legacy_prefix: The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceS3ConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[str]:
        """
        The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceS3ConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFormat":
            suggest = "avro_format"
        elif key == "csvFormat":
            suggest = "csv_format"
        elif key == "documentFileTypeFormatExperimental":
            suggest = "document_file_type_format_experimental"
        elif key == "jsonlFormat":
            suggest = "jsonl_format"
        elif key == "parquetFormat":
            suggest = "parquet_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_format: Optional['outputs.SourceS3ConfigurationStreamFormatAvroFormat'] = None,
                 csv_format: Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormat'] = None,
                 document_file_type_format_experimental: Optional['outputs.SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental'] = None,
                 jsonl_format: Optional['outputs.SourceS3ConfigurationStreamFormatJsonlFormat'] = None,
                 parquet_format: Optional['outputs.SourceS3ConfigurationStreamFormatParquetFormat'] = None):
        """
        :param 'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs' document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatAvroFormat']:
        return pulumi.get(self, "avro_format")

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental']:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatJsonlFormat']:
        return pulumi.get(self, "jsonl_format")

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatParquetFormat']:
        return pulumi.get(self, "parquet_format")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatAvroFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleAsString":
            suggest = "double_as_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormatAvroFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_as_string: Optional[bool] = None):
        """
        :param bool double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[bool]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "ignoreErrorsOnFieldsMismatch":
            suggest = "ignore_errors_on_fields_mismatch"
        elif key == "inferenceType":
            suggest = "inference_type"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 ignore_errors_on_fields_mismatch: Optional[bool] = None,
                 inference_type: Optional[str] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param bool ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param str inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[bool]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[str]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnprocessableFiles":
            suggest = "skip_unprocessable_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processing: Optional['outputs.SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing'] = None,
                 skip_unprocessable_files: Optional[bool] = None,
                 strategy: Optional[str] = None):
        """
        :param 'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs' processing: Processing configuration
        :param bool skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param str strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing']:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[bool]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing(dict):
    def __init__(__self__, *,
                 local: Optional['outputs.SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal'] = None):
        """
        :param 'SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs' local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal']:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")


@pulumi.output_type
class SourceS3ConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceS3ConfigurationStreamFormatJsonlFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceS3ConfigurationStreamFormatParquetFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalAsFloat":
            suggest = "decimal_as_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceS3ConfigurationStreamFormatParquetFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceS3ConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceS3ConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_as_float: Optional[bool] = None):
        """
        :param bool decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[bool]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")


@pulumi.output_type
class SourceSalesforceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "forceUseBulkApi":
            suggest = "force_use_bulk_api"
        elif key == "isSandbox":
            suggest = "is_sandbox"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "streamSliceStep":
            suggest = "stream_slice_step"
        elif key == "streamsCriterias":
            suggest = "streams_criterias"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSalesforceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSalesforceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSalesforceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 force_use_bulk_api: Optional[bool] = None,
                 is_sandbox: Optional[bool] = None,
                 start_date: Optional[str] = None,
                 stream_slice_step: Optional[str] = None,
                 streams_criterias: Optional[Sequence['outputs.SourceSalesforceConfigurationStreamsCriteria']] = None):
        """
        :param str client_id: Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>
        :param str client_secret: Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>
        :param str refresh_token: Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
        :param bool force_use_bulk_api: Toggle to use Bulk API (this might cause empty fields for some streams). Default: false
        :param bool is_sandbox: Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>. Default: false
        :param str start_date: Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
        :param str stream_slice_step: The size of the time window (ISO8601 duration) to slice requests. Default: "P30D"
        :param Sequence['SourceSalesforceConfigurationStreamsCriteriaArgs'] streams_criterias: Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if force_use_bulk_api is not None:
            pulumi.set(__self__, "force_use_bulk_api", force_use_bulk_api)
        if is_sandbox is not None:
            pulumi.set(__self__, "is_sandbox", is_sandbox)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if stream_slice_step is not None:
            pulumi.set(__self__, "stream_slice_step", stream_slice_step)
        if streams_criterias is not None:
            pulumi.set(__self__, "streams_criterias", streams_criterias)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="forceUseBulkApi")
    def force_use_bulk_api(self) -> Optional[bool]:
        """
        Toggle to use Bulk API (this might cause empty fields for some streams). Default: false
        """
        return pulumi.get(self, "force_use_bulk_api")

    @property
    @pulumi.getter(name="isSandbox")
    def is_sandbox(self) -> Optional[bool]:
        """
        Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>. Default: false
        """
        return pulumi.get(self, "is_sandbox")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="streamSliceStep")
    def stream_slice_step(self) -> Optional[str]:
        """
        The size of the time window (ISO8601 duration) to slice requests. Default: "P30D"
        """
        return pulumi.get(self, "stream_slice_step")

    @property
    @pulumi.getter(name="streamsCriterias")
    def streams_criterias(self) -> Optional[Sequence['outputs.SourceSalesforceConfigurationStreamsCriteria']]:
        """
        Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
        """
        return pulumi.get(self, "streams_criterias")


@pulumi.output_type
class SourceSalesforceConfigurationStreamsCriteria(dict):
    def __init__(__self__, *,
                 value: str,
                 criteria: Optional[str] = None):
        """
        :param str criteria: must be one of ["starts with", "ends with", "contains", "exacts", "starts not with", "ends not with", "not contains", "not exacts"]; Default: "contains"
        """
        pulumi.set(__self__, "value", value)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def criteria(self) -> Optional[str]:
        """
        must be one of ["starts with", "ends with", "contains", "exacts", "starts not with", "ends not with", "not contains", "not exacts"]; Default: "contains"
        """
        return pulumi.get(self, "criteria")


@pulumi.output_type
class SourceSalesloftConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSalesloftConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSalesloftConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSalesloftConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceSalesloftConfigurationCredentials',
                 start_date: str):
        """
        :param str start_date: The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceSalesloftConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSalesloftConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaApiKey":
            suggest = "authenticate_via_api_key"
        elif key == "authenticateViaOAuth":
            suggest = "authenticate_via_o_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSalesloftConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSalesloftConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSalesloftConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_api_key: Optional['outputs.SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey'] = None,
                 authenticate_via_o_auth: Optional['outputs.SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth'] = None):
        if authenticate_via_api_key is not None:
            pulumi.set(__self__, "authenticate_via_api_key", authenticate_via_api_key)
        if authenticate_via_o_auth is not None:
            pulumi.set(__self__, "authenticate_via_o_auth", authenticate_via_o_auth)

    @property
    @pulumi.getter(name="authenticateViaApiKey")
    def authenticate_via_api_key(self) -> Optional['outputs.SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey']:
        return pulumi.get(self, "authenticate_via_api_key")

    @property
    @pulumi.getter(name="authenticateViaOAuth")
    def authenticate_via_o_auth(self) -> Optional['outputs.SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth']:
        return pulumi.get(self, "authenticate_via_o_auth")


@pulumi.output_type
class SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: API Key for making authenticated requests. More instruction on how to find this value in our <a href="https://docs.airbyte.com/integrations/sources/salesloft#setup-guide">docs</a>
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key for making authenticated requests. More instruction on how to find this value in our <a href="https://docs.airbyte.com/integrations/sources/salesloft#setup-guide">docs</a>
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tokenExpiryDate":
            suggest = "token_expiry_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 token_expiry_date: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The Client ID of your Salesloft developer application.
        :param str client_secret: The Client Secret of your Salesloft developer application.
        :param str refresh_token: The token for obtaining a new access token.
        :param str token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Salesloft developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Salesloft developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The token for obtaining a new access token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> str:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")


@pulumi.output_type
class SourceSapFieldglassConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSapFieldglassConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSapFieldglassConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSapFieldglassConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: API Key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceSecodaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSecodaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSecodaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSecodaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Your API Access Key. See <a href="https://docs.secoda.co/secoda-api/authentication">here</a>. The key is case sensitive.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Access Key. See <a href="https://docs.secoda.co/secoda-api/authentication">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceSendgridConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSendgridConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSendgridConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSendgridConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str):
        """
        :param str api_key: Sendgrid API Key, use <a href=\\"https://app.sendgrid.com/settings/api_keys/\\">admin</a> to generate this key.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Sendgrid API Key, use <a href=\\"https://app.sendgrid.com/settings/api_keys/\\">admin</a> to generate this key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSendinblueConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSendinblueConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSendinblueConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSendinblueConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: Your API Key. See <a href="https://developers.sendinblue.com/docs/getting-started">here</a>.
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key. See <a href="https://developers.sendinblue.com/docs/getting-started">here</a>.
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceSenseforceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "backendUrl":
            suggest = "backend_url"
        elif key == "datasetId":
            suggest = "dataset_id"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "sliceRange":
            suggest = "slice_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSenseforceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSenseforceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSenseforceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 backend_url: str,
                 dataset_id: str,
                 start_date: str,
                 slice_range: Optional[int] = None):
        """
        :param str access_token: Your API access token. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a>. The toke is case sensitive.
        :param str backend_url: Your Senseforce API backend URL. This is the URL shown during the Login screen. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
        :param str dataset_id: The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
        :param str start_date: UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the start_date to 2020-10-10 or later
        :param int slice_range: The time increment used by the connector when requesting data from the Senseforce API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted and the more likely one could run into rate limites.  Furthermore, consider that large chunks of time might take a long time for the Senseforce query to return data - meaning it could take in effect longer than with more smaller time slices. If there are a lot of data per day, set this setting to 1. If there is only very little data per day, you might change the setting to 10 or more. Default: 10
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "backend_url", backend_url)
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "start_date", start_date)
        if slice_range is not None:
            pulumi.set(__self__, "slice_range", slice_range)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Your API access token. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a>. The toke is case sensitive.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="backendUrl")
    def backend_url(self) -> str:
        """
        Your Senseforce API backend URL. This is the URL shown during the Login screen. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
        """
        return pulumi.get(self, "backend_url")

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> str:
        """
        The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
        """
        return pulumi.get(self, "dataset_id")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the start_date to 2020-10-10 or later
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="sliceRange")
    def slice_range(self) -> Optional[int]:
        """
        The time increment used by the connector when requesting data from the Senseforce API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted and the more likely one could run into rate limites.  Furthermore, consider that large chunks of time might take a long time for the Senseforce query to return data - meaning it could take in effect longer than with more smaller time slices. If there are a lot of data per day, set this setting to 1. If there is only very little data per day, you might change the setting to 10 or more. Default: 10
        """
        return pulumi.get(self, "slice_range")


@pulumi.output_type
class SourceSentryConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"
        elif key == "discoverFields":
            suggest = "discover_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSentryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSentryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSentryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: str,
                 organization: str,
                 project: str,
                 discover_fields: Optional[Sequence[str]] = None,
                 hostname: Optional[str] = None):
        """
        :param str auth_token: Log into Sentry and then <a href="https://sentry.io/settings/account/api/auth-tokens/">create authentication tokens</a>.For self-hosted, you can find or create authentication tokens by visiting "{instance_url_prefix}/settings/account/api/auth-tokens/"
        :param str organization: The slug of the organization the groups belong to.
        :param str project: The name (slug) of the Project you want to sync.
        :param Sequence[str] discover_fields: Fields to retrieve when fetching discover events
        :param str hostname: Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty. Default: "sentry.io"
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "project", project)
        if discover_fields is not None:
            pulumi.set(__self__, "discover_fields", discover_fields)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        Log into Sentry and then <a href="https://sentry.io/settings/account/api/auth-tokens/">create authentication tokens</a>.For self-hosted, you can find or create authentication tokens by visiting "{instance_url_prefix}/settings/account/api/auth-tokens/"
        """
        return pulumi.get(self, "auth_token")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        The slug of the organization the groups belong to.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        The name (slug) of the Project you want to sync.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="discoverFields")
    def discover_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to retrieve when fetching discover events
        """
        return pulumi.get(self, "discover_fields")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty. Default: "sentry.io"
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class SourceSftpBulkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "folderPath":
            suggest = "folder_path"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceSftpBulkConfigurationCredentials',
                 host: str,
                 streams: Sequence['outputs.SourceSftpBulkConfigurationStream'],
                 username: str,
                 folder_path: Optional[str] = None,
                 port: Optional[int] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceSftpBulkConfigurationCredentialsArgs' credentials: Credentials for connecting to the SFTP Server
        :param str host: The server host address
        :param Sequence['SourceSftpBulkConfigurationStreamArgs'] streams: Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        :param str username: The server user
        :param str folder_path: The directory to search files for sync. Default: "/"
        :param int port: The server port. Default: 22
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "streams", streams)
        pulumi.set(__self__, "username", username)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceSftpBulkConfigurationCredentials':
        """
        Credentials for connecting to the SFTP Server
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The server host address
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.SourceSftpBulkConfigurationStream']:
        """
        Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
        """
        return pulumi.get(self, "streams")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The server user
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[str]:
        """
        The directory to search files for sync. Default: "/"
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The server port. Default: 22
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSftpBulkConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticateViaPassword":
            suggest = "authenticate_via_password"
        elif key == "authenticateViaPrivateKey":
            suggest = "authenticate_via_private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticate_via_password: Optional['outputs.SourceSftpBulkConfigurationCredentialsAuthenticateViaPassword'] = None,
                 authenticate_via_private_key: Optional['outputs.SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey'] = None):
        if authenticate_via_password is not None:
            pulumi.set(__self__, "authenticate_via_password", authenticate_via_password)
        if authenticate_via_private_key is not None:
            pulumi.set(__self__, "authenticate_via_private_key", authenticate_via_private_key)

    @property
    @pulumi.getter(name="authenticateViaPassword")
    def authenticate_via_password(self) -> Optional['outputs.SourceSftpBulkConfigurationCredentialsAuthenticateViaPassword']:
        return pulumi.get(self, "authenticate_via_password")

    @property
    @pulumi.getter(name="authenticateViaPrivateKey")
    def authenticate_via_private_key(self) -> Optional['outputs.SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey']:
        return pulumi.get(self, "authenticate_via_private_key")


@pulumi.output_type
class SourceSftpBulkConfigurationCredentialsAuthenticateViaPassword(dict):
    def __init__(__self__, *,
                 password: str):
        """
        :param str password: Password
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key: str):
        """
        :param str private_key: The Private key
        """
        pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        """
        The Private key
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class SourceSftpBulkConfigurationStream(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysToSyncIfHistoryIsFull":
            suggest = "days_to_sync_if_history_is_full"
        elif key == "inputSchema":
            suggest = "input_schema"
        elif key == "legacyPrefix":
            suggest = "legacy_prefix"
        elif key == "primaryKey":
            suggest = "primary_key"
        elif key == "validationPolicy":
            suggest = "validation_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStream. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStream.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStream.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: 'outputs.SourceSftpBulkConfigurationStreamFormat',
                 name: str,
                 days_to_sync_if_history_is_full: Optional[int] = None,
                 globs: Optional[Sequence[str]] = None,
                 input_schema: Optional[str] = None,
                 legacy_prefix: Optional[str] = None,
                 primary_key: Optional[str] = None,
                 schemaless: Optional[bool] = None,
                 validation_policy: Optional[str] = None):
        """
        :param 'SourceSftpBulkConfigurationStreamFormatArgs' format: The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        :param str name: The name of the stream.
        :param int days_to_sync_if_history_is_full: When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        :param Sequence[str] globs: The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        :param str input_schema: The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        :param str legacy_prefix: The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        :param str primary_key: The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        :param bool schemaless: When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        :param str validation_policy: The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "name", name)
        if days_to_sync_if_history_is_full is not None:
            pulumi.set(__self__, "days_to_sync_if_history_is_full", days_to_sync_if_history_is_full)
        if globs is not None:
            pulumi.set(__self__, "globs", globs)
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if legacy_prefix is not None:
            pulumi.set(__self__, "legacy_prefix", legacy_prefix)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if schemaless is not None:
            pulumi.set(__self__, "schemaless", schemaless)
        if validation_policy is not None:
            pulumi.set(__self__, "validation_policy", validation_policy)

    @property
    @pulumi.getter
    def format(self) -> 'outputs.SourceSftpBulkConfigurationStreamFormat':
        """
        The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the stream.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="daysToSyncIfHistoryIsFull")
    def days_to_sync_if_history_is_full(self) -> Optional[int]:
        """
        When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
        """
        return pulumi.get(self, "days_to_sync_if_history_is_full")

    @property
    @pulumi.getter
    def globs(self) -> Optional[Sequence[str]]:
        """
        The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
        """
        return pulumi.get(self, "globs")

    @property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[str]:
        """
        The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
        """
        return pulumi.get(self, "input_schema")

    @property
    @pulumi.getter(name="legacyPrefix")
    def legacy_prefix(self) -> Optional[str]:
        """
        The path prefix configured in v3 versions of the S3 connector. This option is deprecated in favor of a single glob.
        """
        return pulumi.get(self, "legacy_prefix")

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[str]:
        """
        The column or columns (for a composite key) that serves as the unique identifier of a record. If empty, the primary key will default to the parser's default primary key.
        """
        return pulumi.get(self, "primary_key")

    @property
    @pulumi.getter
    def schemaless(self) -> Optional[bool]:
        """
        When enabled, syncs will not validate or structure records against the stream's schema. Default: false
        """
        return pulumi.get(self, "schemaless")

    @property
    @pulumi.getter(name="validationPolicy")
    def validation_policy(self) -> Optional[str]:
        """
        The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. must be one of ["Emit Record", "Skip Record", "Wait for Discover"]; Default: "Emit Record"
        """
        return pulumi.get(self, "validation_policy")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFormat":
            suggest = "avro_format"
        elif key == "csvFormat":
            suggest = "csv_format"
        elif key == "documentFileTypeFormatExperimental":
            suggest = "document_file_type_format_experimental"
        elif key == "jsonlFormat":
            suggest = "jsonl_format"
        elif key == "parquetFormat":
            suggest = "parquet_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_format: Optional['outputs.SourceSftpBulkConfigurationStreamFormatAvroFormat'] = None,
                 csv_format: Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormat'] = None,
                 document_file_type_format_experimental: Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental'] = None,
                 jsonl_format: Optional['outputs.SourceSftpBulkConfigurationStreamFormatJsonlFormat'] = None,
                 parquet_format: Optional['outputs.SourceSftpBulkConfigurationStreamFormatParquetFormat'] = None):
        """
        :param 'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalArgs' document_file_type_format_experimental: Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if csv_format is not None:
            pulumi.set(__self__, "csv_format", csv_format)
        if document_file_type_format_experimental is not None:
            pulumi.set(__self__, "document_file_type_format_experimental", document_file_type_format_experimental)
        if jsonl_format is not None:
            pulumi.set(__self__, "jsonl_format", jsonl_format)
        if parquet_format is not None:
            pulumi.set(__self__, "parquet_format", parquet_format)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatAvroFormat']:
        return pulumi.get(self, "avro_format")

    @property
    @pulumi.getter(name="csvFormat")
    def csv_format(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormat']:
        return pulumi.get(self, "csv_format")

    @property
    @pulumi.getter(name="documentFileTypeFormatExperimental")
    def document_file_type_format_experimental(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental']:
        """
        Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
        """
        return pulumi.get(self, "document_file_type_format_experimental")

    @property
    @pulumi.getter(name="jsonlFormat")
    def jsonl_format(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatJsonlFormat']:
        return pulumi.get(self, "jsonl_format")

    @property
    @pulumi.getter(name="parquetFormat")
    def parquet_format(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatParquetFormat']:
        return pulumi.get(self, "parquet_format")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatAvroFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleAsString":
            suggest = "double_as_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatAvroFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatAvroFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 double_as_string: Optional[bool] = None):
        """
        :param bool double_as_string: Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        if double_as_string is not None:
            pulumi.set(__self__, "double_as_string", double_as_string)

    @property
    @pulumi.getter(name="doubleAsString")
    def double_as_string(self) -> Optional[bool]:
        """
        Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
        """
        return pulumi.get(self, "double_as_string")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatCsvFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "doubleQuote":
            suggest = "double_quote"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "falseValues":
            suggest = "false_values"
        elif key == "headerDefinition":
            suggest = "header_definition"
        elif key == "ignoreErrorsOnFieldsMismatch":
            suggest = "ignore_errors_on_fields_mismatch"
        elif key == "inferenceType":
            suggest = "inference_type"
        elif key == "nullValues":
            suggest = "null_values"
        elif key == "quoteChar":
            suggest = "quote_char"
        elif key == "skipRowsAfterHeader":
            suggest = "skip_rows_after_header"
        elif key == "skipRowsBeforeHeader":
            suggest = "skip_rows_before_header"
        elif key == "stringsCanBeNull":
            suggest = "strings_can_be_null"
        elif key == "trueValues":
            suggest = "true_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatCsvFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatCsvFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delimiter: Optional[str] = None,
                 double_quote: Optional[bool] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 false_values: Optional[Sequence[str]] = None,
                 header_definition: Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition'] = None,
                 ignore_errors_on_fields_mismatch: Optional[bool] = None,
                 inference_type: Optional[str] = None,
                 null_values: Optional[Sequence[str]] = None,
                 quote_char: Optional[str] = None,
                 skip_rows_after_header: Optional[int] = None,
                 skip_rows_before_header: Optional[int] = None,
                 strings_can_be_null: Optional[bool] = None,
                 true_values: Optional[Sequence[str]] = None):
        """
        :param str delimiter: The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        :param bool double_quote: Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        :param str encoding: The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        :param str escape_char: The character used for escaping special characters. To disallow escaping, leave this field blank.
        :param Sequence[str] false_values: A set of case-sensitive strings that should be interpreted as false values.
        :param 'SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionArgs' header_definition: How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        :param bool ignore_errors_on_fields_mismatch: Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        :param str inference_type: How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        :param Sequence[str] null_values: A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        :param str quote_char: The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        :param int skip_rows_after_header: The number of rows to skip after the header row. Default: 0
        :param int skip_rows_before_header: The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        :param bool strings_can_be_null: Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        :param Sequence[str] true_values: A set of case-sensitive strings that should be interpreted as true values.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if double_quote is not None:
            pulumi.set(__self__, "double_quote", double_quote)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if false_values is not None:
            pulumi.set(__self__, "false_values", false_values)
        if header_definition is not None:
            pulumi.set(__self__, "header_definition", header_definition)
        if ignore_errors_on_fields_mismatch is not None:
            pulumi.set(__self__, "ignore_errors_on_fields_mismatch", ignore_errors_on_fields_mismatch)
        if inference_type is not None:
            pulumi.set(__self__, "inference_type", inference_type)
        if null_values is not None:
            pulumi.set(__self__, "null_values", null_values)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if skip_rows_after_header is not None:
            pulumi.set(__self__, "skip_rows_after_header", skip_rows_after_header)
        if skip_rows_before_header is not None:
            pulumi.set(__self__, "skip_rows_before_header", skip_rows_before_header)
        if strings_can_be_null is not None:
            pulumi.set(__self__, "strings_can_be_null", strings_can_be_null)
        if true_values is not None:
            pulumi.set(__self__, "true_values", true_values)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        """
        The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\\t'. Default: ","
        """
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="doubleQuote")
    def double_quote(self) -> Optional[bool]:
        """
        Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
        """
        return pulumi.get(self, "double_quote")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        """
        The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
        """
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        """
        The character used for escaping special characters. To disallow escaping, leave this field blank.
        """
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="falseValues")
    def false_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as false values.
        """
        return pulumi.get(self, "false_values")

    @property
    @pulumi.getter(name="headerDefinition")
    def header_definition(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition']:
        """
        How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
        """
        return pulumi.get(self, "header_definition")

    @property
    @pulumi.getter(name="ignoreErrorsOnFieldsMismatch")
    def ignore_errors_on_fields_mismatch(self) -> Optional[bool]:
        """
        Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
        """
        return pulumi.get(self, "ignore_errors_on_fields_mismatch")

    @property
    @pulumi.getter(name="inferenceType")
    def inference_type(self) -> Optional[str]:
        """
        How to infer the types of the columns. If none, inference default to strings. must be one of ["None", "Primitive Types Only"]; Default: "None"
        """
        return pulumi.get(self, "inference_type")

    @property
    @pulumi.getter(name="nullValues")
    def null_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
        """
        return pulumi.get(self, "null_values")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        """
        The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\\""
        """
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter(name="skipRowsAfterHeader")
    def skip_rows_after_header(self) -> Optional[int]:
        """
        The number of rows to skip after the header row. Default: 0
        """
        return pulumi.get(self, "skip_rows_after_header")

    @property
    @pulumi.getter(name="skipRowsBeforeHeader")
    def skip_rows_before_header(self) -> Optional[int]:
        """
        The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
        """
        return pulumi.get(self, "skip_rows_before_header")

    @property
    @pulumi.getter(name="stringsCanBeNull")
    def strings_can_be_null(self) -> Optional[bool]:
        """
        Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
        """
        return pulumi.get(self, "strings_can_be_null")

    @property
    @pulumi.getter(name="trueValues")
    def true_values(self) -> Optional[Sequence[str]]:
        """
        A set of case-sensitive strings that should be interpreted as true values.
        """
        return pulumi.get(self, "true_values")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromCsv":
            suggest = "from_csv"
        elif key == "userProvided":
            suggest = "user_provided"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autogenerated: Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated'] = None,
                 from_csv: Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv'] = None,
                 user_provided: Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided'] = None):
        if autogenerated is not None:
            pulumi.set(__self__, "autogenerated", autogenerated)
        if from_csv is not None:
            pulumi.set(__self__, "from_csv", from_csv)
        if user_provided is not None:
            pulumi.set(__self__, "user_provided", user_provided)

    @property
    @pulumi.getter
    def autogenerated(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated']:
        return pulumi.get(self, "autogenerated")

    @property
    @pulumi.getter(name="fromCsv")
    def from_csv(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv']:
        return pulumi.get(self, "from_csv")

    @property
    @pulumi.getter(name="userProvided")
    def user_provided(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided']:
        return pulumi.get(self, "user_provided")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str]):
        """
        :param Sequence[str] column_names: The column names that will be used while emitting the CSV records
        """
        pulumi.set(__self__, "column_names", column_names)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        """
        The column names that will be used while emitting the CSV records
        """
        return pulumi.get(self, "column_names")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skipUnprocessableFiles":
            suggest = "skip_unprocessable_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimental.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 processing: Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing'] = None,
                 skip_unprocessable_files: Optional[bool] = None,
                 strategy: Optional[str] = None):
        """
        :param 'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingArgs' processing: Processing configuration
        :param bool skip_unprocessable_files: If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        :param str strategy: The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        if processing is not None:
            pulumi.set(__self__, "processing", processing)
        if skip_unprocessable_files is not None:
            pulumi.set(__self__, "skip_unprocessable_files", skip_unprocessable_files)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def processing(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing']:
        """
        Processing configuration
        """
        return pulumi.get(self, "processing")

    @property
    @pulumi.getter(name="skipUnprocessableFiles")
    def skip_unprocessable_files(self) -> Optional[bool]:
        """
        If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
        """
        return pulumi.get(self, "skip_unprocessable_files")

    @property
    @pulumi.getter
    def strategy(self) -> Optional[str]:
        """
        The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. must be one of ["auto", "fast", "ocr_only", "hi_res"]; Default: "auto"
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viaApi":
            suggest = "via_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local: Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal'] = None,
                 via_api: Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi'] = None):
        """
        :param 'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocalArgs' local: Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        :param 'SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiArgs' via_api: Process files via an API, using the `hi_res` mode. This option is useful for increased performance and accuracy, but requires an API key and a hosted instance of unstructured.
        """
        if local is not None:
            pulumi.set(__self__, "local", local)
        if via_api is not None:
            pulumi.set(__self__, "via_api", via_api)

    @property
    @pulumi.getter
    def local(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal']:
        """
        Process files locally, supporting `fast` and `ocr` modes. This is the default option.
        """
        return pulumi.get(self, "local")

    @property
    @pulumi.getter(name="viaApi")
    def via_api(self) -> Optional['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi']:
        """
        Process files via an API, using the `hi_res` mode. This option is useful for increased performance and accuracy, but requires an API key and a hosted instance of unstructured.
        """
        return pulumi.get(self, "via_api")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingLocal(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiUrl":
            suggest = "api_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[str] = None,
                 api_url: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameter']] = None):
        """
        :param str api_key: The API key to use matching the environment. Default: ""
        :param str api_url: The URL of the unstructured API to use. Default: "https://api.unstructured.io"
        :param Sequence['SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameterArgs'] parameters: List of parameters send to the API
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if api_url is not None:
            pulumi.set(__self__, "api_url", api_url)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[str]:
        """
        The API key to use matching the environment. Default: ""
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiUrl")
    def api_url(self) -> Optional[str]:
        """
        The URL of the unstructured API to use. Default: "https://api.unstructured.io"
        """
        return pulumi.get(self, "api_url")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameter']]:
        """
        List of parameters send to the API
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatDocumentFileTypeFormatExperimentalProcessingViaApiParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the unstructured API parameter to use
        :param str value: The value of the parameter
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the unstructured API parameter to use
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatJsonlFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceSftpBulkConfigurationStreamFormatParquetFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decimalAsFloat":
            suggest = "decimal_as_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpBulkConfigurationStreamFormatParquetFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpBulkConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpBulkConfigurationStreamFormatParquetFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decimal_as_float: Optional[bool] = None):
        """
        :param bool decimal_as_float: Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        if decimal_as_float is not None:
            pulumi.set(__self__, "decimal_as_float", decimal_as_float)

    @property
    @pulumi.getter(name="decimalAsFloat")
    def decimal_as_float(self) -> Optional[bool]:
        """
        Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
        """
        return pulumi.get(self, "decimal_as_float")


@pulumi.output_type
class SourceSftpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filePattern":
            suggest = "file_pattern"
        elif key == "fileTypes":
            suggest = "file_types"
        elif key == "folderPath":
            suggest = "folder_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host: str,
                 user: str,
                 credentials: Optional['outputs.SourceSftpConfigurationCredentials'] = None,
                 file_pattern: Optional[str] = None,
                 file_types: Optional[str] = None,
                 folder_path: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str host: The server host address
        :param str user: The server user
        :param 'SourceSftpConfigurationCredentialsArgs' credentials: The server authentication method
        :param str file_pattern: The regular expression to specify files for sync in a chosen Folder Path. Default: ""
        :param str file_types: Coma separated file types. Currently only 'csv' and 'json' types are supported. Default: "csv,json"
        :param str folder_path: The directory to search files for sync. Default: ""
        :param int port: The server port. Default: 22
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "user", user)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if file_pattern is not None:
            pulumi.set(__self__, "file_pattern", file_pattern)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if folder_path is not None:
            pulumi.set(__self__, "folder_path", folder_path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The server host address
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def user(self) -> str:
        """
        The server user
        """
        return pulumi.get(self, "user")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceSftpConfigurationCredentials']:
        """
        The server authentication method
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="filePattern")
    def file_pattern(self) -> Optional[str]:
        """
        The regular expression to specify files for sync in a chosen Folder Path. Default: ""
        """
        return pulumi.get(self, "file_pattern")

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[str]:
        """
        Coma separated file types. Currently only 'csv' and 'json' types are supported. Default: "csv,json"
        """
        return pulumi.get(self, "file_types")

    @property
    @pulumi.getter(name="folderPath")
    def folder_path(self) -> Optional[str]:
        """
        The directory to search files for sync. Default: ""
        """
        return pulumi.get(self, "folder_path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The server port. Default: 22
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SourceSftpConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordAuthentication":
            suggest = "password_authentication"
        elif key == "sshKeyAuthentication":
            suggest = "ssh_key_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_authentication: Optional['outputs.SourceSftpConfigurationCredentialsPasswordAuthentication'] = None,
                 ssh_key_authentication: Optional['outputs.SourceSftpConfigurationCredentialsSshKeyAuthentication'] = None):
        if password_authentication is not None:
            pulumi.set(__self__, "password_authentication", password_authentication)
        if ssh_key_authentication is not None:
            pulumi.set(__self__, "ssh_key_authentication", ssh_key_authentication)

    @property
    @pulumi.getter(name="passwordAuthentication")
    def password_authentication(self) -> Optional['outputs.SourceSftpConfigurationCredentialsPasswordAuthentication']:
        return pulumi.get(self, "password_authentication")

    @property
    @pulumi.getter(name="sshKeyAuthentication")
    def ssh_key_authentication(self) -> Optional['outputs.SourceSftpConfigurationCredentialsSshKeyAuthentication']:
        return pulumi.get(self, "ssh_key_authentication")


@pulumi.output_type
class SourceSftpConfigurationCredentialsPasswordAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUserPassword":
            suggest = "auth_user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpConfigurationCredentialsPasswordAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpConfigurationCredentialsPasswordAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpConfigurationCredentialsPasswordAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_user_password: str):
        """
        :param str auth_user_password: OS-level password for logging into the jump server host
        """
        pulumi.set(__self__, "auth_user_password", auth_user_password)

    @property
    @pulumi.getter(name="authUserPassword")
    def auth_user_password(self) -> str:
        """
        OS-level password for logging into the jump server host
        """
        return pulumi.get(self, "auth_user_password")


@pulumi.output_type
class SourceSftpConfigurationCredentialsSshKeyAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authSshKey":
            suggest = "auth_ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSftpConfigurationCredentialsSshKeyAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSftpConfigurationCredentialsSshKeyAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSftpConfigurationCredentialsSshKeyAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_ssh_key: str):
        """
        :param str auth_ssh_key: OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        pulumi.set(__self__, "auth_ssh_key", auth_ssh_key)

    @property
    @pulumi.getter(name="authSshKey")
    def auth_ssh_key(self) -> str:
        """
        OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
        """
        return pulumi.get(self, "auth_ssh_key")


@pulumi.output_type
class SourceShopifyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bulkWindowInDays":
            suggest = "bulk_window_in_days"
        elif key == "fetchTransactionsUserId":
            suggest = "fetch_transactions_user_id"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceShopifyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceShopifyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceShopifyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shop: str,
                 bulk_window_in_days: Optional[int] = None,
                 credentials: Optional['outputs.SourceShopifyConfigurationCredentials'] = None,
                 fetch_transactions_user_id: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param str shop: The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
        :param int bulk_window_in_days: Defines what would be a date range per single BULK Job. Default: 30
        :param 'SourceShopifyConfigurationCredentialsArgs' credentials: The authorization method to use to retrieve data from Shopify
        :param bool fetch_transactions_user_id: Defines which API type (REST/BULK) to use to fetch `Transactions` data. If you are a `Shopify Plus` user, leave the default value to speed up the fetch. Default: false
        :param str start_date: The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated. Default: "2020-01-01"
        """
        pulumi.set(__self__, "shop", shop)
        if bulk_window_in_days is not None:
            pulumi.set(__self__, "bulk_window_in_days", bulk_window_in_days)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if fetch_transactions_user_id is not None:
            pulumi.set(__self__, "fetch_transactions_user_id", fetch_transactions_user_id)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def shop(self) -> str:
        """
        The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
        """
        return pulumi.get(self, "shop")

    @property
    @pulumi.getter(name="bulkWindowInDays")
    def bulk_window_in_days(self) -> Optional[int]:
        """
        Defines what would be a date range per single BULK Job. Default: 30
        """
        return pulumi.get(self, "bulk_window_in_days")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceShopifyConfigurationCredentials']:
        """
        The authorization method to use to retrieve data from Shopify
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="fetchTransactionsUserId")
    def fetch_transactions_user_id(self) -> Optional[bool]:
        """
        Defines which API type (REST/BULK) to use to fetch `Transactions` data. If you are a `Shopify Plus` user, leave the default value to speed up the fetch. Default: false
        """
        return pulumi.get(self, "fetch_transactions_user_id")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated. Default: "2020-01-01"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceShopifyConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiPassword":
            suggest = "api_password"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceShopifyConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceShopifyConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceShopifyConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_password: Optional['outputs.SourceShopifyConfigurationCredentialsApiPassword'] = None,
                 o_auth20: Optional['outputs.SourceShopifyConfigurationCredentialsOAuth20'] = None):
        """
        :param 'SourceShopifyConfigurationCredentialsApiPasswordArgs' api_password: API Password Auth
        :param 'SourceShopifyConfigurationCredentialsOAuth20Args' o_auth20: OAuth2.0
        """
        if api_password is not None:
            pulumi.set(__self__, "api_password", api_password)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiPassword")
    def api_password(self) -> Optional['outputs.SourceShopifyConfigurationCredentialsApiPassword']:
        """
        API Password Auth
        """
        return pulumi.get(self, "api_password")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceShopifyConfigurationCredentialsOAuth20']:
        """
        OAuth2.0
        """
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceShopifyConfigurationCredentialsApiPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiPassword":
            suggest = "api_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceShopifyConfigurationCredentialsApiPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceShopifyConfigurationCredentialsApiPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceShopifyConfigurationCredentialsApiPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_password: str):
        """
        :param str api_password: The API Password for your private application in the `Shopify` store.
        """
        pulumi.set(__self__, "api_password", api_password)

    @property
    @pulumi.getter(name="apiPassword")
    def api_password(self) -> str:
        """
        The API Password for your private application in the `Shopify` store.
        """
        return pulumi.get(self, "api_password")


@pulumi.output_type
class SourceShopifyConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceShopifyConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceShopifyConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceShopifyConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: The Access Token for making authenticated requests.
        :param str client_id: The Client ID of the Shopify developer application.
        :param str client_secret: The Client Secret of the Shopify developer application.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        The Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of the Shopify developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the Shopify developer application.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceShortioConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainId":
            suggest = "domain_id"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceShortioConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceShortioConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceShortioConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_id: str,
                 secret_key: str,
                 start_date: str):
        """
        :param str secret_key: Short.io Secret Key
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> str:
        return pulumi.get(self, "domain_id")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        """
        Short.io Secret Key
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSlackConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "channelFilters":
            suggest = "channel_filters"
        elif key == "includePrivateChannels":
            suggest = "include_private_channels"
        elif key == "joinChannels":
            suggest = "join_channels"
        elif key == "lookbackWindow":
            suggest = "lookback_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSlackConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSlackConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSlackConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 channel_filters: Optional[Sequence[str]] = None,
                 credentials: Optional['outputs.SourceSlackConfigurationCredentials'] = None,
                 include_private_channels: Optional[bool] = None,
                 join_channels: Optional[bool] = None,
                 lookback_window: Optional[int] = None):
        """
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param Sequence[str] channel_filters: A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
        :param 'SourceSlackConfigurationCredentialsArgs' credentials: Choose how to authenticate into Slack
        :param bool include_private_channels: Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels. . Default: false
        :param bool join_channels: Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages. . Default: true
        :param int lookback_window: How far into the past to look for messages in threads, default is 0 days. Default: 0
        """
        pulumi.set(__self__, "start_date", start_date)
        if channel_filters is not None:
            pulumi.set(__self__, "channel_filters", channel_filters)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if include_private_channels is not None:
            pulumi.set(__self__, "include_private_channels", include_private_channels)
        if join_channels is not None:
            pulumi.set(__self__, "join_channels", join_channels)
        if lookback_window is not None:
            pulumi.set(__self__, "lookback_window", lookback_window)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="channelFilters")
    def channel_filters(self) -> Optional[Sequence[str]]:
        """
        A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
        """
        return pulumi.get(self, "channel_filters")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceSlackConfigurationCredentials']:
        """
        Choose how to authenticate into Slack
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="includePrivateChannels")
    def include_private_channels(self) -> Optional[bool]:
        """
        Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels. . Default: false
        """
        return pulumi.get(self, "include_private_channels")

    @property
    @pulumi.getter(name="joinChannels")
    def join_channels(self) -> Optional[bool]:
        """
        Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages. . Default: true
        """
        return pulumi.get(self, "join_channels")

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional[int]:
        """
        How far into the past to look for messages in threads, default is 0 days. Default: 0
        """
        return pulumi.get(self, "lookback_window")


@pulumi.output_type
class SourceSlackConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "signInViaSlackOAuth":
            suggest = "sign_in_via_slack_o_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSlackConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSlackConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSlackConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.SourceSlackConfigurationCredentialsApiToken'] = None,
                 sign_in_via_slack_o_auth: Optional['outputs.SourceSlackConfigurationCredentialsSignInViaSlackOAuth'] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if sign_in_via_slack_o_auth is not None:
            pulumi.set(__self__, "sign_in_via_slack_o_auth", sign_in_via_slack_o_auth)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.SourceSlackConfigurationCredentialsApiToken']:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="signInViaSlackOAuth")
    def sign_in_via_slack_o_auth(self) -> Optional['outputs.SourceSlackConfigurationCredentialsSignInViaSlackOAuth']:
        return pulumi.get(self, "sign_in_via_slack_o_auth")


@pulumi.output_type
class SourceSlackConfigurationCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSlackConfigurationCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSlackConfigurationCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSlackConfigurationCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class SourceSlackConfigurationCredentialsSignInViaSlackOAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSlackConfigurationCredentialsSignInViaSlackOAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSlackConfigurationCredentialsSignInViaSlackOAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSlackConfigurationCredentialsSignInViaSlackOAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str):
        """
        :param str access_token: Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
        :param str client_id: Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
        :param str client_secret: Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceSmailyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiPassword":
            suggest = "api_password"
        elif key == "apiSubdomain":
            suggest = "api_subdomain"
        elif key == "apiUsername":
            suggest = "api_username"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSmailyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSmailyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSmailyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_password: str,
                 api_subdomain: str,
                 api_username: str):
        """
        :param str api_password: API user password. See https://smaily.com/help/api/general/create-api-user/
        :param str api_subdomain: API Subdomain. See https://smaily.com/help/api/general/create-api-user/
        :param str api_username: API user username. See https://smaily.com/help/api/general/create-api-user/
        """
        pulumi.set(__self__, "api_password", api_password)
        pulumi.set(__self__, "api_subdomain", api_subdomain)
        pulumi.set(__self__, "api_username", api_username)

    @property
    @pulumi.getter(name="apiPassword")
    def api_password(self) -> str:
        """
        API user password. See https://smaily.com/help/api/general/create-api-user/
        """
        return pulumi.get(self, "api_password")

    @property
    @pulumi.getter(name="apiSubdomain")
    def api_subdomain(self) -> str:
        """
        API Subdomain. See https://smaily.com/help/api/general/create-api-user/
        """
        return pulumi.get(self, "api_subdomain")

    @property
    @pulumi.getter(name="apiUsername")
    def api_username(self) -> str:
        """
        API user username. See https://smaily.com/help/api/general/create-api-user/
        """
        return pulumi.get(self, "api_username")


@pulumi.output_type
class SourceSmartengageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSmartengageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSmartengageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSmartengageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: API Key
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        API Key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceSmartsheetsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spreadsheetId":
            suggest = "spreadsheet_id"
        elif key == "metadataFields":
            suggest = "metadata_fields"
        elif key == "startDatetime":
            suggest = "start_datetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSmartsheetsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSmartsheetsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSmartsheetsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceSmartsheetsConfigurationCredentials',
                 spreadsheet_id: str,
                 metadata_fields: Optional[Sequence[str]] = None,
                 start_datetime: Optional[str] = None):
        """
        :param str spreadsheet_id: The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
        :param Sequence[str] metadata_fields: A List of available columns which metadata can be pulled from.
        :param str start_datetime: Only rows modified after this date/time will be replicated. This should be an ISO 8601 string, for instance: `2000-01-01T13:00:00`. Default: "2020-01-01T00:00:00+00:00"
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "spreadsheet_id", spreadsheet_id)
        if metadata_fields is not None:
            pulumi.set(__self__, "metadata_fields", metadata_fields)
        if start_datetime is not None:
            pulumi.set(__self__, "start_datetime", start_datetime)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceSmartsheetsConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="spreadsheetId")
    def spreadsheet_id(self) -> str:
        """
        The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
        """
        return pulumi.get(self, "spreadsheet_id")

    @property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> Optional[Sequence[str]]:
        """
        A List of available columns which metadata can be pulled from.
        """
        return pulumi.get(self, "metadata_fields")

    @property
    @pulumi.getter(name="startDatetime")
    def start_datetime(self) -> Optional[str]:
        """
        Only rows modified after this date/time will be replicated. This should be an ISO 8601 string, for instance: `2000-01-01T13:00:00`. Default: "2020-01-01T00:00:00+00:00"
        """
        return pulumi.get(self, "start_datetime")


@pulumi.output_type
class SourceSmartsheetsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiAccessToken":
            suggest = "api_access_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSmartsheetsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSmartsheetsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSmartsheetsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_access_token: Optional['outputs.SourceSmartsheetsConfigurationCredentialsApiAccessToken'] = None,
                 o_auth20: Optional['outputs.SourceSmartsheetsConfigurationCredentialsOAuth20'] = None):
        if api_access_token is not None:
            pulumi.set(__self__, "api_access_token", api_access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiAccessToken")
    def api_access_token(self) -> Optional['outputs.SourceSmartsheetsConfigurationCredentialsApiAccessToken']:
        return pulumi.get(self, "api_access_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceSmartsheetsConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceSmartsheetsConfigurationCredentialsApiAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSmartsheetsConfigurationCredentialsApiAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSmartsheetsConfigurationCredentialsApiAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSmartsheetsConfigurationCredentialsApiAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: The access token to use for accessing your data from Smartsheets. This access token must be generated by a user with at least read access to the data you'd like to replicate. Generate an access token in the Smartsheets main menu by clicking Account > Apps & Integrations > API Access. See the <a href="https://docs.airbyte.com/integrations/sources/smartsheets/#setup-guide">setup guide</a> for information on how to obtain this token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The access token to use for accessing your data from Smartsheets. This access token must be generated by a user with at least read access to the data you'd like to replicate. Generate an access token in the Smartsheets main menu by clicking Account > Apps & Integrations > API Access. See the <a href="https://docs.airbyte.com/integrations/sources/smartsheets/#setup-guide">setup guide</a> for information on how to obtain this token.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceSmartsheetsConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tokenExpiryDate":
            suggest = "token_expiry_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSmartsheetsConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSmartsheetsConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSmartsheetsConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 token_expiry_date: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The API ID of the SmartSheets developer application.
        :param str client_secret: The API Secret the SmartSheets developer application.
        :param str refresh_token: The key to refresh the expired access_token.
        :param str token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The API ID of the SmartSheets developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The API Secret the SmartSheets developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> str:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")


@pulumi.output_type
class SourceSnapchatMarketingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "actionReportTime":
            suggest = "action_report_time"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "swipeUpAttributionWindow":
            suggest = "swipe_up_attribution_window"
        elif key == "viewAttributionWindow":
            suggest = "view_attribution_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSnapchatMarketingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSnapchatMarketingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSnapchatMarketingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 action_report_time: Optional[str] = None,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None,
                 swipe_up_attribution_window: Optional[str] = None,
                 view_attribution_window: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Snapchat developer application.
        :param str client_secret: The Client Secret of your Snapchat developer application.
        :param str refresh_token: Refresh Token to renew the expired Access Token.
        :param str action_report_time: Specifies the principle for conversion reporting. must be one of ["conversion", "impression"]; Default: "conversion"
        :param str end_date: Date in the format 2017-01-25. Any data after this date will not be replicated.
        :param str start_date: Date in the format 2022-01-01. Any data before this date will not be replicated. Default: "2022-01-01"
        :param str swipe_up_attribution_window: Attribution window for swipe ups. must be one of ["1_DAY", "7_DAY", "28_DAY"]; Default: "28_DAY"
        :param str view_attribution_window: Attribution window for views. must be one of ["1_HOUR", "3_HOUR", "6_HOUR", "1_DAY", "7_DAY"]; Default: "1_DAY"
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if action_report_time is not None:
            pulumi.set(__self__, "action_report_time", action_report_time)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)
        if swipe_up_attribution_window is not None:
            pulumi.set(__self__, "swipe_up_attribution_window", swipe_up_attribution_window)
        if view_attribution_window is not None:
            pulumi.set(__self__, "view_attribution_window", view_attribution_window)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Snapchat developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Snapchat developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        Refresh Token to renew the expired Access Token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="actionReportTime")
    def action_report_time(self) -> Optional[str]:
        """
        Specifies the principle for conversion reporting. must be one of ["conversion", "impression"]; Default: "conversion"
        """
        return pulumi.get(self, "action_report_time")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        Date in the format 2017-01-25. Any data after this date will not be replicated.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        Date in the format 2022-01-01. Any data before this date will not be replicated. Default: "2022-01-01"
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="swipeUpAttributionWindow")
    def swipe_up_attribution_window(self) -> Optional[str]:
        """
        Attribution window for swipe ups. must be one of ["1_DAY", "7_DAY", "28_DAY"]; Default: "28_DAY"
        """
        return pulumi.get(self, "swipe_up_attribution_window")

    @property
    @pulumi.getter(name="viewAttributionWindow")
    def view_attribution_window(self) -> Optional[str]:
        """
        Attribution window for views. must be one of ["1_HOUR", "3_HOUR", "6_HOUR", "1_DAY", "7_DAY"]; Default: "1_DAY"
        """
        return pulumi.get(self, "view_attribution_window")


@pulumi.output_type
class SourceSnowflakeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jdbcUrlParams":
            suggest = "jdbc_url_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSnowflakeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSnowflakeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSnowflakeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: str,
                 host: str,
                 role: str,
                 warehouse: str,
                 credentials: Optional['outputs.SourceSnowflakeConfigurationCredentials'] = None,
                 jdbc_url_params: Optional[str] = None,
                 schema: Optional[str] = None):
        """
        :param str database: The database you created for Airbyte to access data.
        :param str host: The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
        :param str role: The role you created for Airbyte to access Snowflake.
        :param str warehouse: The warehouse you created for Airbyte to access data.
        :param str jdbc_url_params: Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        :param str schema: The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "warehouse", warehouse)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if jdbc_url_params is not None:
            pulumi.set(__self__, "jdbc_url_params", jdbc_url_params)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        The database you created for Airbyte to access data.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The role you created for Airbyte to access Snowflake.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def warehouse(self) -> str:
        """
        The warehouse you created for Airbyte to access data.
        """
        return pulumi.get(self, "warehouse")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceSnowflakeConfigurationCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="jdbcUrlParams")
    def jdbc_url_params(self) -> Optional[str]:
        """
        Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
        """
        return pulumi.get(self, "jdbc_url_params")

    @property
    @pulumi.getter
    def schema(self) -> Optional[str]:
        """
        The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class SourceSnowflakeConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth20":
            suggest = "o_auth20"
        elif key == "usernameAndPassword":
            suggest = "username_and_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSnowflakeConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSnowflakeConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSnowflakeConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth20: Optional['outputs.SourceSnowflakeConfigurationCredentialsOAuth20'] = None,
                 username_and_password: Optional['outputs.SourceSnowflakeConfigurationCredentialsUsernameAndPassword'] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if username_and_password is not None:
            pulumi.set(__self__, "username_and_password", username_and_password)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceSnowflakeConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")

    @property
    @pulumi.getter(name="usernameAndPassword")
    def username_and_password(self) -> Optional['outputs.SourceSnowflakeConfigurationCredentialsUsernameAndPassword']:
        return pulumi.get(self, "username_and_password")


@pulumi.output_type
class SourceSnowflakeConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "accessToken":
            suggest = "access_token"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSnowflakeConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSnowflakeConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSnowflakeConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 access_token: Optional[str] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str client_id: The Client ID of your Snowflake developer application.
        :param str client_secret: The Client Secret of your Snowflake developer application.
        :param str access_token: Access Token for making authenticated requests.
        :param str refresh_token: Refresh Token for making authenticated requests.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Snowflake developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Snowflake developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        Refresh Token for making authenticated requests.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceSnowflakeConfigurationCredentialsUsernameAndPassword(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password associated with the username.
        :param str username: The username you created to allow Airbyte to access the database.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password associated with the username.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username you created to allow Airbyte to access the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SourceSonarCloudConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentKeys":
            suggest = "component_keys"
        elif key == "userToken":
            suggest = "user_token"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSonarCloudConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSonarCloudConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSonarCloudConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_keys: Sequence[str],
                 organization: str,
                 user_token: str,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param Sequence[str] component_keys: Comma-separated list of component keys.
        :param str organization: Organization key. See <a href="https://docs.sonarcloud.io/appendices/project-information/#project-and-organization-keys">here</a>.
        :param str user_token: Your User Token. See <a href="https://docs.sonarcloud.io/advanced-setup/user-accounts/">here</a>. The token is case sensitive.
        :param str end_date: To retrieve issues created before the given date (inclusive).
        :param str start_date: To retrieve issues created after the given date (inclusive).
        """
        pulumi.set(__self__, "component_keys", component_keys)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "user_token", user_token)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="componentKeys")
    def component_keys(self) -> Sequence[str]:
        """
        Comma-separated list of component keys.
        """
        return pulumi.get(self, "component_keys")

    @property
    @pulumi.getter
    def organization(self) -> str:
        """
        Organization key. See <a href="https://docs.sonarcloud.io/appendices/project-information/#project-and-organization-keys">here</a>.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter(name="userToken")
    def user_token(self) -> str:
        """
        Your User Token. See <a href="https://docs.sonarcloud.io/advanced-setup/user-accounts/">here</a>. The token is case sensitive.
        """
        return pulumi.get(self, "user_token")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        To retrieve issues created before the given date (inclusive).
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        To retrieve issues created after the given date (inclusive).
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSpacexApiConfiguration(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 options: Optional[str] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        return pulumi.get(self, "options")


@pulumi.output_type
class SourceSquareConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeDeletedObjects":
            suggest = "include_deleted_objects"
        elif key == "isSandbox":
            suggest = "is_sandbox"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSquareConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSquareConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSquareConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: Optional['outputs.SourceSquareConfigurationCredentials'] = None,
                 include_deleted_objects: Optional[bool] = None,
                 is_sandbox: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param 'SourceSquareConfigurationCredentialsArgs' credentials: Choose how to authenticate to Square.
        :param bool include_deleted_objects: In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes). Default: false
        :param bool is_sandbox: Determines whether to use the sandbox or production environment. Default: false
        :param str start_date: UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated. Default: "2021-01-01"
        """
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if include_deleted_objects is not None:
            pulumi.set(__self__, "include_deleted_objects", include_deleted_objects)
        if is_sandbox is not None:
            pulumi.set(__self__, "is_sandbox", is_sandbox)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceSquareConfigurationCredentials']:
        """
        Choose how to authenticate to Square.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="includeDeletedObjects")
    def include_deleted_objects(self) -> Optional[bool]:
        """
        In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes). Default: false
        """
        return pulumi.get(self, "include_deleted_objects")

    @property
    @pulumi.getter(name="isSandbox")
    def is_sandbox(self) -> Optional[bool]:
        """
        Determines whether to use the sandbox or production environment. Default: false
        """
        return pulumi.get(self, "is_sandbox")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated. Default: "2021-01-01"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSquareConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "oauthAuthentication":
            suggest = "oauth_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSquareConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSquareConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSquareConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.SourceSquareConfigurationCredentialsApiKey'] = None,
                 oauth_authentication: Optional['outputs.SourceSquareConfigurationCredentialsOauthAuthentication'] = None):
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if oauth_authentication is not None:
            pulumi.set(__self__, "oauth_authentication", oauth_authentication)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.SourceSquareConfigurationCredentialsApiKey']:
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="oauthAuthentication")
    def oauth_authentication(self) -> Optional['outputs.SourceSquareConfigurationCredentialsOauthAuthentication']:
        return pulumi.get(self, "oauth_authentication")


@pulumi.output_type
class SourceSquareConfigurationCredentialsApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSquareConfigurationCredentialsApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSquareConfigurationCredentialsApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSquareConfigurationCredentialsApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str):
        """
        :param str api_key: The API key for a Square application
        """
        pulumi.set(__self__, "api_key", api_key)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The API key for a Square application
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class SourceSquareConfigurationCredentialsOauthAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSquareConfigurationCredentialsOauthAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSquareConfigurationCredentialsOauthAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSquareConfigurationCredentialsOauthAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str):
        """
        :param str client_id: The Square-issued ID of your application
        :param str client_secret: The Square-issued application secret for your application
        :param str refresh_token: A refresh token generated using the above client ID and secret
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Square-issued ID of your application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Square-issued application secret for your application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        A refresh token generated using the above client ID and secret
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceStravaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "athleteId":
            suggest = "athlete_id"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceStravaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceStravaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceStravaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 athlete_id: int,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 start_date: str):
        """
        :param int athlete_id: The Athlete ID of your Strava developer application.
        :param str client_id: The Client ID of your Strava developer application.
        :param str client_secret: The Client Secret of your Strava developer application.
        :param str refresh_token: The Refresh Token with the activity: read_all permissions.
        :param str start_date: UTC date and time. Any data before this date will not be replicated.
        """
        pulumi.set(__self__, "athlete_id", athlete_id)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="athleteId")
    def athlete_id(self) -> int:
        """
        The Athlete ID of your Strava developer application.
        """
        return pulumi.get(self, "athlete_id")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your Strava developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your Strava developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The Refresh Token with the activity: read_all permissions.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceStripeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "callRateLimit":
            suggest = "call_rate_limit"
        elif key == "lookbackWindowDays":
            suggest = "lookback_window_days"
        elif key == "numWorkers":
            suggest = "num_workers"
        elif key == "sliceRange":
            suggest = "slice_range"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceStripeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceStripeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceStripeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 client_secret: str,
                 call_rate_limit: Optional[int] = None,
                 lookback_window_days: Optional[int] = None,
                 num_workers: Optional[int] = None,
                 slice_range: Optional[int] = None,
                 start_date: Optional[str] = None):
        """
        :param str account_id: Your Stripe account ID (starts with 'acct_', find yours <a href="https://dashboard.stripe.com/settings/account">here</a>).
        :param str client_secret: Stripe API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.stripe.com/apikeys">here</a>).
        :param int call_rate_limit: The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
        :param int lookback_window_days: When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info <a href="https://docs.airbyte.com/integrations/sources/stripe#requirements">here</a>. Default: 0
        :param int num_workers: The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account. Default: 10
        :param int slice_range: The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted. Default: 365
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated. Default: "2017-01-25T00:00:00Z"
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if call_rate_limit is not None:
            pulumi.set(__self__, "call_rate_limit", call_rate_limit)
        if lookback_window_days is not None:
            pulumi.set(__self__, "lookback_window_days", lookback_window_days)
        if num_workers is not None:
            pulumi.set(__self__, "num_workers", num_workers)
        if slice_range is not None:
            pulumi.set(__self__, "slice_range", slice_range)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Your Stripe account ID (starts with 'acct_', find yours <a href="https://dashboard.stripe.com/settings/account">here</a>).
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        Stripe API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.stripe.com/apikeys">here</a>).
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="callRateLimit")
    def call_rate_limit(self) -> Optional[int]:
        """
        The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
        """
        return pulumi.get(self, "call_rate_limit")

    @property
    @pulumi.getter(name="lookbackWindowDays")
    def lookback_window_days(self) -> Optional[int]:
        """
        When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info <a href="https://docs.airbyte.com/integrations/sources/stripe#requirements">here</a>. Default: 0
        """
        return pulumi.get(self, "lookback_window_days")

    @property
    @pulumi.getter(name="numWorkers")
    def num_workers(self) -> Optional[int]:
        """
        The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account. Default: 10
        """
        return pulumi.get(self, "num_workers")

    @property
    @pulumi.getter(name="sliceRange")
    def slice_range(self) -> Optional[int]:
        """
        The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted. Default: 365
        """
        return pulumi.get(self, "slice_range")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated. Default: "2017-01-25T00:00:00Z"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceSurveySparrowConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "surveyIds":
            suggest = "survey_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSurveySparrowConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSurveySparrowConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSurveySparrowConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 region: Optional['outputs.SourceSurveySparrowConfigurationRegion'] = None,
                 survey_ids: Optional[Sequence[str]] = None):
        """
        :param str access_token: Your access token. See <a href="https://developers.surveysparrow.com/rest-apis#authentication">here</a>. The key is case sensitive.
        :param 'SourceSurveySparrowConfigurationRegionArgs' region: Is your account location is EU based? If yes, the base url to retrieve data will be different.
        :param Sequence[str] survey_ids: A List of your survey ids for survey-specific stream
        """
        pulumi.set(__self__, "access_token", access_token)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if survey_ids is not None:
            pulumi.set(__self__, "survey_ids", survey_ids)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Your access token. See <a href="https://developers.surveysparrow.com/rest-apis#authentication">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def region(self) -> Optional['outputs.SourceSurveySparrowConfigurationRegion']:
        """
        Is your account location is EU based? If yes, the base url to retrieve data will be different.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="surveyIds")
    def survey_ids(self) -> Optional[Sequence[str]]:
        """
        A List of your survey ids for survey-specific stream
        """
        return pulumi.get(self, "survey_ids")


@pulumi.output_type
class SourceSurveySparrowConfigurationRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "euBasedAccount":
            suggest = "eu_based_account"
        elif key == "globalAccount":
            suggest = "global_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSurveySparrowConfigurationRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSurveySparrowConfigurationRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSurveySparrowConfigurationRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eu_based_account: Optional['outputs.SourceSurveySparrowConfigurationRegionEuBasedAccount'] = None,
                 global_account: Optional['outputs.SourceSurveySparrowConfigurationRegionGlobalAccount'] = None):
        if eu_based_account is not None:
            pulumi.set(__self__, "eu_based_account", eu_based_account)
        if global_account is not None:
            pulumi.set(__self__, "global_account", global_account)

    @property
    @pulumi.getter(name="euBasedAccount")
    def eu_based_account(self) -> Optional['outputs.SourceSurveySparrowConfigurationRegionEuBasedAccount']:
        return pulumi.get(self, "eu_based_account")

    @property
    @pulumi.getter(name="globalAccount")
    def global_account(self) -> Optional['outputs.SourceSurveySparrowConfigurationRegionGlobalAccount']:
        return pulumi.get(self, "global_account")


@pulumi.output_type
class SourceSurveySparrowConfigurationRegionEuBasedAccount(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceSurveySparrowConfigurationRegionGlobalAccount(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceSurveymonkeyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "surveyIds":
            suggest = "survey_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSurveymonkeyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSurveymonkeyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSurveymonkeyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceSurveymonkeyConfigurationCredentials',
                 start_date: str,
                 origin: Optional[str] = None,
                 survey_ids: Optional[Sequence[str]] = None):
        """
        :param 'SourceSurveymonkeyConfigurationCredentialsArgs' credentials: The authorization method to use to retrieve data from SurveyMonkey
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param str origin: Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different. must be one of ["USA", "Europe", "Canada"]; Default: "USA"
        :param Sequence[str] survey_ids: IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if survey_ids is not None:
            pulumi.set(__self__, "survey_ids", survey_ids)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceSurveymonkeyConfigurationCredentials':
        """
        The authorization method to use to retrieve data from SurveyMonkey
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        """
        Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different. must be one of ["USA", "Europe", "Canada"]; Default: "USA"
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter(name="surveyIds")
    def survey_ids(self) -> Optional[Sequence[str]]:
        """
        IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
        """
        return pulumi.get(self, "survey_ids")


@pulumi.output_type
class SourceSurveymonkeyConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSurveymonkeyConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSurveymonkeyConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSurveymonkeyConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: Access Token for making authenticated requests. See the <a href="https://docs.airbyte.io/integrations/sources/surveymonkey">docs</a> for information on how to generate this key.
        :param str client_id: The Client ID of the SurveyMonkey developer application.
        :param str client_secret: The Client Secret of the SurveyMonkey developer application.
        """
        pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests. See the <a href="https://docs.airbyte.io/integrations/sources/surveymonkey">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of the SurveyMonkey developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of the SurveyMonkey developer application.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceTempoConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTempoConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTempoConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTempoConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class SourceTheGuardianApiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "endDate":
            suggest = "end_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTheGuardianApiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTheGuardianApiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTheGuardianApiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 start_date: str,
                 end_date: Optional[str] = None,
                 query: Optional[str] = None,
                 section: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str api_key: Your API Key. See <a href="https://open-platform.theguardian.com/access/">here</a>. The key is case sensitive.
        :param str start_date: Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the start_date will not be shown.
        :param str end_date: (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the end_date will not be shown. Default is set to the current date (today) for incremental syncs.
        :param str query: (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
        :param str section: (Optional) Use this to filter the results by a particular section. See <a href="https://content.guardianapis.com/sections?api-key=test">here</a> for a list of all sections, and <a href="https://open-platform.theguardian.com/documentation/section">here</a> for the sections endpoint documentation.
        :param str tag: (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See <a href="https://content.guardianapis.com/tags?api-key=test">here</a> for a list of all tags, and <a href="https://open-platform.theguardian.com/documentation/tag">here</a> for the tags endpoint documentation.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if section is not None:
            pulumi.set(__self__, "section", section)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key. See <a href="https://open-platform.theguardian.com/access/">here</a>. The key is case sensitive.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the start_date will not be shown.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the end_date will not be shown. Default is set to the current date (today) for incremental syncs.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def section(self) -> Optional[str]:
        """
        (Optional) Use this to filter the results by a particular section. See <a href="https://content.guardianapis.com/sections?api-key=test">here</a> for a list of all sections, and <a href="https://open-platform.theguardian.com/documentation/section">here</a> for the sections endpoint documentation.
        """
        return pulumi.get(self, "section")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See <a href="https://content.guardianapis.com/tags?api-key=test">here</a> for a list of all tags, and <a href="https://open-platform.theguardian.com/documentation/tag">here</a> for the tags endpoint documentation.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class SourceTiktokMarketingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributionWindow":
            suggest = "attribution_window"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "includeDeleted":
            suggest = "include_deleted"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTiktokMarketingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTiktokMarketingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTiktokMarketingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribution_window: Optional[int] = None,
                 credentials: Optional['outputs.SourceTiktokMarketingConfigurationCredentials'] = None,
                 end_date: Optional[str] = None,
                 include_deleted: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param int attribution_window: The attribution window in days. Default: 3
        :param 'SourceTiktokMarketingConfigurationCredentialsArgs' credentials: Authentication method
        :param str end_date: The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between start_date and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
        :param bool include_deleted: Set to active if you want to include deleted data in reports. Default: false
        :param str start_date: The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated. Default: "2016-09-01"
        """
        if attribution_window is not None:
            pulumi.set(__self__, "attribution_window", attribution_window)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if include_deleted is not None:
            pulumi.set(__self__, "include_deleted", include_deleted)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="attributionWindow")
    def attribution_window(self) -> Optional[int]:
        """
        The attribution window in days. Default: 3
        """
        return pulumi.get(self, "attribution_window")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceTiktokMarketingConfigurationCredentials']:
        """
        Authentication method
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between start_date and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="includeDeleted")
    def include_deleted(self) -> Optional[bool]:
        """
        Set to active if you want to include deleted data in reports. Default: false
        """
        return pulumi.get(self, "include_deleted")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated. Default: "2016-09-01"
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceTiktokMarketingConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth20":
            suggest = "o_auth20"
        elif key == "sandboxAccessToken":
            suggest = "sandbox_access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTiktokMarketingConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTiktokMarketingConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTiktokMarketingConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth20: Optional['outputs.SourceTiktokMarketingConfigurationCredentialsOAuth20'] = None,
                 sandbox_access_token: Optional['outputs.SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken'] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if sandbox_access_token is not None:
            pulumi.set(__self__, "sandbox_access_token", sandbox_access_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceTiktokMarketingConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")

    @property
    @pulumi.getter(name="sandboxAccessToken")
    def sandbox_access_token(self) -> Optional['outputs.SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken']:
        return pulumi.get(self, "sandbox_access_token")


@pulumi.output_type
class SourceTiktokMarketingConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "appId":
            suggest = "app_id"
        elif key == "advertiserId":
            suggest = "advertiser_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTiktokMarketingConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTiktokMarketingConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTiktokMarketingConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 app_id: str,
                 secret: str,
                 advertiser_id: Optional[str] = None):
        """
        :param str access_token: Long-term Authorized Access Token.
        :param str app_id: The Developer Application App ID.
        :param str secret: The Developer Application Secret.
        :param str advertiser_id: The Advertiser ID to filter reports and streams. Let this empty to retrieve all.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "app_id", app_id)
        pulumi.set(__self__, "secret", secret)
        if advertiser_id is not None:
            pulumi.set(__self__, "advertiser_id", advertiser_id)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Long-term Authorized Access Token.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> str:
        """
        The Developer Application App ID.
        """
        return pulumi.get(self, "app_id")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        The Developer Application Secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="advertiserId")
    def advertiser_id(self) -> Optional[str]:
        """
        The Advertiser ID to filter reports and streams. Let this empty to retrieve all.
        """
        return pulumi.get(self, "advertiser_id")


@pulumi.output_type
class SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "advertiserId":
            suggest = "advertiser_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 advertiser_id: str):
        """
        :param str access_token: The long-term authorized access token.
        :param str advertiser_id: The Advertiser ID which generated for the developer's Sandbox application.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "advertiser_id", advertiser_id)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The long-term authorized access token.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="advertiserId")
    def advertiser_id(self) -> str:
        """
        The Advertiser ID which generated for the developer's Sandbox application.
        """
        return pulumi.get(self, "advertiser_id")


@pulumi.output_type
class SourceTrelloConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "boardIds":
            suggest = "board_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTrelloConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTrelloConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTrelloConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 start_date: str,
                 token: str,
                 board_ids: Optional[Sequence[str]] = None):
        """
        :param str key: Trello API key. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        :param str start_date: UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        :param str token: Trello API token. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        :param Sequence[str] board_ids: IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated. Please note that this is not the 8-character ID in the board's shortLink (URL of the board). Rather, what is required here is the 24-character ID usually returned by the API
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "token", token)
        if board_ids is not None:
            pulumi.set(__self__, "board_ids", board_ids)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Trello API key. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        Trello API token. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
        """
        return pulumi.get(self, "token")

    @property
    @pulumi.getter(name="boardIds")
    def board_ids(self) -> Optional[Sequence[str]]:
        """
        IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated. Please note that this is not the 8-character ID in the board's shortLink (URL of the board). Rather, what is required here is the 24-character ID usually returned by the API
        """
        return pulumi.get(self, "board_ids")


@pulumi.output_type
class SourceTrustpilotConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "businessUnits":
            suggest = "business_units"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTrustpilotConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTrustpilotConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTrustpilotConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 business_units: Sequence[str],
                 credentials: 'outputs.SourceTrustpilotConfigurationCredentials',
                 start_date: str):
        """
        :param Sequence[str] business_units: The names of business units which shall be synchronized. Some streams e.g. configured_business_units or private_reviews use this configuration.
        :param str start_date: For streams with sync. method incremental the start date time to be used
        """
        pulumi.set(__self__, "business_units", business_units)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="businessUnits")
    def business_units(self) -> Sequence[str]:
        """
        The names of business units which shall be synchronized. Some streams e.g. configured_business_units or private_reviews use this configuration.
        """
        return pulumi.get(self, "business_units")

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceTrustpilotConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        For streams with sync. method incremental the start date time to be used
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceTrustpilotConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTrustpilotConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTrustpilotConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTrustpilotConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional['outputs.SourceTrustpilotConfigurationCredentialsApiKey'] = None,
                 o_auth20: Optional['outputs.SourceTrustpilotConfigurationCredentialsOAuth20'] = None):
        """
        :param 'SourceTrustpilotConfigurationCredentialsApiKeyArgs' api_key: The API key authentication method gives you access to only the streams which are part of the Public API. When you want to get streams available via the Consumer API (e.g. the private reviews) you need to use authentication method OAuth 2.0.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional['outputs.SourceTrustpilotConfigurationCredentialsApiKey']:
        """
        The API key authentication method gives you access to only the streams which are part of the Public API. When you want to get streams available via the Consumer API (e.g. the private reviews) you need to use authentication method OAuth 2.0.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceTrustpilotConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceTrustpilotConfigurationCredentialsApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTrustpilotConfigurationCredentialsApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTrustpilotConfigurationCredentialsApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTrustpilotConfigurationCredentialsApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: The API key of the Trustpilot API application.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The API key of the Trustpilot API application.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class SourceTrustpilotConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tokenExpiryDate":
            suggest = "token_expiry_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTrustpilotConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTrustpilotConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTrustpilotConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 token_expiry_date: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The API key of the Trustpilot API application. (represents the OAuth Client ID)
        :param str client_secret: The Secret of the Trustpilot API application. (represents the OAuth Client Secret)
        :param str refresh_token: The key to refresh the expired access_token.
        :param str token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The API key of the Trustpilot API application. (represents the OAuth Client ID)
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Secret of the Trustpilot API application. (represents the OAuth Client Secret)
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> str:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")


@pulumi.output_type
class SourceTvmazeScheduleConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domesticScheduleCountryCode":
            suggest = "domestic_schedule_country_code"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "webScheduleCountryCode":
            suggest = "web_schedule_country_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTvmazeScheduleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTvmazeScheduleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTvmazeScheduleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domestic_schedule_country_code: str,
                 start_date: str,
                 end_date: Optional[str] = None,
                 web_schedule_country_code: Optional[str] = None):
        """
        :param str domestic_schedule_country_code: Country code for domestic TV schedule retrieval.
        :param str start_date: Start date for TV schedule retrieval. May be in the future.
        :param str end_date: End date for TV schedule retrieval. May be in the future. Optional.
        :param str web_schedule_country_code: ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
               all countries plus global web channels (e.g. Netflix). Alternatively,
               set to 'global' for just global web channels.
        """
        pulumi.set(__self__, "domestic_schedule_country_code", domestic_schedule_country_code)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if web_schedule_country_code is not None:
            pulumi.set(__self__, "web_schedule_country_code", web_schedule_country_code)

    @property
    @pulumi.getter(name="domesticScheduleCountryCode")
    def domestic_schedule_country_code(self) -> str:
        """
        Country code for domestic TV schedule retrieval.
        """
        return pulumi.get(self, "domestic_schedule_country_code")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Start date for TV schedule retrieval. May be in the future.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        End date for TV schedule retrieval. May be in the future. Optional.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="webScheduleCountryCode")
    def web_schedule_country_code(self) -> Optional[str]:
        """
        ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
        all countries plus global web channels (e.g. Netflix). Alternatively,
        set to 'global' for just global web channels.
        """
        return pulumi.get(self, "web_schedule_country_code")


@pulumi.output_type
class SourceTwilioConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountSid":
            suggest = "account_sid"
        elif key == "authToken":
            suggest = "auth_token"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "lookbackWindow":
            suggest = "lookback_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTwilioConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTwilioConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTwilioConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_sid: str,
                 auth_token: str,
                 start_date: str,
                 lookback_window: Optional[int] = None):
        """
        :param str account_sid: Twilio account SID
        :param str auth_token: Twilio Auth Token.
        :param str start_date: UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
        :param int lookback_window: How far into the past to look for records. (in minutes). Default: 0
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "start_date", start_date)
        if lookback_window is not None:
            pulumi.set(__self__, "lookback_window", lookback_window)

    @property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> str:
        """
        Twilio account SID
        """
        return pulumi.get(self, "account_sid")

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        Twilio Auth Token.
        """
        return pulumi.get(self, "auth_token")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="lookbackWindow")
    def lookback_window(self) -> Optional[int]:
        """
        How far into the past to look for records. (in minutes). Default: 0
        """
        return pulumi.get(self, "lookback_window")


@pulumi.output_type
class SourceTwilioTaskrouterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountSid":
            suggest = "account_sid"
        elif key == "authToken":
            suggest = "auth_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTwilioTaskrouterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTwilioTaskrouterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTwilioTaskrouterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_sid: str,
                 auth_token: str):
        """
        :param str account_sid: Twilio Account ID
        :param str auth_token: Twilio Auth Token
        """
        pulumi.set(__self__, "account_sid", account_sid)
        pulumi.set(__self__, "auth_token", auth_token)

    @property
    @pulumi.getter(name="accountSid")
    def account_sid(self) -> str:
        """
        Twilio Account ID
        """
        return pulumi.get(self, "account_sid")

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        Twilio Auth Token
        """
        return pulumi.get(self, "auth_token")


@pulumi.output_type
class SourceTwitterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "endDate":
            suggest = "end_date"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTwitterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTwitterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTwitterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 query: str,
                 end_date: Optional[str] = None,
                 start_date: Optional[str] = None):
        """
        :param str api_key: App only Bearer Token. See the <a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens">docs</a> for more information on how to obtain this token.
        :param str query: Query for matching Tweets. You can learn how to build this query by reading <a href="https://developer.twitter.com/en/docs/twitter-api/tweets/search/integrate/build-a-query"> build a query guide </a>.
        :param str end_date: The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
        :param str start_date: The start date for retrieving tweets cannot be more than 7 days in the past.
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query", query)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        App only Bearer Token. See the <a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens">docs</a> for more information on how to obtain this token.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for matching Tweets. You can learn how to build this query by reading <a href="https://developer.twitter.com/en/docs/twitter-api/tweets/search/integrate/build-a-query"> build a query guide </a>.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
        """
        return pulumi.get(self, "end_date")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The start date for retrieving tweets cannot be more than 7 days in the past.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceTypeformConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formIds":
            suggest = "form_ids"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTypeformConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTypeformConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTypeformConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: 'outputs.SourceTypeformConfigurationCredentials',
                 form_ids: Optional[Sequence[str]] = None,
                 start_date: Optional[str] = None):
        """
        :param Sequence[str] form_ids: When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the form_id is u6nXL7. You can find form URLs on Share panel
        :param str start_date: The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "credentials", credentials)
        if form_ids is not None:
            pulumi.set(__self__, "form_ids", form_ids)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceTypeformConfigurationCredentials':
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="formIds")
    def form_ids(self) -> Optional[Sequence[str]]:
        """
        When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the form_id is u6nXL7. You can find form URLs on Share panel
        """
        return pulumi.get(self, "form_ids")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceTypeformConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oAuth20":
            suggest = "o_auth20"
        elif key == "privateToken":
            suggest = "private_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTypeformConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTypeformConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTypeformConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 o_auth20: Optional['outputs.SourceTypeformConfigurationCredentialsOAuth20'] = None,
                 private_token: Optional['outputs.SourceTypeformConfigurationCredentialsPrivateToken'] = None):
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)
        if private_token is not None:
            pulumi.set(__self__, "private_token", private_token)

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceTypeformConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")

    @property
    @pulumi.getter(name="privateToken")
    def private_token(self) -> Optional['outputs.SourceTypeformConfigurationCredentialsPrivateToken']:
        return pulumi.get(self, "private_token")


@pulumi.output_type
class SourceTypeformConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "tokenExpiryDate":
            suggest = "token_expiry_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTypeformConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTypeformConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTypeformConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 token_expiry_date: str):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The Client ID of the Typeform developer application.
        :param str client_secret: The Client Secret the Typeform developer application.
        :param str refresh_token: The key to refresh the expired access_token.
        :param str token_expiry_date: The date-time when the access token should be refreshed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        pulumi.set(__self__, "token_expiry_date", token_expiry_date)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of the Typeform developer application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret the Typeform developer application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        The key to refresh the expired access_token.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="tokenExpiryDate")
    def token_expiry_date(self) -> str:
        """
        The date-time when the access token should be refreshed.
        """
        return pulumi.get(self, "token_expiry_date")


@pulumi.output_type
class SourceTypeformConfigurationCredentialsPrivateToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTypeformConfigurationCredentialsPrivateToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTypeformConfigurationCredentialsPrivateToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTypeformConfigurationCredentialsPrivateToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: Log into your Typeform account and then generate a personal Access Token.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Log into your Typeform account and then generate a personal Access Token.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceUsCensusConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "queryPath":
            suggest = "query_path"
        elif key == "queryParams":
            suggest = "query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceUsCensusConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceUsCensusConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceUsCensusConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 query_path: str,
                 query_params: Optional[str] = None):
        """
        :param str api_key: Your API Key. Get your key <a href="https://api.census.gov/data/key_signup.html">here</a>.
        :param str query_path: The path portion of the GET request
        :param str query_params: The query parameters portion of the GET request, without the api key
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "query_path", query_path)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key. Get your key <a href="https://api.census.gov/data/key_signup.html">here</a>.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="queryPath")
    def query_path(self) -> str:
        """
        The path portion of the GET request
        """
        return pulumi.get(self, "query_path")

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[str]:
        """
        The query parameters portion of the GET request, without the api key
        """
        return pulumi.get(self, "query_params")


@pulumi.output_type
class SourceVantageConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceVantageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceVantageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceVantageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: Your API Access token. See <a href="https://vantage.readme.io/reference/authentication">here</a>.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Your API Access token. See <a href="https://vantage.readme.io/reference/authentication">here</a>.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceWebflowConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "siteId":
            suggest = "site_id"
        elif key == "acceptVersion":
            suggest = "accept_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceWebflowConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceWebflowConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceWebflowConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 site_id: str,
                 accept_version: Optional[str] = None):
        """
        :param str api_key: The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
        :param str site_id: The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
        :param str accept_version: The version of the Webflow API to use. See https://developers.webflow.com/#versioning
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "site_id", site_id)
        if accept_version is not None:
            pulumi.set(__self__, "accept_version", accept_version)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="siteId")
    def site_id(self) -> str:
        """
        The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
        """
        return pulumi.get(self, "site_id")

    @property
    @pulumi.getter(name="acceptVersion")
    def accept_version(self) -> Optional[str]:
        """
        The version of the Webflow API to use. See https://developers.webflow.com/#versioning
        """
        return pulumi.get(self, "accept_version")


@pulumi.output_type
class SourceWhiskyHunterConfiguration(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceWikipediaPageviewsConfiguration(dict):
    def __init__(__self__, *,
                 access: str,
                 agent: str,
                 article: str,
                 country: str,
                 end: str,
                 project: str,
                 start: str):
        """
        :param str access: If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
        :param str agent: If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
        :param str article: The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
        :param str country: The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
        :param str end: The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
        :param str project: If you want to filter by project, use the domain of any Wikimedia project.
        :param str start: The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format.
        """
        pulumi.set(__self__, "access", access)
        pulumi.set(__self__, "agent", agent)
        pulumi.set(__self__, "article", article)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def access(self) -> str:
        """
        If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
        """
        return pulumi.get(self, "access")

    @property
    @pulumi.getter
    def agent(self) -> str:
        """
        If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
        """
        return pulumi.get(self, "agent")

    @property
    @pulumi.getter
    def article(self) -> str:
        """
        The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
        """
        return pulumi.get(self, "article")

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def end(self) -> str:
        """
        The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        If you want to filter by project, use the domain of any Wikimedia project.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class SourceWoocommerceConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "apiSecret":
            suggest = "api_secret"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceWoocommerceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceWoocommerceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceWoocommerceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: str,
                 api_secret: str,
                 shop: str,
                 start_date: str):
        """
        :param str api_key: Customer Key for API in WooCommerce shop
        :param str api_secret: Customer Secret for API in WooCommerce shop
        :param str shop: The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
        :param str start_date: The date you would like to replicate data from. Format: YYYY-MM-DD
        """
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_secret", api_secret)
        pulumi.set(__self__, "shop", shop)
        pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Customer Key for API in WooCommerce shop
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiSecret")
    def api_secret(self) -> str:
        """
        Customer Secret for API in WooCommerce shop
        """
        return pulumi.get(self, "api_secret")

    @property
    @pulumi.getter
    def shop(self) -> str:
        """
        The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
        """
        return pulumi.get(self, "shop")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date you would like to replicate data from. Format: YYYY-MM-DD
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceXkcdConfiguration(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SourceYandexMetricaConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authToken":
            suggest = "auth_token"
        elif key == "counterId":
            suggest = "counter_id"
        elif key == "startDate":
            suggest = "start_date"
        elif key == "endDate":
            suggest = "end_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceYandexMetricaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceYandexMetricaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceYandexMetricaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_token: str,
                 counter_id: str,
                 start_date: str,
                 end_date: Optional[str] = None):
        """
        :param str auth_token: Your Yandex Metrica API access token
        :param str counter_id: Counter ID
        :param str start_date: Starting point for your data replication, in format of "YYYY-MM-DD".
        :param str end_date: Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
        """
        pulumi.set(__self__, "auth_token", auth_token)
        pulumi.set(__self__, "counter_id", counter_id)
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> str:
        """
        Your Yandex Metrica API access token
        """
        return pulumi.get(self, "auth_token")

    @property
    @pulumi.getter(name="counterId")
    def counter_id(self) -> str:
        """
        Counter ID
        """
        return pulumi.get(self, "counter_id")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Starting point for your data replication, in format of "YYYY-MM-DD".
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[str]:
        """
        Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
        """
        return pulumi.get(self, "end_date")


@pulumi.output_type
class SourceYotpoConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "appKey":
            suggest = "app_key"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceYotpoConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceYotpoConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceYotpoConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 app_key: str,
                 start_date: str,
                 email: Optional[str] = None):
        """
        :param str access_token: Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
        :param str app_key: App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
        :param str start_date: Date time filter for incremental filter, Specify which date to extract from.
        :param str email: Email address registered with yotpo. Default: "example@gmail.com"
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "app_key", app_key)
        pulumi.set(__self__, "start_date", start_date)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="appKey")
    def app_key(self) -> str:
        """
        App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
        """
        return pulumi.get(self, "app_key")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        Date time filter for incremental filter, Specify which date to extract from.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Email address registered with yotpo. Default: "example@gmail.com"
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class SourceYoutubeAnalyticsConfiguration(dict):
    def __init__(__self__, *,
                 credentials: 'outputs.SourceYoutubeAnalyticsConfigurationCredentials'):
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def credentials(self) -> 'outputs.SourceYoutubeAnalyticsConfigurationCredentials':
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceYoutubeAnalyticsConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceYoutubeAnalyticsConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceYoutubeAnalyticsConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceYoutubeAnalyticsConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 refresh_token: str,
                 additional_properties: Optional[str] = None):
        """
        :param str client_id: The Client ID of your developer application
        :param str client_secret: The client secret of your developer application
        :param str refresh_token: A refresh token generated using the above client ID and secret
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your developer application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret of your developer application
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        A refresh token generated using the above client ID and secret
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceZendeskChatConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskChatConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskChatConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskChatConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 credentials: Optional['outputs.SourceZendeskChatConfigurationCredentials'] = None,
                 subdomain: Optional[str] = None):
        """
        :param str start_date: The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
        :param str subdomain: Required if you access Zendesk Chat from a Zendesk Support subdomain. Default: ""
        """
        pulumi.set(__self__, "start_date", start_date)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if subdomain is not None:
            pulumi.set(__self__, "subdomain", subdomain)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceZendeskChatConfigurationCredentials']:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def subdomain(self) -> Optional[str]:
        """
        Required if you access Zendesk Chat from a Zendesk Support subdomain. Default: ""
        """
        return pulumi.get(self, "subdomain")


@pulumi.output_type
class SourceZendeskChatConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskChatConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskChatConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskChatConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional['outputs.SourceZendeskChatConfigurationCredentialsAccessToken'] = None,
                 o_auth20: Optional['outputs.SourceZendeskChatConfigurationCredentialsOAuth20'] = None):
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional['outputs.SourceZendeskChatConfigurationCredentialsAccessToken']:
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceZendeskChatConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceZendeskChatConfigurationCredentialsAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskChatConfigurationCredentialsAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskChatConfigurationCredentialsAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskChatConfigurationCredentialsAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str):
        """
        :param str access_token: The Access Token to make authenticated requests.
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The Access Token to make authenticated requests.
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class SourceZendeskChatConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "refreshToken":
            suggest = "refresh_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskChatConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskChatConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskChatConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 refresh_token: Optional[str] = None):
        """
        :param str access_token: Access Token for making authenticated requests.
        :param str client_id: The Client ID of your OAuth application
        :param str client_secret: The Client Secret of your OAuth application.
        :param str refresh_token: Refresh Token to obtain new Access Token, when it's expired.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[str]:
        """
        Access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The Client ID of your OAuth application
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[str]:
        """
        Refresh Token to obtain new Access Token, when it's expired.
        """
        return pulumi.get(self, "refresh_token")


@pulumi.output_type
class SourceZendeskSellConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSellConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSellConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSellConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str):
        """
        :param str api_token: The API token for authenticating to Zendesk Sell
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The API token for authenticating to Zendesk Sell
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class SourceZendeskSunshineConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSunshineConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSunshineConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSunshineConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 subdomain: str,
                 credentials: Optional['outputs.SourceZendeskSunshineConfigurationCredentials'] = None):
        """
        :param str start_date: The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
        :param str subdomain: The subdomain for your Zendesk Account.
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "subdomain", subdomain)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        The subdomain for your Zendesk Account.
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceZendeskSunshineConfigurationCredentials']:
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceZendeskSunshineConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSunshineConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSunshineConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSunshineConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.SourceZendeskSunshineConfigurationCredentialsApiToken'] = None,
                 o_auth20: Optional['outputs.SourceZendeskSunshineConfigurationCredentialsOAuth20'] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.SourceZendeskSunshineConfigurationCredentialsApiToken']:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceZendeskSunshineConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceZendeskSunshineConfigurationCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSunshineConfigurationCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSunshineConfigurationCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSunshineConfigurationCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 email: str):
        """
        :param str api_token: API Token. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk_sunshine">docs</a> for information on how to generate this key.
        :param str email: The user email for your Zendesk account
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        API Token. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk_sunshine">docs</a> for information on how to generate this key.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The user email for your Zendesk account
        """
        return pulumi.get(self, "email")


@pulumi.output_type
class SourceZendeskSunshineConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSunshineConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSunshineConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSunshineConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 client_id: str,
                 client_secret: str):
        """
        :param str access_token: Long-term access Token for making authenticated requests.
        :param str client_id: The Client ID of your OAuth application.
        :param str client_secret: The Client Secret of your OAuth application.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Long-term access Token for making authenticated requests.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The Client ID of your OAuth application.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The Client Secret of your OAuth application.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceZendeskSupportConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignorePagination":
            suggest = "ignore_pagination"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSupportConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSupportConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSupportConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subdomain: str,
                 credentials: Optional['outputs.SourceZendeskSupportConfigurationCredentials'] = None,
                 ignore_pagination: Optional[bool] = None,
                 start_date: Optional[str] = None):
        """
        :param str subdomain: This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY_SUBDOMAIN.zendesk.com/, MY_SUBDOMAIN is the value of your subdomain.
        :param 'SourceZendeskSupportConfigurationCredentialsArgs' credentials: Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
        :param bool ignore_pagination: Makes each stream read a single page of data. Default: false
        :param str start_date: The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        pulumi.set(__self__, "subdomain", subdomain)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if ignore_pagination is not None:
            pulumi.set(__self__, "ignore_pagination", ignore_pagination)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY_SUBDOMAIN.zendesk.com/, MY_SUBDOMAIN is the value of your subdomain.
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceZendeskSupportConfigurationCredentials']:
        """
        Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="ignorePagination")
    def ignore_pagination(self) -> Optional[bool]:
        """
        Makes each stream read a single page of data. Default: false
        """
        return pulumi.get(self, "ignore_pagination")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[str]:
        """
        The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class SourceZendeskSupportConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSupportConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSupportConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSupportConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.SourceZendeskSupportConfigurationCredentialsApiToken'] = None,
                 o_auth20: Optional['outputs.SourceZendeskSupportConfigurationCredentialsOAuth20'] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.SourceZendeskSupportConfigurationCredentialsApiToken']:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceZendeskSupportConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceZendeskSupportConfigurationCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSupportConfigurationCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSupportConfigurationCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSupportConfigurationCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 email: str,
                 additional_properties: Optional[str] = None):
        """
        :param str api_token: The value of the API token generated. See our <a href="https://docs.airbyte.com/integrations/sources/zendesk-support#setup-guide">full documentation</a> for more information on generating this token.
        :param str email: The user email for your Zendesk account.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "email", email)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The value of the API token generated. See our <a href="https://docs.airbyte.com/integrations/sources/zendesk-support#setup-guide">full documentation</a> for more information on generating this token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The user email for your Zendesk account.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceZendeskSupportConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskSupportConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskSupportConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskSupportConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 additional_properties: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: The OAuth access token. See the <a href="https://developer.zendesk.com/documentation/ticketing/working-with-oauth/creating-and-using-oauth-tokens-with-the-api/">Zendesk docs</a> for more information on generating this token.
        :param str additional_properties: Parsed as JSON.
        :param str client_id: The OAuth client's ID. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        :param str client_secret: The OAuth client secret. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        """
        pulumi.set(__self__, "access_token", access_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The OAuth access token. See the <a href="https://developer.zendesk.com/documentation/ticketing/working-with-oauth/creating-and-using-oauth-tokens-with-the-api/">Zendesk docs</a> for more information on generating this token.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The OAuth client's ID. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The OAuth client secret. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceZendeskTalkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskTalkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskTalkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskTalkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 start_date: str,
                 subdomain: str,
                 credentials: Optional['outputs.SourceZendeskTalkConfigurationCredentials'] = None):
        """
        :param str start_date: The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        :param str subdomain: This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY_SUBDOMAIN}.zendesk.com/, where MY_SUBDOMAIN is the value of your subdomain.
        :param 'SourceZendeskTalkConfigurationCredentialsArgs' credentials: Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
        """
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "subdomain", subdomain)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter
    def subdomain(self) -> str:
        """
        This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY_SUBDOMAIN}.zendesk.com/, where MY_SUBDOMAIN is the value of your subdomain.
        """
        return pulumi.get(self, "subdomain")

    @property
    @pulumi.getter
    def credentials(self) -> Optional['outputs.SourceZendeskTalkConfigurationCredentials']:
        """
        Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
        """
        return pulumi.get(self, "credentials")


@pulumi.output_type
class SourceZendeskTalkConfigurationCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "oAuth20":
            suggest = "o_auth20"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskTalkConfigurationCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskTalkConfigurationCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskTalkConfigurationCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional['outputs.SourceZendeskTalkConfigurationCredentialsApiToken'] = None,
                 o_auth20: Optional['outputs.SourceZendeskTalkConfigurationCredentialsOAuth20'] = None):
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if o_auth20 is not None:
            pulumi.set(__self__, "o_auth20", o_auth20)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional['outputs.SourceZendeskTalkConfigurationCredentialsApiToken']:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="oAuth20")
    def o_auth20(self) -> Optional['outputs.SourceZendeskTalkConfigurationCredentialsOAuth20']:
        return pulumi.get(self, "o_auth20")


@pulumi.output_type
class SourceZendeskTalkConfigurationCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskTalkConfigurationCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskTalkConfigurationCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskTalkConfigurationCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 email: str,
                 additional_properties: Optional[str] = None):
        """
        :param str api_token: The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        :param str email: The user email for your Zendesk account.
        :param str additional_properties: Parsed as JSON.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "email", email)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The user email for your Zendesk account.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")


@pulumi.output_type
class SourceZendeskTalkConfigurationCredentialsOAuth20(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZendeskTalkConfigurationCredentialsOAuth20. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZendeskTalkConfigurationCredentialsOAuth20.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZendeskTalkConfigurationCredentialsOAuth20.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 additional_properties: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None):
        """
        :param str access_token: The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        :param str additional_properties: Parsed as JSON.
        :param str client_id: Client ID
        :param str client_secret: Client Secret
        """
        pulumi.set(__self__, "access_token", access_token)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[str]:
        """
        Parsed as JSON.
        """
        return pulumi.get(self, "additional_properties")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Client Secret
        """
        return pulumi.get(self, "client_secret")


@pulumi.output_type
class SourceZenloopConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "dateFrom":
            suggest = "date_from"
        elif key == "surveyGroupId":
            suggest = "survey_group_id"
        elif key == "surveyId":
            suggest = "survey_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZenloopConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZenloopConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZenloopConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: str,
                 date_from: Optional[str] = None,
                 survey_group_id: Optional[str] = None,
                 survey_id: Optional[str] = None):
        """
        :param str api_token: Zenloop API Token. You can get the API token in settings page <a href="https://app.zenloop.com/settings/api">here</a>
        :param str date_from: Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
        :param str survey_group_id: Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
        :param str survey_id: Zenloop Survey ID. Can be found <a href="https://app.zenloop.com/settings/api">here</a>. Leave empty to pull answers from all surveys
        """
        pulumi.set(__self__, "api_token", api_token)
        if date_from is not None:
            pulumi.set(__self__, "date_from", date_from)
        if survey_group_id is not None:
            pulumi.set(__self__, "survey_group_id", survey_group_id)
        if survey_id is not None:
            pulumi.set(__self__, "survey_id", survey_id)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Zenloop API Token. You can get the API token in settings page <a href="https://app.zenloop.com/settings/api">here</a>
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="dateFrom")
    def date_from(self) -> Optional[str]:
        """
        Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
        """
        return pulumi.get(self, "date_from")

    @property
    @pulumi.getter(name="surveyGroupId")
    def survey_group_id(self) -> Optional[str]:
        """
        Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
        """
        return pulumi.get(self, "survey_group_id")

    @property
    @pulumi.getter(name="surveyId")
    def survey_id(self) -> Optional[str]:
        """
        Zenloop Survey ID. Can be found <a href="https://app.zenloop.com/settings/api">here</a>. Leave empty to pull answers from all surveys
        """
        return pulumi.get(self, "survey_id")


@pulumi.output_type
class SourceZohoCrmConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "dcRegion":
            suggest = "dc_region"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "startDatetime":
            suggest = "start_datetime"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZohoCrmConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZohoCrmConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZohoCrmConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret: str,
                 dc_region: str,
                 environment: str,
                 refresh_token: str,
                 edition: Optional[str] = None,
                 start_datetime: Optional[str] = None):
        """
        :param str client_id: OAuth2.0 Client ID
        :param str client_secret: OAuth2.0 Client Secret
        :param str dc_region: Please choose the region of your Data Center location. More info by this <a href="https://www.zoho.com/crm/developer/docs/api/v2/multi-dc.html">Link</a>. must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
        :param str environment: Please choose the environment. must be one of ["Production", "Developer", "Sandbox"]
        :param str refresh_token: OAuth2.0 Refresh Token
        :param str edition: Choose your Edition of Zoho CRM to determine API Concurrency Limits. must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]; Default: "Free"
        :param str start_datetime: ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "dc_region", dc_region)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "refresh_token", refresh_token)
        if edition is not None:
            pulumi.set(__self__, "edition", edition)
        if start_datetime is not None:
            pulumi.set(__self__, "start_datetime", start_datetime)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        OAuth2.0 Client ID
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        OAuth2.0 Client Secret
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="dcRegion")
    def dc_region(self) -> str:
        """
        Please choose the region of your Data Center location. More info by this <a href="https://www.zoho.com/crm/developer/docs/api/v2/multi-dc.html">Link</a>. must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
        """
        return pulumi.get(self, "dc_region")

    @property
    @pulumi.getter
    def environment(self) -> str:
        """
        Please choose the environment. must be one of ["Production", "Developer", "Sandbox"]
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> str:
        """
        OAuth2.0 Refresh Token
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter
    def edition(self) -> Optional[str]:
        """
        Choose your Edition of Zoho CRM to determine API Concurrency Limits. must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]; Default: "Free"
        """
        return pulumi.get(self, "edition")

    @property
    @pulumi.getter(name="startDatetime")
    def start_datetime(self) -> Optional[str]:
        """
        ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
        """
        return pulumi.get(self, "start_datetime")


@pulumi.output_type
class SourceZoomConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "authorizationEndpoint":
            suggest = "authorization_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceZoomConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceZoomConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceZoomConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 client_id: str,
                 client_secret: str,
                 authorization_endpoint: Optional[str] = None):
        """
        :param str account_id: The account ID for your Zoom account. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        :param str client_id: The client ID for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        :param str client_secret: The client secret for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        :param str authorization_endpoint: Default: "https://zoom.us/oauth/token"
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        The account ID for your Zoom account. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client ID for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> str:
        """
        The client secret for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        Default: "https://zoom.us/oauth/token"
        """
        return pulumi.get(self, "authorization_endpoint")


@pulumi.output_type
class GetConnectionConfigurationsResult(dict):
    def __init__(__self__, *,
                 streams: Sequence['outputs.GetConnectionConfigurationsStreamResult']):
        pulumi.set(__self__, "streams", streams)

    @property
    @pulumi.getter
    def streams(self) -> Sequence['outputs.GetConnectionConfigurationsStreamResult']:
        return pulumi.get(self, "streams")


@pulumi.output_type
class GetConnectionConfigurationsStreamResult(dict):
    def __init__(__self__, *,
                 cursor_fields: Sequence[str],
                 name: str,
                 primary_keys: Sequence[Sequence[str]],
                 sync_mode: str):
        """
        :param Sequence[str] cursor_fields: Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
        :param Sequence[Sequence[str]] primary_keys: Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
        :param str sync_mode: must be one of ["full_refresh_overwrite", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
        """
        pulumi.set(__self__, "cursor_fields", cursor_fields)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_keys", primary_keys)
        pulumi.set(__self__, "sync_mode", sync_mode)

    @property
    @pulumi.getter(name="cursorFields")
    def cursor_fields(self) -> Sequence[str]:
        """
        Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
        """
        return pulumi.get(self, "cursor_fields")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Sequence[Sequence[str]]:
        """
        Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
        """
        return pulumi.get(self, "primary_keys")

    @property
    @pulumi.getter(name="syncMode")
    def sync_mode(self) -> str:
        """
        must be one of ["full_refresh_overwrite", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
        """
        return pulumi.get(self, "sync_mode")


@pulumi.output_type
class GetConnectionScheduleResult(dict):
    def __init__(__self__, *,
                 basic_timing: str,
                 cron_expression: str,
                 schedule_type: str):
        """
        :param str schedule_type: must be one of ["manual", "cron", "basic"]
        """
        pulumi.set(__self__, "basic_timing", basic_timing)
        pulumi.set(__self__, "cron_expression", cron_expression)
        pulumi.set(__self__, "schedule_type", schedule_type)

    @property
    @pulumi.getter(name="basicTiming")
    def basic_timing(self) -> str:
        return pulumi.get(self, "basic_timing")

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> str:
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> str:
        """
        must be one of ["manual", "cron", "basic"]
        """
        return pulumi.get(self, "schedule_type")


